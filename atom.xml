<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曾经浮华的小窝</title>
  
  <subtitle>hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaocc.xyz/"/>
  <updated>2022-06-06T08:45:58.497Z</updated>
  <id>http://www.xiaocc.xyz/</id>
  
  <author>
    <name>曾经浮华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年终总结</title>
    <link href="http://www.xiaocc.xyz/2022-01-15/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://www.xiaocc.xyz/2022-01-15/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-01-15T01:00:00.000Z</published>
    <updated>2022-06-06T08:45:58.497Z</updated>
    
    <content type="html"><![CDATA[<p>对的，你没看错，这是一篇2020年终总结</p><a id="more"></a><p>现在是2022年，补充一篇2020年终总结，听起来挺奇怪，这迟到的总结有什么意义呢？</p><p>一方面，可以趁着不忙的这个周五，回味一下逝去的时光，写点东西留作纪念，以免再过个三五年遗忘2020年都经历些什么。</p><p>另一方面，年终总结虽会迟到，但永不缺席，哈哈</p><p>现在凭着记忆返回波荡起伏的2020年</p><h4><span id="疫情">疫情</span></h4><p>这一年对所有人影响最大的事情就是疫情，由于娃在2019年12月19日出生，到2020年春节才刚满月，早就决定这年春节不回老家过年，而是让我姐从武汉到上海，一起在这个熟悉而又陌生的城市度过春节假期。</p><p>1月7日，部门年会，由于我们部门主体在深圳，所以上海组集体坐飞机去往那儿，吃饭、抽奖、表演节目、拍照，大家玩得很开心。</p><p>当我返回上海，却连续拉肚子、精神萎靡三四天，找公司医疗服务台咨询，反馈是水土不服，拿了点药吃，没当回事，修养几天慢慢好了，后来想想，还好不是新冠。</p><p>1月中旬，群里突传武汉有SARS，微博、公司同事开始有这方面讨论，但官方消息压得比较严，说没问题</p><p>叮嘱姐在武汉小心点</p><p>1月20日左右，消息传播得比较广了，也有医疗组到武汉，并且钟南山说有人传人</p><p>完蛋，这个时候，整个上海才开始警觉起来，慌得一比，还好即将放春节假，因为有提前请假回家的同事，所以公司人不多</p><p>1月21号，姐坐动车从武汉到上海，双层口罩，全副武装，全程连水都没喝一杯</p><p>到家就酒精喷雾消毒，洗澡，这之后才让她抱宝宝</p><p>全家人提心吊胆的，生怕她有感染，社区也需要流动人口报备，每日三次测温上报</p><p>开始足不出户</p><p>1月23日，是一个难忘的日子，武汉封城</p><p>这之后大家更慌了，到处抢口罩，买不到，还得感谢亲戚从岳阳寄点给我们使用</p><p>随后这一个月，每周去超市买一次菜，其它时间，闭门不出，在家带娃</p><h4><span id="春节">春节</span></h4><p>春节在家，每天就是关注新闻，关注疫情人数及扩散到的城市，及各地管控措施等等</p><p>初几的某天，早上刚起床，照常刷新闻，有报道科比去世，我当然是不信的，因为那段混乱的时间，各种谣言假消息满天飞</p><p>经过多个平台相互确认，老大居然真的走了，从高中就开始看他的比赛，2016年看着他最后一场比赛拿61分</p><p>挺突然的，有点懵，当时想，人生就是这样无常，再拼命工作，赚再多钱，人没了，有什么意义呢</p><p>这种感触与情绪持续时间并不长，很快就被工作群各种信息及艾特拉回现实</p><p>我只是一个打工人，上有老，下有小，是家里的顶梁柱，整个家庭需要我支撑</p><p>其它时间就是关注武汉火神山、雷神山医院的建设，及全国各地医疗援助情况，关注疫情发展态势</p><h4><span id="宝宝生病">宝宝生病</span></h4><p>在这疫情的紧要关头，家里娃吐奶，流鼻涕，生长慢，发烧，没办法，只有去医院处理</p><p>我那鄂A武汉牌照的车肯定是不敢出门</p><p>打车到儿童医院，由于湖北籍的身份证，对我们行程询问特别仔细，在那个疫情刚发生的时间点，还没有核酸检测一说，连是什么病毒都未弄清楚</p><p>好在娃病情不严重，开了点药，回家吃，继续宅着</p><h4><span id="疫情好转">疫情好转</span></h4><p>过了14天，大家都挺好，放心了，万幸，姐从武汉来未感染病毒，不然一家人不知道如何应对</p><p>有姐帮着带娃，我也能轻松点，睡个好觉</p><p>她晚上带娃，白天补觉，我负责白天带</p><p>在这样的日子中一天天度过</p><p>对病毒及疫情的处理，也逐渐有章法，不再慌乱</p><p>疫情逐渐好转</p><p>公司依然是在家办公，直到2月中旬才相互轮换着到公司报道</p><p>2月底的某天，姐所在公司的财务负责人，约50岁，感染新冠去世，震惊</p><p>才感触到每天新闻播报的死亡人数不是一个数字，是鲜活的生命，后面是一个个家庭</p><h4><span id="业务转型与封闭">业务转型与封闭</span></h4><p>小组所做业务经过两年探索，效果不明显，决定抽调一部分人去做新业务，由于是个大项目，涉及多方合作，需要在深圳封闭开发MVP版本</p><p>领导同步信息说最多封闭半个月，我们当然都是不信</p><p>大环境如此，又是疫情，没办法，只能硬着头皮干</p><p>就这样，三波研发(上海、成都、深圳) + 产品(成都)，到滨海大厦进行封闭开发，做直播带货</p><p>直播的火刚烧起来，这故事领导给大领导一讲，都觉得十分有搞头</p><p>我们白天黑夜的开发，强度相当之大，半个月就开发出来第一版，给大老板体验，收到反馈，继续优化</p><p>每天忙活到凌晨2-3点，特别是对我这种大龄员工，有点顶不住，回到酒店，躺在床上久久不能入眠</p><p>这种日子的意义在哪里，钱又不多，还忙得飞起，甚至有猝死风险</p><h4><span id="上海-深圳两地跑">上海-深圳两地跑</span></h4><p>第一个版本，算是拼命的赶出来，离领导说的封闭半个月又过去了一周</p><p>我们找领导聊这事儿，私下想着，三地研发把功能划分，回归base地，远程协助</p><p>哪知还有二期版本开发和客户试运营，听到这心里哇凉哇凉的，不知要封闭到猴年马月</p><p>领导答应大家，每两周可以回base地探亲一次，公司报销，也行吧，聊以慰藉</p><p>虽然怨声载道，但是没有更好的选择，大家只能硬撑着，一股负面情绪在四处扩散</p><p>现实中思想的巨人、行动的矮子比较多，大部分同事都只是嘴上抱怨干得不爽、太累、要跳槽，可是真正付出行动的少之又少</p><p>抱怨不解决问题，所以请闭上嘴巴，拿出实际行动</p><p>这个时候，娃才半岁不到，老爸我为了生活，只能在外奔波</p><p>就此开启两地飞行生活</p><h4><span id="准备离职">准备离职</span></h4><p>经过一个半月的封闭，身心疲惫</p><p>经过对产品形态以及研发人员结构分析，我认为：</p><p>本部门的大领导base均在深圳，这次拉上海 + 成都紧急协作，只是因为深圳开发人员不足，就是拼了命干，这个项目火了，咱们不一定能捞到好处</p><p>上海这边连公司任命的组长都没一个，在领导那里太卑微，就是一外包角色，未来难以发展</p><p>就此开始了刷题复习及相关资料准备，为跳槽做准备</p><p>你能想象，每晚凌晨1点下班，再复习1h的日子吗</p><p>经过2周的准备，开始面试流程，再经过三周的面试周期</p><p>这段难熬的日子，终于拨云见日，拿到offer，心里有谱，稳了</p><h4><span id="跑路">跑路</span></h4><p>7月10日，距离5月1日到深圳开始封闭算起，已经快3个月，高强度工作的日子，时光总是过得很快</p><p>这天开总结大会，总算是要放我们回base地，而在此之前会找大家聊涨薪事宜</p><p>涨薪与否并不影响我跑路，但还是会好奇，会给打发多少</p><p>具体数额不说了，只是沟通时候，有几句话，我到现在依然记得很清晰</p><blockquote><p>在带货这个项目中，你工作尽心，很好的完成需求落地与项目推动、人员管理，表现不错，特额外给你申请RSU鼓励，希望你在未来的项目中继续加油，好好干</p></blockquote><p>但是看看RSU数额，我苦涩的笑了</p><p>回到上海后不久，我就给领导提了离职</p><p>不是因为钱，是我想换个行业，搞金融与区块链</p><p>这当然是谎话，因为那段时间，互联网公司竞业非常严重，你要是说实话，下家肯定无法入职</p><p>几天之后，我在合川路科技绿洲入职</p><h4><span id="入职字节">入职字节</span></h4><p>入职字节的工作感受，及与腾讯工作体验各方面对比，会详细写一篇，这里先简单记录工作历程</p><p>在字节工作最大的感受，唯一不变的就是变化，从入职到2020年底，共计4个月，换了5次方向，搬了3次工位</p><p>7月底入职字节，起初负责社群收书模块，跟随模块负责人做了一个需求，熟悉技术栈及工作流程<br>半个月后，功能交接，模块负责人离职，我做的一点点东西也随之交接</p><p>然后看了一周的拍搜模块，熟悉处理逻辑与链路，不久后，社区方向出现多个重大事故，我随之调整过去负责质量与稳定性建设</p><p>9月-10月负责学生社区板块，主要是梳理代码质量与逻辑结构、对不合理设计进行重构，增加服务质量建设，包括监控告警及容灾</p><p>十一国庆回来，产品层面梳理社区价值，通过用户调研 + 数据分析，发现社区对于app整体留存提升正向不明显，而内容类功能涉及运营、审核等，却会消耗大量资源<br>基于此类信息，进行社区价值复盘，结论就是优先级调低，探索其它功能</p><p>11月初，我重新负责拍搜系统，提出建设拍搜平台的设想，并对之前流程不合理处进行设计重构</p><p>这次调整后，平台建设刚起步，部门组织架构调整，产品层面提出对标竞品，开发一个专门针对学生的app</p><p>这次紧急项目从各组抽调大量人员，我整体负责业务侧服务端，需要对齐人力、刨除风险，保证项目各个关键时间节点按时交付</p><p>从12月初开始封闭开发，需求对齐、任务拆解、人员分配、设计方案输出与review、开发、测试，一直忙到12月底进行一轮测试</p><h4><span id="变化的一年">变化的一年</span></h4><p>2020年，不管是社会层面遭受新冠疫情、科比去世、工作变动，还是加入字节后负责内容不断变化<br>这一年太让人印象深刻，所有的变化如潮水一般向人涌来，最后在新年贺词中结束了这一年</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对的，你没看错，这是一篇2020年终总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>服务过载保护研究</title>
    <link href="http://www.xiaocc.xyz/2020-10-17/%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4%E7%A0%94%E7%A9%B6/"/>
    <id>http://www.xiaocc.xyz/2020-10-17/%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4%E7%A0%94%E7%A9%B6/</id>
    <published>2020-10-17T05:30:00.000Z</published>
    <updated>2020-10-17T09:56:14.501Z</updated>
    
    <content type="html"><![CDATA[<p>本文以微信服务过载保护论文为核心并结合其他资料，研究服务过载的现象、检测、处理及优化</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>什么是服务过载？</p><p>服务过载就是服务请求量超过其处理能力，引起响应延迟变大，直至超时。<br>某些情况下用户或上游服务重试，导致该服务请求量进一步加大，加剧服务过载现象，直到该服务有效处理量降至零。<br>更可能由于级联反应，带动上游过载，最后引起整个系统雪崩。</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202010/Jietu20201017-1425.png"></p><p>为什么会发生过载？</p><p>由于互联网场景天生的请求不均衡性，高峰期请求量一般为均值3倍，或特定节假日由点状变为群体性访问，或者热门事件导致的突发大流量访问，或者硬件老化访问变慢，或者网络异常前端重试，或者异常攻击等等，这些情况均可能导致服务超过处理能力，引起过载。</p><p>过载保护有什么好处？</p><p>其能在请求量超过服务处理能力十倍、百倍情况下，服务有效处理量依然维持高水平，可减少用户重试导致的过载加剧，及为过载恢复争取时间，提升用户体验。<br>未进行过载保护情况下，某核心服务过载至雪崩，可导致全部用户受影响，添加保护后，服务依然可以保持最大有效处理量响应用户请求。</p><h4><span id="过载保护">过载保护</span></h4><h5><span id="基本场景">基本场景</span></h5><p>根据系统架构不同，过载保护分为以下几个场景：</p><ul><li>单体应用 —— 通过监控系统资源及运行时情况进行保护</li><li>小型多模块系统 —— 通过前置构建网关服务，其监控下游服务处理情况，依次进行保护</li><li>大规模分布式微服务系统 —— 所有服务均需要被保护，否则某个服务过载，极容易由于级联反应导致整个系统崩溃</li></ul><h5><span id="过载检测">过载检测</span></h5><p>针对微服务系统进行过载保护的常用手段为QPS限制，即通过前期压测，给服务处理能力设定上限，一般超过该上限90%即认为进入过载状态。</p><p>但是这种基于固定阈值的方式，无法解决服务处理场景动态变化的问题。</p><p>例如：服务部署的机型不同，磁盘等硬件不同，受同机部署的其它进程影响，网络延迟变化等，单一的固定阈值无法动态适应这些变化。</p><p>我们需要思考服务过载后引起的最本质的现象是什么，以及如何检测到这些现象？</p><p>常用的网络框架大致处理流程为：<br>网络数据包接收线程 -&gt; 解码数据包为消息并放入消息队列 -&gt; 工作线程处理</p><p>那么，我们能否通过检测消息队列的长度，并依此来判定服务过载，因为服务过载时，工作线程处理不及时，会导致消息队列数据积压。<br>但是这里有一个难点，由于机型不同，各机型部署的服务过载时候，积压队列长度不一，很难设定一个统一值。<br>另一方面，我们要设计的是一个通用的过载保护方案，不可能为每种service配置各自的队列长度参数。</p><p>那我们从本质上来思考？站在用户侧考虑，服务过载对用户有什么影响？<br>响应延迟变大，甚至不返回，时间维度是最本质的影响。</p><p><strong>微信过载检测系统，通过检测消息从队列中取出的延迟及cpu负载情况，以此来评估过载</strong></p><p>而该平均延迟上限值具有普适性，经验值为20ms，该种检测方式简单、直接，直达本质。<br>不需要额外配置，不需要针对不同服务、不同机型配置，可以集成在服务框架中，保护整个微服务系统。</p><h5><span id="过载处理">过载处理</span></h5><p>每个服务保存参数P，为请求通过率，初始为1，此时请求全部通过<br>过载检测算法，检测工作线程取出消息延迟，并结合cpu负载，动态调整参数P，假设调整到0.95，即表示有5%的概率直接丢弃请求，这部分丢弃的请求不会放入消息队列</p><p>其参数调整算法类似于TCP拥塞算法，采用快降慢升模式</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202010/Jietu20201017-1630.png"></p><p>每2000个请求或每秒钟，计算队列平均的等待时间 &gt; 20ms，或者cpu负载 &gt; 90，开始拒绝，否则开始回升特殊处理，对于通过率 &lt; 20%时候，降速因子降为 2%</p><p>通过以上保护系统形成一个回馈系统，过载时，降低服务入口流量，待恢复正常，逐步提高流量<br>系统不存在无效处理(即处理那些在上游看来已经超时的请求)，也不会因为积压队列过长导致雪崩</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202010/Jietu20201017-1640.png"></p><h6><span id="随机丢弃问题">随机丢弃问题</span></h6><p>上述保护系统能很好的对服务进行过载保护，但是依然有优化空间，并且有逻辑上的无效处理</p><p>常见的几种服务间调用模式如下：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202010/Jietu20201017-163907.jpg"></p><p><strong>为什么服务M的单次处理均是有效处理，但说它存在逻辑上的无效处理</strong></p><p>请观察模式二，某个请求需要调用基础服务M两次，可能是转账时候查询两者的银行卡号，但此时服务M过载，通过率P=0.5，也即有50%的概率丢弃请求。<br>那么存在这种情况，A第一次调用M成功，但是第二次调用M请求被丢弃，而只有两次调用同时成功，总体才算成功。<br>这就导致第一次成功处理的请求成为逻辑上的无效请求，浪费过载时宝贵的系统资源。</p><p>这时A调用下游的总体成功率为：P * P = 0.5 * 0.5 = 0.25<br>A同时调用的下游模块越多，其总体成功率越低，逻辑无效处理越多</p><p>如何解决这个问题？</p><p>问题的根本在于服务过载时，对请求丢弃的<strong>无差别随机</strong>，如果能保证M服务的各实例，均按照相同的规则对请求进行丢弃，那么X实例通的请求，在Y实例依然通过</p><p>所以这里对丢弃规则进行优化，不再随机丢弃，而是按照用户user_id维度丢弃，注意这里的user_id是发起客户端请求的用户id，而不是请求参数中的用户id，注意这两者的差别，如此就能保证丢弃的一致性。</p><p>大体思路为：<br>对用户id进行hash计算，并散列到0-1区间，按照当前通过率，判断是否丢弃该请求。</p><p>假设某用户id为10000，散列之后为0.95，那么通过率为0.97时不会丢弃该用户请求，当通过率为0.93时，该用户请求将被丢弃，该算法能保证集群丢弃的一致性，减少逻辑无效处理。</p><p>还是模式二，用户X通过服务A发起某种请求，需要访问基础服务M两次，参数为Y、Z，通过hash用户id并分布到0-1区间，按照通过率比对，判断是否丢弃请求，而M服务两次比对原则一致。</p><h6><span id="倒霉的用户">倒霉的用户</span></h6><p>上述处理能保证丢弃的一致性，并减少逻辑无效处理，是否存在其他问题呢？</p><p>这里存在一个用户体验上的问题，某用户G按照散列算法分配到0.99，意味着每次服务过载都会优先对他的请求进行丢弃，如果我是这个用户，那么肯定会崩溃。</p><p>如何减少对特定用户的伤害？</p><p>修改hash算法，增加维度，以user_id + 日期来计算，这样能保证全体用户都有被分配到高水位的概率。</p><p>所有用户都有成为倒霉鬼的那一天，而不是一直盯着豆豆打。</p><h6><span id="业务优先级">业务优先级</span></h6><p>据此之上可以做进一步的优化，根据业务优先级进行丢弃，优先保证核心功能得到处理</p><p>原理类似，根据优先级id配置散列表，过载丢弃时，优先丢弃低优先级业务的请求</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202010/Jietu20201017-1730.png"></p><h6><span id="前置丢弃">前置丢弃</span></h6><p>当服务过载非常严重的时候，丢弃请求都会消耗额外资源，能否让这部分注定被丢弃的请求，根本就不发送到下游服务呢？</p><p>这里就需要上下游联动，下游服务将自己的通过率P，定时告知上游，上游发送请求到下游之前，先预检查请求是否会被丢弃，如果会被丢弃，直接不发，即快速熔断。</p><p>该参数传递可以级联传递到用户客户端侧，从最上游进行控制。</p><h4><span id="其它问题">其它问题</span></h4><h5><span id="参数传递">参数传递</span></h5><p>上述过载保护算法中的请求用户user_id，业务优先级group_id，如何在微服务系统中进行传递，需要每个接口的请求结构都添加这两个额外参数么？</p><p>对于已存在的模块、接口，推动参数升级将是不可能完成的事情</p><p>这里得益于整个微信后台均采用统一框架，这些通用参数可以直接在框架内部传递，上层业务完全无感知，而过载保护算法，请求重试机制均融合在框架内部</p><h5><span id="外部模块">外部模块</span></h5><p>事情总有万一，对于需要访问到微信外部其它部门的能力，如何感知到过载，并做好过载保护</p><ul><li>推动外部门框架升级，统一采用微信服务框架，整体具有过载保护能力，这不现实</li><li>通过包装一个模块A，统一调用外部，其它内部模块访问模块A，这样当外部模块异常时，A模块可以快速拒绝</li></ul><p>参考资料：</p><ul><li><a href="https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf" target="_blank" rel="noopener">Overload Control for Scaling WeChat Microservices</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以微信服务过载保护论文为核心并结合其他资料，研究服务过载的现象、检测、处理及优化&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>多阶hash实现与分析</title>
    <link href="http://www.xiaocc.xyz/2020-07-20/%E5%A4%9A%E9%98%B6hash%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://www.xiaocc.xyz/2020-07-20/%E5%A4%9A%E9%98%B6hash%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</id>
    <published>2020-07-20T11:30:00.000Z</published>
    <updated>2020-07-20T13:22:13.910Z</updated>
    
    <content type="html"><![CDATA[<p>多阶hash作为腾讯即通部门底层存储，在资料、关系链系统中均有使用，内部文档大多讲述实现原理，缺少实现细节与具体源码，在github偶遇一份类似实现，特分析之。</p><a id="more"></a><h4><span id="多阶hash简介">多阶hash简介</span></h4><p>我们常用的hash只有一层结构，常采用链表法进行冲突解决：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202007/Jietu20200720-193241.jpg"></p><p>当hash结构装载的数据较多时，冲突严重，链表结构长度较长，查找key的过程需要对链表进行遍历，耗时不可控，这时可以进行hash扩容，即将hash桶数量扩大，数据重新迁移到某个index下，但此数据迁移过程耗时较长，同时需要考虑读写冲突问题。</p><p>腾讯设计的多阶hash，即是将某一层冲突的key，交由下一层进行填充，直到最终层</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202007/Jietu20200720-195236.jpg"></p><p>多阶hash构造时候，需要两个参数，第0层最多容纳的元素个数N，阶数M</p><p><strong>每一阶可容纳元素个数如何计算呢？</strong></p><p>从N开始计算比它小的素数，依次作为每一阶的元素个数</p><p>假如N=100，M=5，那么每一阶元素个数为：</p><p><code>97,89,83,79,73</code></p><p><strong>元素插入流程：</strong></p><p>根据元素key计算hash值，对N0取模得到下标，查看该坑位是否被占<br>如果该坑位被占，那么下移到下一阶，重复上述计算过程，直到：</p><ul><li>某一阶有空余坑位，那么将该元素插入</li><li>如果查找到最后一阶，仍然没有空余坑位，那么插入不成功，对外报错。但是综合考虑N，M值，这种情况概率极低</li></ul><p>最差情况下，需要查找M阶，才能找到可插入坑位</p><p><strong>元素查找流程：</strong></p><p>与元素插入流程类似<br>根据原始key计算hash值，从第0阶开始依次查找对应坑位，检查坑位中元素key与待查找元素key是否匹配，如果不匹配，则下移到下一阶，继续查找<br>如果某一阶对应坑位hash值为0，也就是该坑位为空，不能停止查找元素，因为该坑位可能是由于删除操作而释放出来</p><p>最差情况下，需要查找到最后一阶，也就是查找M阶，才能找到元素</p><p>综上，该数据结构，最坏情况下需要查找M阶</p><p>与普通hash结构相比，其优缺点如下：</p><p>优点：</p><ul><li>实现结构简单，利于cpu缓存，查找速度不一定慢</li><li>可直接将数据结构保存到磁盘，进行落地存储</li><li>插入与查找时间可控，不需要复杂的动态扩容流程</li></ul><p>缺点：</p><ul><li>初始内存占用多，不像普通hash随着元素插入逐渐消耗内存</li><li>不支持扩容，初始构建时即限定可插入最大元素数量</li></ul><p>综合考虑优缺点，可用其实现一些高性能的存储系统</p><h4><span id="多阶hash实现">多阶hash实现</span></h4><p>多阶hash的元素一般保存key值，其value需要找地方额外存储</p><p>整个系统设计如下：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202007/Jietu20200720-203342.jpg"></p><p>系统保留一大块内存，并切分为小的block，每个block有固定大小，这样一个value会占据一个至多个block</p><p>例如：每个block为32字节，需要写入value为70字节，那么其将占据3个(2 * 32 + 6)block</p><p>内存布局：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202007/Jietu20200720-204303.jpg"></p><p>整个存储由：<br>header + nodes + blocks<br>三部分构成，其中nodes由所有的node节点组成，blocks由所有的block元素构成</p><p>nodes即是由多阶hash打平而来，而blocks本来就是预先申请的大块存储</p><p>内存结构即最终磁盘组织结构，不需要额外转存，设计非常巧妙</p><p>如果再配合内存映射<code>mmap</code>简直完美，操作内存即是操作文件！</p><h4><span id="几个问题">几个问题</span></h4><ul><li><p>插入元素时，如何查找可用block？<br>  将空闲block组织成链表结构，在每个空闲block中记录下一个空闲的block地址，将空闲block逻辑上串联，在header中记录空闲链表头部地址。<br>  需要空闲block时，从空闲链表头部开始获取即可</p><p>  <img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202007/Jietu20200720-205853.jpg"></p></li><li><p>删除元素后如何回收block？<br>  查找待删除的最后一个block，将其next设置为header中空闲链表头部地址，同时将header中空闲链表头部地址更新为删除的第一个block地址</p><p>  <img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202007/Jietu20200720-210431.jpg"></p></li></ul><h4><span id="最后">最后</span></h4><p>经过以上分析，再查看项目源码会理解得比较透彻</p><p>项目地址：<a href="https://github.com/zfengzhen/mem_hash" target="_blank" rel="noopener">多阶hash</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多阶hash作为腾讯即通部门底层存储，在资料、关系链系统中均有使用，内部文档大多讲述实现原理，缺少实现细节与具体源码，在github偶遇一份类似实现，特分析之。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>golang任务作业系统实现分析</title>
    <link href="http://www.xiaocc.xyz/2020-04-19/golang%E4%BB%BB%E5%8A%A1%E4%BD%9C%E4%B8%9A%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.xiaocc.xyz/2020-04-19/golang%E4%BB%BB%E5%8A%A1%E4%BD%9C%E4%B8%9A%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-04-19T02:30:00.000Z</published>
    <updated>2020-04-19T05:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sidekiq任务作业系统的golang实现分析</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>当前负责工作的消息推送模块有一个子作业系统，主要依赖于消息队列。<br>最近一直在思考这块内容，能否将整个任务系统进行抽象，将具体业务逻辑剥离，只保留整个最核心的任务拆分、任务调度、任务作业等功能。<br>在网上查找相关资料，找到一个ruby实现的任务系统<code>Sidekiq</code>，随后找到其golang实现，整个系统代码规模不大，设计很巧妙，故而从源码一探究竟。</p><h4><span id="使用">使用</span></h4><p>直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com&#x2F;jrallison&#x2F;go-workers&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func myJob(message *workers.Msg) &#123;</span><br><span class="line">  &#x2F;&#x2F; do something with your message</span><br><span class="line">  &#x2F;&#x2F; message.Jid()</span><br><span class="line">  &#x2F;&#x2F; message.Args() is a wrapper around go-simplejson (http:&#x2F;&#x2F;godoc.org&#x2F;github.com&#x2F;bitly&#x2F;go-simplejson)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type myMiddleware struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (r *myMiddleware) Call(queue string, message *workers.Msg, next func() bool) (acknowledge bool) &#123;</span><br><span class="line">  &#x2F;&#x2F; do something before each message is processed</span><br><span class="line">  acknowledge &#x3D; next()</span><br><span class="line">  &#x2F;&#x2F; do something after each message is processed</span><br><span class="line">  return</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  workers.Configure(map[string]string&#123;</span><br><span class="line">    &#x2F;&#x2F; location of redis instance</span><br><span class="line">    &quot;server&quot;:  &quot;localhost:6379&quot;,</span><br><span class="line">    &#x2F;&#x2F; instance of the database</span><br><span class="line">    &quot;database&quot;:  &quot;0&quot;,</span><br><span class="line">    &#x2F;&#x2F; number of connections to keep open with redis</span><br><span class="line">    &quot;pool&quot;:    &quot;30&quot;,</span><br><span class="line">    &#x2F;&#x2F; unique process id for this instance of workers (for proper recovery of inprogress jobs on crash)</span><br><span class="line">    &quot;process&quot;: &quot;1&quot;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  workers.Middleware.Append(&amp;myMiddleware&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; pull messages from &quot;myqueue&quot; with concurrency of 10</span><br><span class="line">  workers.Process(&quot;myqueue&quot;, myJob, 10)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; pull messages from &quot;myqueue2&quot; with concurrency of 20</span><br><span class="line">  workers.Process(&quot;myqueue2&quot;, myJob, 20)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Add a job to a queue</span><br><span class="line">  workers.Enqueue(&quot;myqueue3&quot;, &quot;Add&quot;, []int&#123;1, 2&#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Add a job to a queue with retry</span><br><span class="line">  workers.EnqueueWithOptions(&quot;myqueue3&quot;, &quot;Add&quot;, []int&#123;1, 2&#125;, workers.EnqueueOptions&#123;Retry: true&#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; stats will be available at http:&#x2F;&#x2F;localhost:8080&#x2F;stats</span><br><span class="line">  go workers.StatsServer(8080)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Blocks until process is told to exit via unix signal</span><br><span class="line">  workers.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>config</code>中设置redis相关信息<br>生产者：可以将任务放置于特定的queue_name，任务可以设置立即执行或者延迟执行<br>消费者：由管理器启动多个消费者，消费queue_name的任务并执行job函数</p><p>可以看到该作业系统有业务隔离能力、定时作业能力，其实还有失败重试能力</p><p>接下来逐一进行分析</p><h4><span id="整体架构">整体架构</span></h4><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202004/Jietu20200419-105612.jpg"></p><p>整体系统由<code>manager</code>、<code>worker</code>、<code>schedule</code>、<code>fetcher</code>构成</p><ul><li>manager - 负责某个queue-name任务的处理，内含一个fetcher、多个worker</li><li>worker - 负责具体任务处理</li><li>schedule - 负责延迟发送任务处理、重试任务处理</li><li>fetcher - 负责与redis交互，拉取或删除任务</li></ul><h4><span id="大体流程">大体流程</span></h4><ul><li>Enqueue - 任务入队<ul><li>如果任务需要<strong>立即执行</strong>，则将任务信息保存到redis的<strong>queue-name</strong>队列中</li><li>如果任务需要<strong>延迟执行</strong>，则将任务保存到<strong>公用</strong>的延迟zset队列中，并以待发送时间戳为score</li></ul></li><li>Process - 任务处理<ul><li>manger - 每个queue-name均需要创建一个manager，其负责任务的获取、调度、分发、收尾处理<ul><li>manager启动时候，需要检查是否有残留任务需要处理，也就是任务处理到一半，该process挂掉，导致任务未执行完毕，这些任务需要重新执行</li><li>正常情况下，manager通过fetcher以<code>brpoplpush</code>形式，将待执行任务从<strong>queue-name</strong>转移到正在执行<strong>inprogress</strong>队列，同时通过golang自带chan将任务下发给worker</li></ul></li><li>worker - 从chan获取任务并执行，并通过middleware形式将处理状态返回，如果处理成功，则通过chan通知manager将任务从<strong>inprogress</strong>队列删除，否则，如果任务需要重试，则将重试信息放入<strong>retry</strong>队列，重试间隔时间成指数级递增</li><li>schedule - 负责延迟、重试任务处理<ul><li>延迟任务 - 由于zset中score为任务执行时间戳，利用<code>zrangebyscore</code>，score为<code>-inf -&gt; now</code>，索取可执行任务，将任务从zset中删除，并放入对应<strong>queue-name</strong>队列</li><li>重试任务 - 处理过程与延迟任务相同     </li></ul></li><li>fetcher - 从redis中相关队列获取任务，ack后删除任务等</li></ul></li></ul><h4><span id="一致性分析">一致性分析</span></h4><ol><li>manager任务下发后，worker处理完毕，在ack之前进程挂掉，下次再次启动manager会进行任务重发，这里是<strong>at least once</strong></li><li>schedule从zset中检索可执行任务，然后先调用<code>zrem</code>，再调用<code>lpush</code>将任务放入queue-name中，如果在zrem之后，lpush之前挂掉，则任务丢失，这里是<strong>at most once</strong></li></ol><h4><span id="设计巧妙之处">设计巧妙之处</span></h4><ol><li>middleware - 通过该设计将日志、统计、重试等功能糅合到处理流程中，并可以方便添加其他处理器</li><li>延迟任务 - 通过redis的zset实现，以任务执行时间戳为score</li><li>fetcher - 逻辑层与数据层分离，通过fetcher与redis交互</li></ol><h4><span id="参考资料">参考资料</span></h4><ol><li><a href="https://github.com/jrallison/go-workers" target="_blank" rel="noopener">go-workers</a></li><li><a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/" target="_blank" rel="noopener">Handling 1 Million Requests per Minute with Go</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sidekiq任务作业系统的golang实现分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>唯一ID生成之雪花算法</title>
    <link href="http://www.xiaocc.xyz/2020-04-11/%E5%94%AF%E4%B8%80id%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <id>http://www.xiaocc.xyz/2020-04-11/%E5%94%AF%E4%B8%80id%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-11T01:30:00.000Z</published>
    <updated>2020-04-11T02:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>分析Tweet唯一ID生成的雪花算法</p><a id="more"></a><h4><span id="算法原理">算法原理</span></h4><p>该算法计算唯一id的过程不依赖其它组件与库，简单而直接。<br>算法将int64位的64bit按功能分割成多个bits区间，如下：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202004/Jietu20200411-094438.jpg"></p><p>各区间默认bits位如下：<br>12-5-5-41</p><p>其中我们约定该唯一id只能是正数，那么最高位不能为1，只能为0，所以timestamp长度为 <code>42 - 1</code></p><h5><span id="时间原点">时间原点</span></h5><p>其中timestamp字段精确到<strong>毫秒</strong>，平时我们计算时间一般从<code>linux epoch</code>开始，也就是linux时间原点(1970年1月1日0点0分0秒)开始计算。</p><p>可以想象，现在数据长度只有41位，不足以放下这个<strong>毫秒</strong>级别的时间差距，怎么办？</p><p>我们可以调整时间原点，没必要从linux时间原点开始，我们可以人为约定一个时间原点，例如：2010-01-01 00:00:00，计算当前时间与该时间原点的毫秒级差距，这个差距41位长度可以保存。</p><p>现在计算41位毫秒级长度最多可以保存多长的时间差距</p><p>2^41 / 1000 / 3600 / 24 / 365 = 69.7年</p><p>如果时间原点规定为2010年，那么该算法工作至2080年将失效。</p><p>不过真到那个时候，你我应该已经入土…</p><h5><span id="算法性能">算法性能</span></h5><p>在默认配置下，我们计算该算法生产id的性能如何<br>每毫秒可以生成 <code>2^12 = 4096</code> 个seq，而workId为<code>32</code>，dataCenterId为<code>32</code><br>所以总计：<code>4096 * 32 * 32 = 4194304</code> 约<strong>419万</strong></p><p>单机：<br>每毫秒：4096个，每秒：4096 * 1000 = 4096000 约 400万</p><p>可见该算法性能杠杠的，满足绝大部分id生成需求</p><h5><span id="算法问题">算法问题</span></h5><p>由于该算法将毫秒级时间埋入id中，如果机器时间发生回退，那么将产生重复id，不过这个可以通过比较lastTime 与 curTime，如果 curTime &lt; lastTime 则返回错误。</p><p>但是如果发生进程重启 + 时间回退，则无法解决该问题，因为lastTime是保存在内存中，重启即丢失，就算将该值保存在共享内存中，也可能因为机器故障而丢失，而你不可能每毫秒将该lastTime落盘保存，这不现实。</p><p>如果在1ms内seq增长到了最大值，即占满12个bit，怎么办，算法会停顿1ms，这点延迟通常不是什么大问题。</p><h4><span id="算法实现">算法实现</span></h4><p>代码地址：<br><a href="https://github.com/xiaocc2012/snow.git" target="_blank" rel="noopener">snow</a></p><p>Benchmark测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go test -bench&#x3D;.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: stest&#x2F;snow</span><br><span class="line">BenchmarkSnow-4    4925791       245 ns&#x2F;op</span><br><span class="line">PASS</span><br><span class="line">ok  stest&#x2F;snow1.765s</span><br></pre></td></tr></table></figure><p>生成500万个id耗时1.76秒，约：280万/秒</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析Tweet唯一ID生成的雪花算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>jaegerTracing拓扑关系计算</title>
    <link href="http://www.xiaocc.xyz/2020-01-10/jaeger%E6%8B%93%E6%89%91%E8%AE%A1%E7%AE%97/"/>
    <id>http://www.xiaocc.xyz/2020-01-10/jaeger%E6%8B%93%E6%89%91%E8%AE%A1%E7%AE%97/</id>
    <published>2020-01-10T09:00:00.000Z</published>
    <updated>2020-01-14T07:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>jaegerTracing可视化UI中可以清晰展示服务之间调用依赖关系与调用次数，笔者在此文中分析其计算流程</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>随着微服务架构的兴起，一个功能不再由简单的一个或者几个服务组成，而是由几十、甚至上百个服务协同起来对外提供能力。<br>在此背景下，服务异常情况的排查特别麻烦，各个微服务之间如蜘蛛网一样，单纯依靠监控、告警，很难在短时间内排查出问题的根源。</p><p>在引入分布式追踪技术之前，排查问题的流程往往是这样的：<br>收到某服务A的告警，要么能通过告警id知晓其调用的下游服务名、要么就只能通过观察代码逻辑，找到引起该告警的下游服务。<br>然后，将该事件告知下游服务负责人，其又引入下一轮排查流程。</p><p>或者是另一种景象：<br>某个时间点，大量服务告警，一时间乱成一锅粥，很难理清这些告警服务之间的共同性，是某个公用服务异常，还是依赖的存储层异常，还是某个机房网络问题。<br>这些因素，由于线上服务数量的增长，导致不能在短时间内理清进而排查解决问题。</p><p>又或者：<br>收到某个客户反馈的异常问题，需要排查详细处理日志，而该请求处理链路较长，中间跨越多个服务，想要获取该次请求的相关日志。<br>原始的方法从源头机器开始排查，可是如果源头机器有上百台怎么办？怎么知道该次请求落入哪台机器？这时候顺藤摸瓜比较难。<br>ELK的分布式日志收集可以帮上大忙，但是需要约定日志打印规范，相关服务打印的日志需要带上核心参数，以利于日志检索，同时需要搭建和运维ELK集群，维护成本较高。</p><p>有没有一种直观的方式可以清晰的展示处理逻辑、耗时情况、上下文日志等。</p><p>有，这种技术就是<code>分布式追踪</code>。</p><h4><span id="拓扑计算">拓扑计算</span></h4><p>在本文中不讲解tracing相关技术，而是分析另外一个问题，如下的服务间拓扑图，如何计算出来？</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202001/1_XLxS6v_BWwtU2cvbSsHFyQ.png"></p><p>图中，每个顶点是服务名，每条边展示服务之间的调用次数。</p><p>有了此图，可以方便的解决很多问题</p><ul><li>服务之间调用的依赖关系</li><li>服务之间调用的次数关系，可以依此做服务容量模型</li><li>帮助新人尽快总揽项目，熟悉上下游关系，及其负责的模块在整个链路中的位置</li><li>结合服务告警信息，能快速理清问题根源</li></ul><p>接下来以<code>jaegertracing</code>项目中Flink计算模式为例，解析其拓扑计算流程：<br>项目地址：<a href="https://github.com/jaegertracing/jaeger-analytics-flink" target="_blank" rel="noopener">https://github.com/jaegertracing/jaeger-analytics-flink</a></p><h5><span id="总体流程">总体流程</span></h5><p>服务或框架以TracingAPI的形式将span数据上报，包括tracing_id，span_id，parent_span_id等</p><p>以下是笔者测试上报的span信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">publisher:</span><br><span class="line">2019&#x2F;12&#x2F;06 11:28:32 Reporting span 373f56c0dacafddf:2f69248998aaeeea:5d8ac19e1d4dea0d:1</span><br><span class="line"></span><br><span class="line">formater:</span><br><span class="line">2019&#x2F;12&#x2F;06 11:28:32 Reporting span 373f56c0dacafddf:6962f843e8efa05e:37c328b9efb96096:1</span><br><span class="line"></span><br><span class="line">hello:</span><br><span class="line">2019&#x2F;12&#x2F;06 11:28:32 Reporting span 373f56c0dacafddf:37c328b9efb96096:373f56c0dacafddf:1</span><br><span class="line">2019&#x2F;12&#x2F;06 11:28:32 Reporting span 373f56c0dacafddf:5d8ac19e1d4dea0d:373f56c0dacafddf:1</span><br><span class="line">2019&#x2F;12&#x2F;06 11:28:32 Reporting span 373f56c0dacafddf:373f56c0dacafddf:0:1</span><br></pre></td></tr></table></figure><p>数据格式为：<br>trace_id : span_id : parent_span_id : flags</p><p><code>hello</code>服务调用<code>publisher</code>、<code>formater</code>服务，总计上报5个span数据</p><p>以此数据为例，方便理解flink拓扑计算逻辑</p><p><code>jaeger-analytics-flink</code>项目中计算拓扑逻辑的代码在：<br><code>jaeger-analytics-flink/dependencies-job/src/main/java/io/jaegertracing/dependencies/DependenciesProcessor.java</code></p><h5><span id="流程图">流程图</span></h5><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/202001/Jietu20200114-143929.jpg"></p><h5><span id="流程解析">流程解析</span></h5><ul><li>对上报的span有效性进行清洗，过滤出标志为client/server的span</li><li>按照trace_id进行分组，即将同一个trace_id下上报的span放在一起</li><li>服务自调用特殊情况处理</li><li>将span转换成依赖关系 (即是由点转换成边)<ul><li>遍历所有span，获取span_id、service_name的映射关系</li><li>遍历所有span，通过parent_span_id查找service_name</li><li>上报一条parent_service_name + child_service_name的新数据，表示一条边</li></ul></li><li>针对新的数据流，按照 <code>parent + child</code>进行分组 (即是相同边放在一起)</li><li>按照window进行聚合</li><li>对聚合结果进行sink，写入相应存储</li></ul><p>至此，所有边的数据已经全部计算完毕，前端展示时候，按照有关图算法，即可得到顶点依赖关系并进行绘制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jaegerTracing可视化UI中可以清晰展示服务之间调用依赖关系与调用次数，笔者在此文中分析其计算流程&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>宝贝女儿出生记</title>
    <link href="http://www.xiaocc.xyz/2020-01-07/%E5%AE%9D%E5%AE%9D%E5%87%BA%E7%94%9F%E8%AE%B0/"/>
    <id>http://www.xiaocc.xyz/2020-01-07/%E5%AE%9D%E5%AE%9D%E5%87%BA%E7%94%9F%E8%AE%B0/</id>
    <published>2020-01-07T02:50:00.000Z</published>
    <updated>2020-01-07T07:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录女儿出生这一人生重大时刻，任时光流逝，这份激动不停歇</p><p>我想用文字记录这一刻，生怕会因为岁月的增长而忘却</p><a id="more"></a><h4><span id="初孕">初孕</span></h4><p>4月的一个周末，我像往常一样早起到小区门口的小摊买早餐，有土家族秘制千层饼、豆花。<br>刚到家一开门，老婆抱住我，激动得哭起来<br>“老公，你看，两条杠，我怀孕了，之前每次测试都是一条杠，终于知道两条杠是什么样子了”。<br>然后，哭得稀里哗啦。</p><p>当时我有点懵逼，手里提着早餐，问她“是真的吗？是不是检测试纸放太久变质了”。<br>这个时候我依然无法改变程序员直男癌的本质。</p><p>“我再去买两个试纸测试一下吧，再次确认一下”。</p><p>赶紧飞奔到楼下，跑到小区门口，门口药店因为太早还未开门，打开手机地图，搜索附近其它药店，骑上哈喽单车狂奔而去。</p><p>带回来两个验孕试纸，至今仍然摆在抽屉中。</p><p>再次到家，老婆说已经用排卵试纸进行了测试，应该是有了。<br>我心里一个激灵，悬着的心落下。</p><p>你来得太突然了，虽然爸爸妈妈一直期盼着你的到来，可当你招呼也不打一声真的来到，我们还有点措手不及。</p><p>这个时候，验血是最准确的。</p><p>开车往松江一医赶，大厅很寂静，原来，今天是周日，门诊不上班。</p><p>这可怎么办才好？</p><p>这时候迎上来一个大妈，听说我们想要验血确认是否怀孕，说她儿媳妇是在附近的某某医院生产的，他们那里周日也上班。</p><p>高德地图搜了一下医院名，看了一下评价，应该是莆田系医院，而这个大妈是医托无疑。</p><p>无奈，只能等明日也就是周一再来。</p><h4><span id="确认怀孕">确认怀孕</span></h4><p>周一上午请了假，早早的来到医院进行验血检查。<br>抽完血，化验需要一个小时，这段等待的时间异常难熬。<br>我们俩就这样坐着，规则着后面的事情，如果确认怀孕，什么时候辞职，让哪边的父母过来照顾，怎么建小卡，怎么建大卡，等等。</p><p>hcg检测结果出来，确认怀孕无疑，我们流下了激动的泪水。</p><p>宝宝，你终于来了，爸妈等你等得好辛苦。</p><p>因为之前老婆在抖音上关注了一个中国妹子嫁到美国，给两个美国宝宝当陪护老师，一边照顾他们，一边教他们说中文。<br>其中的女宝宝，老婆特别喜欢，因为她积极、乐观、运动力强、不怯场，英文名：<code>Lyla</code>，中文名：莱拉。</p><p>老婆下令，如果我们宝宝是女宝，那么她的小名就叫莱拉，英文名也有了，还挺洋气的。</p><h4><span id="孕程各项检查">孕程各项检查</span></h4><p>随后就是漫长的怀胎十月，伴随着各种检查：<br>着床情况、nt、唐筛、大排畸、糖耐、胎监等等</p><p>怀孕3个月的时候，孕吐特别严重，吃啥吐啥，闻不得一点油烟味，菜油盐不能放，烧菜时候，我扶她到楼下，等全部弄完了再上来。<br>现在想想，真不知道那2个月是怎么过来的，她亲妈都对她的挑剔有点嫌弃了。<br>说是这么说，但是丈母娘真是下了大心血，每天估摸着买什么菜做给她吃，要有营养，又不能太油，还不能重样，真的挺伤神。<br>要不是丈母娘，她不会被照顾得这么好，整个孕期连一次感冒都没有。而我爸妈，因为是农村人，在城市确实搞不习惯，上手需要时间，两边父母就轮流着照顾她。</p><p>其中，老婆还因为夏天吃葡萄太多，说是吃了葡萄宝宝眼睛大，最后血糖太高，吃了快两个月的杂粮饭。</p><p>十一国庆的时候，她怀孕6个月，状态比较好，带着她还有父母一起，环上海搞了一趟自驾游，大家都玩得很开心。<br>特别是妈妈第一次看见大海，像个孩子一样，拖了鞋子在海里玩水，特别快乐！</p><h4><span id="孕程最后一个月">孕程最后一个月</span></h4><p>整个孕程开始是一个月检查一次，后来是2周一次，到最后一个月是一周一次。<br>她加了一个群，预产期都是12月份的，慢慢的开始有宝宝出生了，有的是因为早产，有的是直接剖的。<br>我们宝宝预产期12月19号，是一个特别爱动的宝宝，胎动像打鼓。<br>朋友说多走走有利于顺产，她每天坚持饭后散步半小时。</p><p>离预产期还有两周，我们开始在家里商量如果出现各种状况怎么办，比如见红怎么办、破水怎么办。<br>最后一次产检还因为宝宝胎心过快，住了一天院，其实就输了几瓶葡萄糖，花了3千块钱，主要是血液化验费，她心疼的要命。</p><p>”老公，我做了一个决定，决定不打无痛，忍忍就过去了“，”哈哈，你那么怕疼，不给你打无痛，我估计你到时候会跪着求我，老公，求你了，给我打无痛吧“</p><h4><span id="生产">生产</span></h4><p>17号去医院，带上各种待产包，宝宝的、宝妈的，各种类目。<br>对了，我们懒宝宝一直不发动，去医院之前还吃了顿火锅、吃满记甜点、逛街，可是这些办法依然都不能刺激她发动，无奈。</p><h5><span id="17号">17号</span></h5><p>17号中午到医院，下午啥事儿没干，就测胎心、验血、验血糖，这样耗着也不是事儿啊，晚上找医生，产房人太多，没有位置，说明天一定给你们挂催产素。<br>17号一天，就这样过去了。</p><h5><span id="18号">18号</span></h5><p>18号上午医生查房，给安排了方案，下午挂催产素、晚上挂水囊。<br>可是，18号当天生产的人太多，走廊里都摆了5张床位。<br>昨天我们还说早来一天，啥也没干，坑我们钱。今天就庆幸，还好早来一天，要是今天来，估计得安排到走廊。<br>下午又啥都没干成，医生说，今天破水生产的太多，忙不过来，晚上先给你们放水囊。</p><p>晚上8:30，医生让我带着老婆去医务室放水囊，前后也就10分钟，让我进去扶她。<br>我看到她的样子，她眼里泛着泪光，双腿不停打颤，疼得受不了，已经无法从操作椅上下来，我几乎是抱着她下来的。搀扶着，踉踉跄跄回到病房，躺在病床上，双腿依然颤抖。</p><p>晚上10点，宫缩就开始了，如潮水一浪一浪袭来，她紧握着我的手，疼得无法言语，后背已汗湿。</p><p>在这样一浪接一浪的宫缩疼痛中，夜里1点，她终于入睡。</p><h5><span id="19号">19号</span></h5><p>早上6点吃完早餐，8:30医生查房，安排我把她送入产房。<br>8点-10点为医生查房时间，所有家属均不能呆在病房，这时候医患交流大厅自然而然成为人们歇脚的地方，通道挤满了人。<br>我推着病床，床上躺着因宫缩疼痛而扭曲的她，我们像战士一样迈向战场。<br>产房家属不能进入，里面的护士接过病床。</p><p>”老婆，加油“，产房门紧紧关上。</p><p>我跟岳母在病患交流大厅焦急等待，时刻关注显示屏上产房内部动态。</p><p>破水，正在滴注催产素</p><p>时而在产房门口的走廊踱步，时间一分一秒的过去</p><p>还好可以微信交流，问她在里面什么情况，疼不疼，带进去的东西吃了没有<br>”宫缩还是不规律，我可能今天生不出来“<br>”疼，好疼，疼得受不了“</p><p>我只能用文字安慰她，却什么也做不了，心如刀扎</p><p>下午3点以后，微信聊天不再回我</p><p>岳母说，她应该到了关键时间</p><h4><span id="新生">新生</span></h4><p>冬天的天黑得特别早，不知不觉，外面已灯火璀璨。<br>我跟岳母商量，在这里等也是等，不如到产房通道等吧，还可以向护士打听打听情况。<br>距离她进入产房已近10个小时，里面什么情况，我们全然不知，只能等。</p><p>等到近晚上7点，护士说你们是家属么，生了个妹妹。<br>听到这话，我眼泪差点流下来，11个小时，她是怎么过来的，承受了多大的疼痛，不敢想。</p><p>医生说，还需要观察2个小时才能出产房，让我们安心等待。</p><p>这漫长而焦急的2小时啊，仿佛度过了2年，墙上的挂钟，哒哒哒的响</p><p>门终于开了，宝宝在婴儿床中安静的睡觉，老婆在病床上双脸惨白、极度虚弱，我握着她的手说，这就是我们的宝宝，老婆，你辛苦了。</p><p>眼泪流了下来。</p><p>回到病房照顾虚弱的老婆和初到这个世界的宝宝。</p><p>宝宝，爸爸妈妈爱你哟，希望你健康、快乐！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录女儿出生这一人生重大时刻，任时光流逝，这份激动不停歇&lt;/p&gt;
&lt;p&gt;我想用文字记录这一刻，生怕会因为岁月的增长而忘却&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://www.xiaocc.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>HyperLogLog原理与实现</title>
    <link href="http://www.xiaocc.xyz/2019-12-16/HyperLogLog%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://www.xiaocc.xyz/2019-12-16/HyperLogLog%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2019-12-16T07:00:00.000Z</published>
    <updated>2019-12-16T10:30:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计学基数计算方法——HyperLogLog的原理解析与实现分析</p><a id="more"></a><h4><span id="背景">背景</span></h4><p> 我们常常碰到这类问题，如：网站昨日访问人数是多少，集合的基数是多少。<br> 所谓基数即是独一无二的内容个数，或者称为去重之后的数。</p><p> 例如：最近5分钟访问网站的用户ID流水为 <code>{1001,1002,1001,1003}</code>，其基数即为<code>3</code>。<br> 当数据量不大时，我们用数组、map、hashmap、bitmap即可达到去重效果，先在集合中检查ID是否已存在，若存在，则该次流水不插入，以此来做基数计算。<br> 但是当面对海量数据时，如网站UV为一千万、一亿，该方案需要消耗大量内存来记录原始数据，同时该查重过程也非常耗时。</p><p> 有没有一种简单的基数计算方案，消耗内存少、计算速度快？</p><p> 有！HyperLogLog即可完成任务，但是其有一个假设前提，它是基于统计学的估计，是一种非精确计算，误差率在1%左右。<br> 其误差率与消耗内存大小、基数大小均有关系。</p><h4><span id="hyperloglog原理">HyperLogLog原理</span></h4><p>假设我们做一项实验，实验内容是这样的：<br>手里有一个硬币，不断抛它，直到出现正面时停止，而在此之前，会一直连续出现反面，我们称这为一次实验。</p><p>现在，我们把该实验进行多次，如果已知连续出现反面的次数，能否推断出需要进行实验的次数？</p><p>假设把出现反面设置为0，出现正面设置为1，一次实验中抛硬币的过程，可以组成一个字符序列。<br><code>01</code>，表示先出现一次反面，再出现正面<br><code>001</code>，表示先出现两次反面，再出现正面</p><p>我们拿序列<code>001</code>分析，该模式出现的概率：1/2 * 1/2 * 1/2=1/8，即该模式出现的概率为1/8。<br>假如经过N次实验后，我们获得了这样一个模式串，那么可以预估N为8，即需要进行8次实验，才能碰到出现<code>001</code>序列的效果。<br>但是，以上只是统计分析，也有可能运气比较好，只需要一次实验就能抛出<code>001</code>的效果。</p><p>那么，该原理如何拿来做基数计算呢？</p><h5><span id="计算过程">计算过程</span></h5><p>假设我们需要统计网站访问uv，用户标识为ID字段。<br>我们可以对ID计算hash值，假设为32位值M，M从二进制角度看即为一串二进制序列，也可以看成是一次抛硬币实验，由于hash函数的散列化功能，对多个ID计算hash，可以认为是多次抛硬币实验。</p><p>所以，我们可以按照如下过程计算基数值：<br>1.对ID计算hash值<br>2.将hash值看作32位二进制数，从左至右找到第一个<code>1</code>出现的下标<br>3.获取下标出现的最大值n</p><p>基数预估值即为：2^n</p><h5><span id="过程优化">过程优化</span></h5><p>在之前说过误差的问题，如何减少误差？</p><p>可以采用多个人来进行实验，以此减少误差，所以优化方案为：<br>1.对ID计算hash值M<br>2.取M的后K位作为桶下标<br>3.从去除尾部K位后的M中，从左至右找到第一个<code>1</code>出现的下标n<br>4.将n放入对应桶中，并获取较大值<br>5.计算所有桶的调和平均数<br>6.计算最终基数</p><p>如下图:<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20191216-164902.jpg"></p><p>假如取hash值后6位，即分成2^6 = 64个桶<br>对ID: 236262计算hash值，取后6位: 010010 = 2<sup>4 + 2</sup>1 = 18，即桶id为<code>18</code>，再从左往右找第一个<code>1</code>出现的下标，为<code>3</code>(下标从1开始计数)，18号桶之前保存的下标数值为<code>2</code>，由于<code>3 &gt; 2</code>，所以更新桶中数值为<code>3</code></p><p>针对所有用户ID进行一遍此流程，假设最终桶中值为M1，M2，Mn，看看如何计算最终基数值：</p><p>m = 2^K<br>调和平均数 y = m / ( 1/2<sup>M1 + 1/2</sup>M2 + … + 1/2^Mn )<br>N = C * m * y </p><p>其中C不是一个固定值，其根据桶的K值，有如下表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func fec(k uint) float64 &#123;</span><br><span class="line">    var constant float64</span><br><span class="line">        m :&#x3D; math.Pow(2, float64(k))</span><br><span class="line">        &#x2F;&#x2F; m 为桶数</span><br><span class="line">        switch k &#123;</span><br><span class="line">            case 4:</span><br><span class="line">                constant &#x3D; 0.673</span><br><span class="line">            case 5:</span><br><span class="line">                constant &#x3D; 0.697</span><br><span class="line">            case 6:</span><br><span class="line">                constant &#x3D; 0.709</span><br><span class="line">            default:</span><br><span class="line">                constant &#x3D; (0.7213 &#x2F; (1 + 1.079 &#x2F; m))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return constant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="调和平均数">调和平均数</span></h5><p>这里采用调和平均数，而不是采用算术平均数，主要是调和平均数可以剔除数值中的异常值，比如我跟马云资产的算术平均数肯定过亿，而调和平均数会偏向于较小值一侧。</p><p>例如：A工资30000，B工资2000，分别计算如下：<br>算术平均数：16000<br>调和平均数：3038</p><p>还有一个经典的例子，轮船顺风速度30，逆风速度20，求平均速度是多少？</p><h4><span id="实际测试">实际测试</span></h4><p>写了一个简单的代码测试误差：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;unsafe&quot;</span><br><span class="line">import &quot;math&quot;</span><br><span class="line">import &quot;math&#x2F;rand&quot;</span><br><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">fmt.Println(tail_zeros(0x1100))</span><br><span class="line">fmt.Println(tail_zeros(0x1010))</span><br><span class="line">fmt.Println(tail_zeros(2))</span><br><span class="line"></span><br><span class="line">n :&#x3D; 10</span><br><span class="line">m :&#x3D; make([]float64, n)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">m[i] &#x3D; test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, v :&#x3D; range m &#123;</span><br><span class="line">fmt.Printf(&quot;%.4f\n&quot;, v - 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    var avg float64</span><br><span class="line">    for _, v :&#x3D; range m &#123;</span><br><span class="line">        avg +&#x3D; (v - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;avg:%.4f\n&quot;, avg&#x2F;float64(len(m)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() float64 &#123;</span><br><span class="line">n :&#x3D; 1000000</span><br><span class="line">m :&#x3D; make([]uint, n)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">m[i] &#x3D; uint(rand.Int31())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return float64(calc(m, 16)) &#x2F; float64(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">c1_32 uint32 &#x3D; 0xcc9e2d51</span><br><span class="line">c2_32 uint32 &#x3D; 0x1b873593</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; GetHash returns a murmur32 hash for the data slice.</span><br><span class="line">func GetHash(data []byte) uint32 &#123;</span><br><span class="line">&#x2F;&#x2F; Seed is set to 37, same as C# version of emitter</span><br><span class="line">var h1 uint32 &#x3D; 37</span><br><span class="line"></span><br><span class="line">nblocks :&#x3D; len(data) &#x2F; 4</span><br><span class="line">var p uintptr</span><br><span class="line">if len(data) &gt; 0 &#123;</span><br><span class="line">p &#x3D; uintptr(unsafe.Pointer(&amp;data[0]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1 :&#x3D; p + uintptr(4*nblocks)</span><br><span class="line">for ; p &lt; p1; p +&#x3D; 4 &#123;</span><br><span class="line">k1 :&#x3D; *(*uint32)(unsafe.Pointer(p))</span><br><span class="line"></span><br><span class="line">k1 *&#x3D; c1_32</span><br><span class="line">k1 &#x3D; (k1 &lt;&lt; 15) | (k1 &gt;&gt; 17) &#x2F;&#x2F; rotl32(k1, 15)</span><br><span class="line">k1 *&#x3D; c2_32</span><br><span class="line"></span><br><span class="line">h1 ^&#x3D; k1</span><br><span class="line">h1 &#x3D; (h1 &lt;&lt; 13) | (h1 &gt;&gt; 19) &#x2F;&#x2F; rotl32(h1, 13)</span><br><span class="line">h1 &#x3D; h1*5 + 0xe6546b64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tail :&#x3D; data[nblocks*4:]</span><br><span class="line"></span><br><span class="line">var k1 uint32</span><br><span class="line">switch len(tail) &amp; 3 &#123;</span><br><span class="line">case 3:</span><br><span class="line">k1 ^&#x3D; uint32(tail[2]) &lt;&lt; 16</span><br><span class="line">fallthrough</span><br><span class="line">case 2:</span><br><span class="line">k1 ^&#x3D; uint32(tail[1]) &lt;&lt; 8</span><br><span class="line">fallthrough</span><br><span class="line">case 1:</span><br><span class="line">k1 ^&#x3D; uint32(tail[0])</span><br><span class="line">k1 *&#x3D; c1_32</span><br><span class="line">k1 &#x3D; (k1 &lt;&lt; 15) | (k1 &gt;&gt; 17) &#x2F;&#x2F; rotl32(k1, 15)</span><br><span class="line">k1 *&#x3D; c2_32</span><br><span class="line">h1 ^&#x3D; k1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 ^&#x3D; uint32(len(data))</span><br><span class="line"></span><br><span class="line">h1 ^&#x3D; h1 &gt;&gt; 16</span><br><span class="line">h1 *&#x3D; 0x85ebca6b</span><br><span class="line">h1 ^&#x3D; h1 &gt;&gt; 13</span><br><span class="line">h1 *&#x3D; 0xc2b2ae35</span><br><span class="line">h1 ^&#x3D; h1 &gt;&gt; 16</span><br><span class="line"></span><br><span class="line">return (h1 &lt;&lt; 24) | (((h1 &gt;&gt; 8) &lt;&lt; 16) &amp; 0xFF0000) | (((h1 &gt;&gt; 16) &lt;&lt; 8) &amp; 0xFF00) | (h1 &gt;&gt; 24)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二进制尾缀0个数</span><br><span class="line">func tail_zeros(n uint) uint &#123;</span><br><span class="line">var i uint &#x3D; 0</span><br><span class="line">for ; i &lt;&#x3D; 32; i++ &#123;</span><br><span class="line">if (n&gt;&gt;i)&amp;0x1 &#x3D;&#x3D; 1 &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return i + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func max(a, b uint) uint &#123;</span><br><span class="line">if a &lt; b &#123;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fec(k uint) float64 &#123;</span><br><span class="line">    var constant float64</span><br><span class="line">        m :&#x3D; math.Pow(2, float64(k))</span><br><span class="line">        &#x2F;&#x2F; m 为桶数</span><br><span class="line">        switch k &#123;</span><br><span class="line">            case 4:</span><br><span class="line">                constant &#x3D; 0.673</span><br><span class="line">            case 5:</span><br><span class="line">                constant &#x3D; 0.697</span><br><span class="line">            case 6:</span><br><span class="line">                constant &#x3D; 0.709</span><br><span class="line">            default:</span><br><span class="line">                constant &#x3D; (0.7213 &#x2F; (1 + 1.079 &#x2F; m))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return constant</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func calc(values []uint, k uint) uint &#123;</span><br><span class="line">&#x2F;&#x2F;桶数量</span><br><span class="line">bn :&#x3D; uint(math.Pow(2, float64(k)))</span><br><span class="line">vb :&#x3D; make([]uint, bn)</span><br><span class="line"></span><br><span class="line">for _, v :&#x3D; range values &#123;</span><br><span class="line">h :&#x3D; uint(GetHash([]byte(fmt.Sprintf(&quot;%032d&quot;, v))))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;桶下标</span><br><span class="line">idx :&#x3D; h &amp; (bn - 1)</span><br><span class="line">tz :&#x3D; tail_zeros(h &gt;&gt; k)</span><br><span class="line"></span><br><span class="line">vb[idx] &#x3D; max(vb[idx], tz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    cnt :&#x3D; make([]float64, bn)</span><br><span class="line"></span><br><span class="line">    var a float64</span><br><span class="line">    var sb float64</span><br><span class="line">    for k, v :&#x3D; range vb &#123;</span><br><span class="line">        cnt[k] &#x3D; math.Pow(2, float64(v))</span><br><span class="line">        a +&#x3D; cnt[k]</span><br><span class="line">        sb +&#x3D; 1 &#x2F; cnt[k]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算调和平均数</span><br><span class="line">    ss :&#x3D; float64(bn) &#x2F; sb</span><br><span class="line"></span><br><span class="line">    return uint(ss * float64(bn) * fec(k))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：上述代码为了计算简便，是从右往左数的第一个1出现的位置，对结果计算无影响</em></p><p>对一百万个随机数，进行基数计算，获取误差，对此操作进行10次，取误差的平均数。<br>平均误差约为：0.15%，空间消耗：2^16 * 4 = 256K</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计学基数计算方法——HyperLogLog的原理解析与实现分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>golang中udp的连接性</title>
    <link href="http://www.xiaocc.xyz/2019-11-30/golang%E4%B8%ADudp%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%80%A7/"/>
    <id>http://www.xiaocc.xyz/2019-11-30/golang%E4%B8%ADudp%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%80%A7/</id>
    <published>2019-11-30T08:30:00.000Z</published>
    <updated>2019-12-01T08:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang中udp分为已连接和未连接两种，两者在发送、接收消息行为模式上有重大区别</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>前段时间，我们组开发一个紧急需求，需要与其它部门某组进行协议交互，暂且称之为B组。<br>B组底层通信采用UDP形式，使用pb为传输协议，本来很简单的事情，可是联调过程中却遇到一个大坑，关于golang中<strong>udp的连接性</strong>问题。</p><p>我们这边采用golang技术栈，以DialUDP的接口与B组交互，先send数据，再recv数据。就这么简单的逻辑，却出问题了，B组能收到我们的请求数据，我们这边却无法接收到B组的返回数据。</p><p>经过与B组交流，他们那边的架构比较奇怪。</p><p>我们设计系统框架，一般会设计一个网关服务，其负责对外提供接口能力，内部再拆分为其它具体服务模块。<br>外部的请求方将请求发送到网关服务，网关服务再根据服务发现逻辑，将请求转发给具体的内部服务，待内部服务处理完毕后，数据原路返回，通过网关服务返回给外部调用方。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20191130-165501.jpg"></p><p>可是这个B组的架构设计，他们采用了一种取巧的搞法。<br>由于udp协议，是一种无连接协议，网关服务接收业务方请求后，记录下请求方的ip、port信息，一并发送给内部具体处理服务，该服务处理完毕后，并不是将响应数据发送给网关服务，由其转发给外部调用方。而是其通过udp的形式，直接将响应数据发送给外部调用方。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20191130-170445.jpg"></p><h4><span id="问题分析">问题分析</span></h4><p>可是，就算这样，又有什么问题呢？<br>我们是UDP服务，B组的网关服务，会将其收到请求的客户端的<code>ip,port</code>信息发送给其内部服务，其再通过udp的形式将数据发送给客户端。</p><p>按照道理，我们是能够收到数据的，可是验证结果，客户端就是收不到返回数据。</p><p>情急之下，我用C语言复写了一下请求逻辑，并进行请求验证，可以正常接收数据，这更增加了我的疑惑。<br>对着golang代码和C语言代码辨析，没什么差别。<br>无奈之下，只能先通过cgo的形式调用C语言函数完成业务需求，待有时间再进行详细分析。</p><p>待业务需求完毕，查阅资料和golang源码后终于搞懂这里面的差别。</p><p>golang中的udp状态分为<strong>已连接</strong>和<strong>未连接</strong>。</p><p>通过DialUDP的形式创建的udp为已连接状态，其会记录remote的ip、port，相当于在两者之间建立了持续通路，发送、接收函数为<code>Write、Read</code>，不需要填remote信息。</p><p>而通过ListenUDP建立的udp为未连接形式，发送、接收函数为<code>WriteTo、ReadFrom</code>，需要填写remote信息。</p><p>在我们与B组交互的这个模式下，由于是通过<code>DialUDP</code>建立的连接，而响应数据并不是通过原通路返回，所以这里无法接收数据。<br>改为使用<code>ListenUDP</code>返回的UDPConn进行数据发送、接收，则可正常接收数据，包括在此种特殊交互模式下。</p><h4><span id="源码分析">源码分析</span></h4><p>下面从源码层面分析<code>DialUDP</code>与<code>ListenUDP</code>有何不同，为什么会导致使用上的如此差异？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error) &#123;</span><br><span class="line">switch network &#123;</span><br><span class="line">case &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;:</span><br><span class="line">default:</span><br><span class="line">return nil, &amp;OpError&#123;Op: &quot;listen&quot;, Net: network, Source: nil, Addr: laddr.opAddr(), Err: UnknownNetworkError(network)&#125;</span><br><span class="line">&#125;</span><br><span class="line">if laddr &#x3D;&#x3D; nil &#123;</span><br><span class="line">laddr &#x3D; &amp;UDPAddr&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">sl :&#x3D; &amp;sysListener&#123;network: network, address: laddr.String()&#125;</span><br><span class="line">c, err :&#x3D; sl.listenUDP(context.Background(), laddr)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, &amp;OpError&#123;Op: &quot;listen&quot;, Net: network, Source: nil, Addr: laddr.opAddr(), Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line">return c, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error) &#123;</span><br><span class="line">switch network &#123;</span><br><span class="line">case &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;:</span><br><span class="line">default:</span><br><span class="line">return nil, &amp;OpError&#123;Op: &quot;dial&quot;, Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: UnknownNetworkError(network)&#125;</span><br><span class="line">&#125;</span><br><span class="line">if raddr &#x3D;&#x3D; nil &#123;</span><br><span class="line">return nil, &amp;OpError&#123;Op: &quot;dial&quot;, Net: network, Source: laddr.opAddr(), Addr: nil, Err: errMissingAddress&#125;</span><br><span class="line">&#125;</span><br><span class="line">sd :&#x3D; &amp;sysDialer&#123;network: network, address: raddr.String()&#125;</span><br><span class="line">c, err :&#x3D; sd.dialUDP(context.Background(), laddr, raddr)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, &amp;OpError&#123;Op: &quot;dial&quot;, Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line">return c, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>sl.listenUDP、sd.dialUDP</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (sl *sysListener) listenUDP(ctx context.Context, laddr *UDPAddr) (*UDPConn, error) &#123;</span><br><span class="line">fd, err :&#x3D; internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_DGRAM, 0, &quot;listen&quot;, sl.ListenConfig.Control)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return newUDPConn(fd), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sd *sysDialer) dialUDP(ctx context.Context, laddr, raddr *UDPAddr) (*UDPConn, error) &#123;</span><br><span class="line">fd, err :&#x3D; internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_DGRAM, 0, &quot;dial&quot;, sd.Dialer.Control)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return newUDPConn(fd), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，两者最终都是调用<code>internetSocket</code>，但是参数层面有差异，特别是<code>listenUDP</code>调用时<strong>raddr</strong>为nil，而<code>dialUDP</code>会传入该值。</p><p>继续往下看，<code>internetSocket</code>内部会调用<code>socket</code>函数，以linux环境为例，其实现在<em>sock_posix.go</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) &#123;</span><br><span class="line">s, err :&#x3D; sysSocket(family, sotype, proto)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">if err &#x3D; setDefaultSockopts(s, family, sotype, ipv6only); err !&#x3D; nil &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">if fd, err &#x3D; newFD(s, family, sotype, net); err !&#x3D; nil &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This function makes a network file descriptor for the</span><br><span class="line">&#x2F;&#x2F; following applications:</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; - An endpoint holder that opens a passive stream</span><br><span class="line">&#x2F;&#x2F;   connection, known as a stream listener</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; - An endpoint holder that opens a destination-unspecific</span><br><span class="line">&#x2F;&#x2F;   datagram connection, known as a datagram listener</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; - An endpoint holder that opens an active stream or a</span><br><span class="line">&#x2F;&#x2F;   destination-specific datagram connection, known as a</span><br><span class="line">&#x2F;&#x2F;   dialer</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; - An endpoint holder that opens the other connection, such</span><br><span class="line">&#x2F;&#x2F;   as talking to the protocol stack inside the kernel</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; For stream and datagram listeners, they will only require</span><br><span class="line">&#x2F;&#x2F; named sockets, so we can assume that it&#39;s just a request</span><br><span class="line">&#x2F;&#x2F; from stream or datagram listeners when laddr is not nil but</span><br><span class="line">&#x2F;&#x2F; raddr is nil. Otherwise we assume it&#39;s just for dialers or</span><br><span class="line">&#x2F;&#x2F; the other connection holders.</span><br><span class="line"></span><br><span class="line">if laddr !&#x3D; nil &amp;&amp; raddr &#x3D;&#x3D; nil &#123;</span><br><span class="line">switch sotype &#123;</span><br><span class="line">case syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line">if err :&#x3D; fd.listenStream(laddr, listenerBacklog(), ctrlFn); err !&#x3D; nil &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return fd, nil</span><br><span class="line">case syscall.SOCK_DGRAM:</span><br><span class="line">if err :&#x3D; fd.listenDatagram(laddr, ctrlFn); err !&#x3D; nil &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return fd, nil</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if err :&#x3D; fd.dial(ctx, laddr, raddr, ctrlFn); err !&#x3D; nil &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return fd, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建socket描述符，如果<code>laddr</code>不为nil，而<code>raddr</code>为nil，说明是监听socket，需要调用<code>Listen</code>函数，接下来调用<code>fd.dial</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">func (fd *netFD) dial(ctx context.Context, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) error &#123;</span><br><span class="line">if ctrlFn !&#x3D; nil &#123;</span><br><span class="line">c, err :&#x3D; newRawConn(fd)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">var ctrlAddr string</span><br><span class="line">if raddr !&#x3D; nil &#123;</span><br><span class="line">ctrlAddr &#x3D; raddr.String()</span><br><span class="line">&#125; else if laddr !&#x3D; nil &#123;</span><br><span class="line">ctrlAddr &#x3D; laddr.String()</span><br><span class="line">&#125;</span><br><span class="line">if err :&#x3D; ctrlFn(fd.ctrlNetwork(), ctrlAddr, c); err !&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var err error</span><br><span class="line">var lsa syscall.Sockaddr</span><br><span class="line">if laddr !&#x3D; nil &#123;</span><br><span class="line">if lsa, err &#x3D; laddr.sockaddr(fd.family); err !&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125; else if lsa !&#x3D; nil &#123;</span><br><span class="line">if err &#x3D; syscall.Bind(fd.pfd.Sysfd, lsa); err !&#x3D; nil &#123;</span><br><span class="line">return os.NewSyscallError(&quot;bind&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var rsa syscall.Sockaddr  &#x2F;&#x2F; remote address from the user</span><br><span class="line">var crsa syscall.Sockaddr &#x2F;&#x2F; remote address we actually connected to</span><br><span class="line">if raddr !&#x3D; nil &#123;</span><br><span class="line">if rsa, err &#x3D; raddr.sockaddr(fd.family); err !&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">if crsa, err &#x3D; fd.connect(ctx, lsa, rsa); err !&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">fd.isConnected &#x3D; true</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if err :&#x3D; fd.init(); err !&#x3D; nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Record the local and remote addresses from the actual socket.</span><br><span class="line">&#x2F;&#x2F; Get the local address by calling Getsockname.</span><br><span class="line">&#x2F;&#x2F; For the remote address, use</span><br><span class="line">&#x2F;&#x2F; 1) the one returned by the connect method, if any; or</span><br><span class="line">&#x2F;&#x2F; 2) the one from Getpeername, if it succeeds; or</span><br><span class="line">&#x2F;&#x2F; 3) the one passed to us as the raddr parameter.</span><br><span class="line">lsa, _ &#x3D; syscall.Getsockname(fd.pfd.Sysfd)</span><br><span class="line">if crsa !&#x3D; nil &#123;</span><br><span class="line">fd.setAddr(fd.addrFunc()(lsa), fd.addrFunc()(crsa))</span><br><span class="line">&#125; else if rsa, _ &#x3D; syscall.Getpeername(fd.pfd.Sysfd); rsa !&#x3D; nil &#123;</span><br><span class="line">fd.setAddr(fd.addrFunc()(lsa), fd.addrFunc()(rsa))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fd.setAddr(fd.addrFunc()(lsa), raddr)</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导致<code>ListenUDP</code>、<code>DialUDP</code>的行为差异的核心实现即在此函数</p><p>如果<code>laddr</code>不为nil，还需要调用<code>bind</code>函数，绑定本地ip、port信息，如果<code>raddr</code>不为nil，会调用<code>fd.connect</code>与remote建立连接。</p><p>如此即导致<code>ListenUDP</code>函数构造的UDPConn为<strong>未连接</strong>状态，而<code>DialUDP</code>函数构造的UDPConn为<strong>已连接</strong>状态，因而<code>DialUDP</code>只能从指定远端接收数据，而<code>ListenUDP</code>则可以从任何远端接收数据。</p><p>至此，谜底彻底揭开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang中udp分为已连接和未连接两种，两者在发送、接收消息行为模式上有重大区别&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>docker中进程优雅退出</title>
    <link href="http://www.xiaocc.xyz/2019-11-26/docker%E8%BF%9B%E7%A8%8B%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA/"/>
    <id>http://www.xiaocc.xyz/2019-11-26/docker%E8%BF%9B%E7%A8%8B%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA/</id>
    <published>2019-11-26T07:30:00.000Z</published>
    <updated>2019-11-26T08:12:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录docker中的进程如何优雅退出</p><a id="more"></a><h4><span id="前言">前言</span></h4><p>在云时代的背景下，当前大多数服务进程都运行在容器中，在容器调度或者手动结束容器时，如何确保服务进程完整处理完某次请求，如何让进程退出之前执行相关收尾动作(如把内存中的数据落盘、把监控数据上报等)。</p><p>这就涉及到容器中进程的优雅退出问题，进程不能突如其来的被结束，而需要先通知进程、再将其结束。</p><p>首先看看容器中启动进程的两种模式：</p><ul><li>exec模式</li><li>shell模式</li></ul><p>其中：<br>exec模式启动的进程id为<code>1</code>，而通过shell模式启动的进程为sh子进程，进程id不固定<br>但是，在exec模式中由于不是通过shell启动的进程，所以不能取到shell相关的环境变量</p><p>文章：<a href="https://www.cnblogs.com/sparkdev/p/8461576.html" target="_blank" rel="noopener">Dockerfile 中的 CMD 与 ENTRYPOINT</a>，对此有详细解释，一般推荐使用exec模式</p><p>通过<code>docker stop</code>关闭容器时，其会先往容器内的<code>1</code>号进程发送<code>SIGTERM</code>信号，然后等待一段时间，再发送<code>SIGKILL</code>信号结束进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stop --help</span><br><span class="line"></span><br><span class="line">Usage:docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Stop one or more running containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -t, --time int   Seconds to wait for stop before killing it (default 10)</span><br></pre></td></tr></table></figure><h4><span id="实践">实践</span></h4><p>据此，我们可以让用户进程监听<code>SIGTERM</code>信号，收到信号时执行相应清理动作，然后退出</p><p>测试代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;os&#x2F;signal&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;program start ...&quot;)</span><br><span class="line"></span><br><span class="line">    ch :&#x3D; make(chan os.Signal, 1)</span><br><span class="line">    signal.Notify(ch, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">    s :&#x3D; &lt;-ch</span><br><span class="line"></span><br><span class="line">    if s &#x3D;&#x3D; syscall.SIGTERM &#123;</span><br><span class="line">        fmt.Println(&quot;sigterm received&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;exit ...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序启动时监听<code>SIGTERM</code>信号，通过docker stop结束容器，可以观察到相应信号接收日志</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录docker中的进程如何优雅退出&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>拓扑排序笔记</title>
    <link href="http://www.xiaocc.xyz/2019-11-06/%E6%8B%93%E6%89%91%E8%AE%A1%E7%AE%97/"/>
    <id>http://www.xiaocc.xyz/2019-11-06/%E6%8B%93%E6%89%91%E8%AE%A1%E7%AE%97/</id>
    <published>2019-11-06T05:30:00.000Z</published>
    <updated>2019-11-06T08:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在任务依赖关系流中，计算任务执行顺序</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>在工作中我们经常碰到这种问题：各个任务之间存在依赖关系，我们如何规划任务的执行顺序，使任务满足依赖要求。</p><p>如下图：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/399159-20151229144326901-1530781288.png"></p><p>有向边(u,v)表示任务v依赖u，也就是说必须先执行任务u，才能执行任务v<br>上图中的拓扑顺序：<code>ABFCDE</code>即是一种正确的执行顺序</p><p>而下图：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/399159-20151229144340448-1796643731.png"></p><p>上图中的拓扑顺序：<code>ABECDF</code>不正确，因为任务<code>E</code>依赖任务<code>C</code>，必须先执行任务<code>C</code>之后才能执行任务<code>E</code></p><h4><span id="拓扑排序算法">拓扑排序算法</span></h4><p>如何实现拓扑排序算法，有两种实现方式：</p><ul><li>入度表</li><li>DFS</li></ul><p>下面分别讲解两种算法的实现流程</p><h5><span id="入度表">入度表</span></h5><p>可以观察到，如果一个任务U，不依赖任何其它任务，那么它的入度为<code>0</code><br>所以该算法流程如下：</p><ul><li>找出图中入度为<code>0</code>的点</li><li>删除该点，再次在图中找出入度为<code>0</code>的点</li><li>再删除…再找出…</li><li>直到图中所有顶点</li></ul><p>如上图中依赖关系，可以构造如下入度表：</p><table><thead><tr><th align="center">入度表</th><th align="center">选择节点</th></tr></thead><tbody><tr><td align="center">A:0 B:1 C:1 D:2 E:2 F:0</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">A</td></tr><tr><td align="center">B:0 C:1 D:1 E:2 F:0</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">B</td></tr><tr><td align="center">C:0 D:1 E:2 F:0</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">C</td></tr><tr><td align="center">D:0 E:1 F:0</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">D</td></tr><tr><td align="center">E:0 F:0</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">E</td></tr><tr><td align="center">F:0</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">F</td></tr></tbody></table><p>执行顺序：ABCDEF，由于节点F不依赖任何节点，其可以在任何时机执行</p><h5><span id="dfs">DFS</span></h5><p>即是深度遍历，从入度为<code>0</code>的节点开始进行深度遍历，到底的时候开始回溯，并将相关节点保存在栈中，最后将栈中的节点弹出，该出栈顺序即为节点执行顺序</p><p>以一个实际例子来进行说明：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20191106-155744.jpg"></p><table><thead><tr><th align="center">遍历流程</th><th align="center">回溯入栈</th></tr></thead><tbody><tr><td align="center">0 -&gt; 1 -&gt; 2 -&gt; 6</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">6</td></tr><tr><td align="center"></td><td align="center">2</td></tr><tr><td align="center">0 -&gt; 1 -&gt; 5 -&gt; 7</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">7</td></tr><tr><td align="center"></td><td align="center">5</td></tr><tr><td align="center">0 -&gt; 1 -&gt; 3</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">3</td></tr><tr><td align="center"></td><td align="center">1</td></tr><tr><td align="center"></td><td align="center">0</td></tr><tr><td align="center">4</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">4</td></tr></tbody></table><p>栈弹出顺序：40135726</p><p>具体DFS遍历顺序可以参考动态演示：<br><a href="https://www.cs.usfca.edu/~galles/visualization/TopoSortDFS.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/TopoSortDFS.html</a></p><p><strong>参考资料</strong></p><ul><li><a href="https://www.cnblogs.com/en-heng/p/5085690.html" target="_blank" rel="noopener">有向无环图的拓扑排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在任务依赖关系流中，计算任务执行顺序&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>btcpool矿池搭建</title>
    <link href="http://www.xiaocc.xyz/2019-10-03/btcpool%E7%9F%BF%E6%B1%A0%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.xiaocc.xyz/2019-10-03/btcpool%E7%9F%BF%E6%B1%A0%E6%90%AD%E5%BB%BA/</id>
    <published>2019-10-03T00:30:00.000Z</published>
    <updated>2019-10-03T01:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>比特币矿池搭建</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>有个前同事目前在北京做数字货币交易，级别是币圈大佬，有天发个链接问我，这个难不难搭建。我瞧了一眼，有很详细的搭建流程，应该不难，可以试试。</p><p>周末尝试搭建，并阅读比特币相关资料，特此即之。</p><h4><span id="btcpool">btcpool</span></h4><p>github地址：<br><a href="https://github.com/btccom/btcpool" target="_blank" rel="noopener">https://github.com/btccom/btcpool</a></p><p>其整体架构如图：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/btcpool.png"></p><p>初次看到这张图有点懵逼，其实，首先找到数据的起始点，然后跟着数据流向，再结合文档就能很容易的理解各个服务的作用。</p><h4><span id="依赖">依赖</span></h4><p>从图中可知整个矿池依赖<code>zookeeper</code>、<code>kafka</code>，整个矿池的核心即是以<code>kafka</code>为数据交换中心</p><p>而<code>bitcoind</code>即是比特币核心，其加入比特币网络，下载历史交易链数据，获取当前未上链交易数据。<br>比特币网络分为<code>正式环境</code>和<code>测试环境</code>，可以先用测试网络搭建矿池，测试功能，因为正式环境的hash计算难度太高，而测试环境相对来说比较容易获得解。</p><h4><span id="各个服务">各个服务</span></h4><ul><li>GbtMaker——通过<code>getblocktemplate</code> rpc接口从bitcoind获取挖矿所需数据，并把数据(rawgbt)发送到kafka</li></ul><p>比特币区块头部结构如下：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/1666320-20190423103204842-912445068.jpg"></p><p><code>previousblockhash</code>当前已确认的最新块的hash值<br><code>nBits</code>挖矿难度，第1个字节表示数据长度，后3个字节表示数据头部，数据尾部用0补齐，可以预见该数值特别大，不直观，可以与创世块难度相除以获得一个比值，该比值即代表挖矿难度提升多少倍。<br>可以调整<code>time</code>、<code>nonce</code>以使最终区块hash值满足难度要求</p><ul><li><p>JobMaker——解码GbtMaker发送的rawgbt数据，将coinbase按照extraNone拆分成coinbase1、extraNone和coinbase2，同时根据rawgbt中的交易数据生成merkle hash数组，以便和coinbase交易生成merkel root。将这些数据(stratumjob)发送到kafka</p></li><li><p>StratumServer从kafka消费获取stratumjob数据，并将挖矿数据下发给miner，miner计算获得share后返回给stratumserver，其计算hash是否满足target，并提交到kafka，然后由BlockMaker处理</p></li><li><p>BlockMaker从kafka获取share数据，并结合GbtMaker发送的rawgbt数据，组合成为block，并通过bitcoind rpc提交到比特币网络</p></li><li><p>其它几个服务主要是给portal统计展示使用</p></li></ul><h4><span id="测试">测试</span></h4><p>阿里云申请一台云主机，根据文档搭建btcpool矿池，难度不大。</p><p>难点在于如何测试整个矿池的可用性，bitcoind切换到test-net并用cpu模拟挖矿，跑了半天也没挖出来一个块，计算nbits获取难度比例，已经增长到600万倍，也不知道是哪些人才在测试链挖矿，难度提升这么多。<br>通过区块链浏览器，查询测试链爆块情况，发现几大矿池商均在开发测试。</p><p>无奈之下，通过朋友借了台蚂蚁s9实体矿机，挂上去，不到5min，爆块，哈哈，激动</p><p>经过测试，说明该矿池整体数据流通没问题，接下来就是主链测试</p><h4><span id="主链测试">主链测试</span></h4><p>观察几大矿池商算力及出块情况，起码得1000P，2-3天才能出一个块，而这2-3天的成本要多少呢？<br>一台普通矿机算力30T，<code>1000P/30T=30000</code>，需要大约3万台机器，算单机1万一台，成本3亿。<br>这么大的测试成本，矿场主一般是不愿意切换矿池的，特别是在矿池稳定性存疑的情况下。</p><h4><span id="最后">最后</span></h4><p>阅读了其它比特币相关资料，如比特币白皮书等，以及51%算力攻击，POW文档等</p><p>附：自己画的容灾架构图</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/btcpool%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比特币矿池搭建&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.xiaocc.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>nomad集群搭建</title>
    <link href="http://www.xiaocc.xyz/2019-06-20/nomad%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.xiaocc.xyz/2019-06-20/nomad%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2019-06-20T14:30:00.000Z</published>
    <updated>2019-07-10T03:44:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式作业调度系统nomad集群搭建</p><a id="more"></a><h4><span id="引子">引子</span></h4><p>在上篇中提到nomad的基本用法，当时使用的是dev环境，也即一个nomad进程同时充当server和client</p><p>在高可用环境中，这是无法忍受的，需要多台机器构建成一个集群然后对外服务</p><p>在本篇中讲讲nomad集群环境的搭建及任务下发到指定datacenter</p><h4><span id="server端配置">server端配置</span></h4><p>nomad的server端采用raft协议选主，client端通过gossip协议交换信息</p><p>nomad配置文档如下：<br><a href="https://www.nomadproject.io/docs/configuration/index.html" target="_blank" rel="noopener">https://www.nomadproject.io/docs/configuration/index.html</a></p><p>我们构造两个server端组成集群，相关配置文件如下：</p><p><strong>server1.hcl</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &quot;server1&quot;</span><br><span class="line"></span><br><span class="line">log_level &#x3D; &quot;DEBUG&quot;</span><br><span class="line"></span><br><span class="line">data_dir &#x3D; &quot;&#x2F;data&#x2F;nomad&#x2F;server1&quot;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    enabled &#x3D; true</span><br><span class="line">    bootstrap_expect &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ports &#123;</span><br><span class="line">  http &#x3D; 4646</span><br><span class="line">  rpc  &#x3D; 4647</span><br><span class="line">  serf &#x3D; 4648</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>server2.hcl</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &quot;server2&quot;</span><br><span class="line"></span><br><span class="line">log_level &#x3D; &quot;DEBUG&quot;</span><br><span class="line"></span><br><span class="line">data_dir &#x3D; &quot;&#x2F;data&#x2F;nomad&#x2F;server2&quot;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    enabled &#x3D; true</span><br><span class="line">    bootstrap_expect &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ports &#123;</span><br><span class="line">  http &#x3D; 4746</span><br><span class="line">  rpc  &#x3D; 4747</span><br><span class="line">  serf &#x3D; 4748</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：每个node的名字要唯一<br><em>由于我是将两个server端部署在同一台物理机，所以将端口做了更改，避免端口冲突</em></p><h4><span id="启动server端">启动server端</span></h4><p>首先启动<code>server1</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad agent -config server1.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; WARNING: Bootstrap mode enabled! Potentially unsafe operation.</span><br><span class="line">&#x3D;&#x3D;&gt; Loaded configuration from server1.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; Starting Nomad agent...</span><br><span class="line">&#x3D;&#x3D;&gt; Nomad agent configuration:</span><br><span class="line"></span><br><span class="line">       Advertise Addrs: HTTP: 172.17.0.1:4646; RPC: 172.17.0.1:4647; Serf: 172.17.0.1:4648</span><br><span class="line">            Bind Addrs: HTTP: 0.0.0.0:4646; RPC: 0.0.0.0:4647; Serf: 0.0.0.0:4648</span><br><span class="line">                Client: false</span><br><span class="line">             Log Level: DEBUG</span><br><span class="line">                Region: global (DC: dc1)</span><br><span class="line">                Server: true</span><br><span class="line">               Version: 0.9.3</span><br></pre></td></tr></table></figure><p>表明server1已经启动，我们查看集群server状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad server members</span><br><span class="line">Name            Address     Port  Status  Leader  Protocol  Build  Datacenter  Region</span><br><span class="line">server1.global  172.17.0.1  4648  alive   true    2         0.9.3  dc1         global</span><br></pre></td></tr></table></figure><p>只有一台server，接下来我们启动<code>server2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad agent -config server2.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; WARNING: Bootstrap mode enabled! Potentially unsafe operation.</span><br><span class="line">&#x3D;&#x3D;&gt; Loaded configuration from server2.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; Starting Nomad agent...</span><br><span class="line">&#x3D;&#x3D;&gt; Nomad agent configuration:</span><br><span class="line"></span><br><span class="line">       Advertise Addrs: HTTP: 172.17.0.1:4746; RPC: 172.17.0.1:4747; Serf: 172.17.0.1:4748</span><br><span class="line">            Bind Addrs: HTTP: 0.0.0.0:4746; RPC: 0.0.0.0:4747; Serf: 0.0.0.0:4748</span><br><span class="line">                Client: false</span><br><span class="line">             Log Level: DEBUG</span><br><span class="line">                Region: global (DC: dc1)</span><br><span class="line">                Server: true</span><br><span class="line">               Version: 0.9.3</span><br></pre></td></tr></table></figure><p>这时再次查看集群状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad server members</span><br><span class="line">Name            Address     Port  Status  Leader  Protocol  Build  Datacenter  Region</span><br><span class="line">server1.global  172.17.0.1  4648  alive   true    2         0.9.3  dc1         global</span><br></pre></td></tr></table></figure><p>依然只有一台server端，为什么呢？我们明明启动了2台server端，怎么回事？</p><p>由于server1、server2互不知晓，无法构成集群，需要手动添加入集群，这做法类似于redis集群的搭建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad server join &quot;172.17.0.1:4748&quot;</span><br><span class="line">Joined 1 servers successfully</span><br><span class="line"></span><br><span class="line">.&#x2F;nomad server members</span><br><span class="line">Name            Address     Port  Status  Leader  Protocol  Build  Datacenter  Region</span><br><span class="line">server1.global  172.17.0.1  4648  alive   true    2         0.9.3  dc1         global</span><br><span class="line">server2.global  172.17.0.1  4748  alive   false   2         0.9.3  dc1         global</span><br></pre></td></tr></table></figure><p>可见server1、server2构建集群成功，并选举出server1作为leader</p><h4><span id="client端配置">client端配置</span></h4><p>nomad的client端，作为任务具体执行的node，所有任务均是在client端执行</p><p>client端可以构建成不同的datacenter，将不同的任务下发指定datacenter执行</p><p><strong>client1.hcl</strong><br>这里指定client1的datacent为beta</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &quot;client1&quot;</span><br><span class="line"></span><br><span class="line"># Increase log verbosity</span><br><span class="line">log_level &#x3D; &quot;DEBUG&quot;</span><br><span class="line"></span><br><span class="line"># Setup data dir</span><br><span class="line">data_dir &#x3D; &quot;&#x2F;data&#x2F;nomad&#x2F;client1&quot;</span><br><span class="line"></span><br><span class="line"># Enable the client</span><br><span class="line">client &#123;</span><br><span class="line">enabled &#x3D; true</span><br><span class="line"></span><br><span class="line"># For demo assume we are talking to server1. For production,</span><br><span class="line"># this should be like &quot;nomad.service.consul:4647&quot; and a system</span><br><span class="line"># like Consul used for service discovery.</span><br><span class="line">servers &#x3D; [&quot;172.17.0.1:4647&quot;]</span><br><span class="line"></span><br><span class="line">options &#123;</span><br><span class="line">    &quot;driver.raw_exec.enable&quot; &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Modify our port to avoid a collision with server1</span><br><span class="line">ports &#123;</span><br><span class="line">http &#x3D; 5656</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">datacenter &#x3D; &quot;beta&quot;</span><br></pre></td></tr></table></figure><p><strong>client2.hcl</strong><br>这里指定client2的datacenter为release</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; &quot;client2&quot;</span><br><span class="line"></span><br><span class="line"># Increase log verbosity</span><br><span class="line">log_level &#x3D; &quot;DEBUG&quot;</span><br><span class="line"></span><br><span class="line"># Setup data dir</span><br><span class="line">data_dir &#x3D; &quot;&#x2F;data&#x2F;nomad&#x2F;client2&quot;</span><br><span class="line"></span><br><span class="line"># Enable the client</span><br><span class="line">client &#123;</span><br><span class="line">enabled &#x3D; true</span><br><span class="line"></span><br><span class="line"># For demo assume we are talking to server1. For production,</span><br><span class="line"># this should be like &quot;nomad.service.consul:4647&quot; and a system</span><br><span class="line"># like Consul used for service discovery.</span><br><span class="line">servers &#x3D; [&quot;172.17.0.1:4647&quot;]</span><br><span class="line"></span><br><span class="line">options &#123;</span><br><span class="line">    &quot;driver.raw_exec.enable&quot; &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Modify our port to avoid a collision with server1</span><br><span class="line">ports &#123;</span><br><span class="line">http &#x3D; 5756</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">datacenter &#x3D; &quot;release&quot;</span><br></pre></td></tr></table></figure><h4><span id="启动client端">启动client端</span></h4><p>首先启动client1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad agent -config client1.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; Loaded configuration from client1.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; Starting Nomad agent...</span><br><span class="line">&#x3D;&#x3D;&gt; Nomad agent configuration:</span><br><span class="line"></span><br><span class="line">       Advertise Addrs: HTTP: 172.17.0.1:5656</span><br><span class="line">            Bind Addrs: HTTP: 0.0.0.0:5656</span><br><span class="line">                Client: true</span><br><span class="line">             Log Level: DEBUG</span><br><span class="line">                Region: global (DC: beta)</span><br><span class="line">                Server: false</span><br><span class="line">               Version: 0.9.3</span><br></pre></td></tr></table></figure><p>client1启动成功，查看node状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad node status</span><br><span class="line">ID        DC    Name     Class   Drain  Eligibility  Status</span><br><span class="line">485c95fb  beta  client1  &lt;none&gt;  false  eligible     ready</span><br></pre></td></tr></table></figure><p>当前有一个node节点，datacenter为beta</p><p>接下来启动client2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad agent -config client2.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; Loaded configuration from client2.hcl</span><br><span class="line">&#x3D;&#x3D;&gt; Starting Nomad agent...</span><br><span class="line">&#x3D;&#x3D;&gt; Nomad agent configuration:</span><br><span class="line"></span><br><span class="line">       Advertise Addrs: HTTP: 172.17.0.1:5756</span><br><span class="line">            Bind Addrs: HTTP: 0.0.0.0:5756</span><br><span class="line">                Client: true</span><br><span class="line">             Log Level: DEBUG</span><br><span class="line">                Region: global (DC: release)</span><br><span class="line">                Server: false</span><br><span class="line">               Version: 0.9.3</span><br></pre></td></tr></table></figure><p>启动client2成功，查看node状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad node status</span><br><span class="line">ID        DC       Name     Class   Drain  Eligibility  Status</span><br><span class="line">fd00db81  release  client2  &lt;none&gt;  false  eligible     ready</span><br><span class="line">485c95fb  beta     client1  &lt;none&gt;  false  eligible     ready</span><br></pre></td></tr></table></figure><h4><span id="提交任务">提交任务</span></h4><p>我们提交一个任务到client1，也即beta环境执行</p><p><strong>cron.nomad</strong><br>注意：command中命令需要为绝对路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">job &quot;cron&quot; &#123;</span><br><span class="line">    datacenters &#x3D; [&quot;beta&quot;]</span><br><span class="line">    type &#x3D; &quot;batch&quot;</span><br><span class="line"></span><br><span class="line">    group &quot;test&quot; &#123;</span><br><span class="line">        count &#x3D; 1</span><br><span class="line"></span><br><span class="line">        task &quot;one&quot; &#123;</span><br><span class="line">            driver &#x3D; &quot;raw_exec&quot;</span><br><span class="line"></span><br><span class="line">            config &#x3D; &#123;</span><br><span class="line">                command &#x3D; &quot;&#x2F;data&#x2F;nomad&#x2F;one.sh&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad job run cron.nomad</span><br><span class="line">&#x3D;&#x3D;&gt; Monitoring evaluation &quot;a00b43ae&quot;</span><br><span class="line">    Evaluation triggered by job &quot;cron&quot;</span><br><span class="line">    Allocation &quot;d641c9df&quot; created: node &quot;485c95fb&quot;, group &quot;test&quot;</span><br><span class="line">    Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;</span><br><span class="line">&#x3D;&#x3D;&gt; Evaluation &quot;a00b43ae&quot; finished with status &quot;complete&quot;</span><br></pre></td></tr></table></figure><p>查看任务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad job status cron</span><br><span class="line">ID            &#x3D; cron</span><br><span class="line">Name          &#x3D; cron</span><br><span class="line">Submit Date   &#x3D; 2019-06-20T00:36:42Z</span><br><span class="line">Type          &#x3D; batch</span><br><span class="line">Priority      &#x3D; 50</span><br><span class="line">Datacenters   &#x3D; beta</span><br><span class="line">Status        &#x3D; running</span><br><span class="line">Periodic      &#x3D; false</span><br><span class="line">Parameterized &#x3D; false</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">Task Group  Queued  Starting  Running  Failed  Complete  Lost</span><br><span class="line">test        0       0         1        0       0         0</span><br><span class="line"></span><br><span class="line">Allocations</span><br><span class="line">ID        Node ID   Task Group  Version  Desired  Status   Created  Modified</span><br><span class="line">d641c9df  485c95fb  test        0        run      running  38s ago  38s ago</span><br></pre></td></tr></table></figure><p><code>Datacenters = beta</code><br>可见该任务在beta环境执行，通过查看日志也可以确定该任务在client1机器执行</p><h4><span id="修改任务">修改任务</span></h4><p>接下来，我们模拟任务变更，即我们先在beta环境测试，测试通过后，需要在release环境执行</p><p>修改<code>cron.nomad</code>，将<br><code>datacenters = [&quot;beta&quot;]</code><br>修改为<br><code>datacenters = [&quot;release&quot;]</code></p><p>查看新任务将如何执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad job plan cron.nomad</span><br><span class="line">+&#x2F;- Job: &quot;cron&quot;</span><br><span class="line">+&#x2F;- Datacenters &#123;</span><br><span class="line">  + Datacenters: &quot;release&quot;</span><br><span class="line">  - Datacenters: &quot;beta&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    Task Group: &quot;test&quot; (1 create, 1 ignore)</span><br><span class="line">      Task: &quot;one&quot;</span><br></pre></td></tr></table></figure><p>提交任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad job run cron.nomad</span><br><span class="line">&#x3D;&#x3D;&gt; Monitoring evaluation &quot;19fb697c&quot;</span><br><span class="line">    Evaluation triggered by job &quot;cron&quot;</span><br><span class="line">    Allocation &quot;6b335975&quot; created: node &quot;fd00db81&quot;, group &quot;test&quot;</span><br><span class="line">    Allocation &quot;6b335975&quot; status changed: &quot;pending&quot; -&gt; &quot;running&quot; (Tasks are running)</span><br><span class="line">    Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;</span><br><span class="line">&#x3D;&#x3D;&gt; Evaluation &quot;19fb697c&quot; finished with status &quot;complete&quot;</span><br></pre></td></tr></table></figure><p>查看任务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad job status cron</span><br><span class="line">ID            &#x3D; cron</span><br><span class="line">Name          &#x3D; cron</span><br><span class="line">Submit Date   &#x3D; 2019-06-20T00:42:49Z</span><br><span class="line">Type          &#x3D; batch</span><br><span class="line">Priority      &#x3D; 50</span><br><span class="line">Datacenters   &#x3D; release</span><br><span class="line">Status        &#x3D; running</span><br><span class="line">Periodic      &#x3D; false</span><br><span class="line">Parameterized &#x3D; false</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">Task Group  Queued  Starting  Running  Failed  Complete  Lost</span><br><span class="line">test        0       0         1        0       1         0</span><br><span class="line"></span><br><span class="line">Allocations</span><br><span class="line">ID        Node ID   Task Group  Version  Desired  Status    Created    Modified</span><br><span class="line">6b335975  fd00db81  test        1        run      running   25s ago    24s ago</span><br><span class="line">d641c9df  485c95fb  test        0        run      complete  6m32s ago  5m41s ago</span><br></pre></td></tr></table></figure><p><code>Datacenters   = release</code><br>可见任务执行的datacenter已经变更为release</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式作业调度系统nomad集群搭建&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.xiaocc.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式作业调度系统nomad</title>
    <link href="http://www.xiaocc.xyz/2019-06-18/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9Fnomad/"/>
    <id>http://www.xiaocc.xyz/2019-06-18/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9Fnomad/</id>
    <published>2019-06-18T06:30:00.000Z</published>
    <updated>2019-06-18T08:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>作业调度系统nomad介绍与使用</p><a id="more"></a><h4><span id="nomad简介">nomad简介</span></h4><p>nomad是一个分布式作业调度系统，其可以管理容器、微服务、批处理任务等。</p><p>其官网如下：<br><code>https://www.nomadproject.io/</code></p><blockquote><p>Nomad is a flexible workload orchestrator that enables an organization to easily<br>deploy and manage any containerized or legacy application using a single,<br>unified workflow. Nomad can run a diverse workload of Docker, non-containerized,<br>microservice, and batch applications.</p></blockquote><blockquote><p>Nomad enables developers to use declarative infrastructure-as-code for deploying applications. Nomad uses bin packing to efficiently schedule jobs and optimize for resource utilization. Nomad is supported on macOS, Windows, and Linux.</p></blockquote><blockquote><p>Nomad is widely adopted and used in production by PagerDuty, Target, Citadel, Trivago, SAP, Pandora, Roblox, eBay, Deluxe Entertainment, and more.</p></blockquote><h4><span id="与k8s区别">与k8s区别</span></h4><p>nomad与当前热门的容器管理系统k8s，有什么区别</p><ul><li>k8s只是一个容器管理系统，而nomad不但可以管理容器，还可以调度服务、批处理任务等等</li><li>nomad由go语言编写，部署简单，无任何依赖，一个binary搞定</li></ul><h4><span id="示例">示例</span></h4><h5><span id="安装">安装</span></h5><p>文档：<a href="https://www.nomadproject.io/intro/getting-started/install.html" target="_blank" rel="noopener">https://www.nomadproject.io/intro/getting-started/install.html</a></p><p>有多种安装方式：</p><ul><li>下载源码自行编译</li><li>下载binary</li><li>通过vagrant安装</li></ul><h5><span id="启动nomad">启动nomad</span></h5><p>nomad支持集群模式和测试dev模式，在dev模式中client、server直接启动，便于研究和测试</p><p>执行：<code>nomad agent -dev</code> 启动nomad</p><p>通过 <code>nomad node status</code> 查看node状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad node status</span><br><span class="line">ID        DC   Name          Class   Drain  Eligibility  Status</span><br><span class="line">3d2f0237  dc1  046ba6241f86  &lt;none&gt;  false  eligible     ready</span><br></pre></td></tr></table></figure><p>nomad的agent内置gossip协议，其运行于server模式下，会通过该协议获取其它server信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad server members</span><br><span class="line">Name                 Address     Port  Status  Leader  Protocol  Build  Datacenter  Region</span><br><span class="line">046ba6241f86.global  172.17.0.7  4648  alive   true    2         0.9.3  dc1         global</span><br></pre></td></tr></table></figure><h5><span id="运行job">运行job</span></h5><p>通过执行<code>nomad job init</code>生成一个任务模板，观察该任务定义文件大体格式</p><p>该模板任务，定义了一个service，其通过docker启动redis服务<br><code>nomad job run example.nomad</code> 即注册了一个job，等待nomad调度运行</p><h5><span id="自定义任务">自定义任务</span></h5><p>如何编写一个自定义job并运行？</p><p><a href="https://www.nomadproject.io/docs/job-specification/index.html" target="_blank" rel="noopener">查看文档</a>，得知任务定义文件基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job</span><br><span class="line">  \_ group</span><br><span class="line">        \_ task</span><br></pre></td></tr></table></figure><p>每个nomad任务文件定义一个<code>job</code>，一个job下可定义多个<code>group</code>，每个group下有多个<code>task</code></p><p>定义在同一个group中的task，nomad会将其分配在相同的node去执行</p><p><code>job、group、task</code>各自又有不同属性</p><p>job的<code>type</code>属性，定义任务类型，有<code>service</code>、<code>batch</code>、<code>system</code>三种类型，<a href="https://www.nomadproject.io/docs/schedulers.html" target="_blank" rel="noopener">详见文档</a></p><p>group的<code>count</code>属性，指定该group下的task需要下发到多少个node执行，一般填<code>1</code></p><p>task的<code>driver</code>属性，指定任务驱动类型，包括<code>docker, qemu, java and exec</code>等，<a href="https://www.nomadproject.io/docs/drivers/index.html" target="_blank" rel="noopener">详见文档</a></p><p>常见的定时作业任务属于<code>batch</code>类型，即定时或周期执行一个<code>bash</code>脚本或者程序</p><p>接下来自定义一个job，在其中执行一个<code>bash</code>脚本</p><p>cron.nomad 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">job &quot;cron&quot; &#123;</span><br><span class="line">datacenters &#x3D; [&quot;dc1&quot;]</span><br><span class="line"></span><br><span class="line">type &#x3D; &quot;batch&quot;</span><br><span class="line"></span><br><span class="line">group &quot;test&quot; &#123;</span><br><span class="line">count &#x3D; 1</span><br><span class="line"></span><br><span class="line">task &quot;one&quot; &#123;</span><br><span class="line">driver &#x3D; &quot;raw_exec&quot;</span><br><span class="line"></span><br><span class="line">config &#x3D; &#123;</span><br><span class="line">command &#x3D; &quot;&#x2F;data&#x2F;nomad&#x2F;one.sh&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>command</code>需要为绝对路径</p><p>one.sh 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">i&#x3D;1</span><br><span class="line">sum&#x3D;0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">  let sum&#x3D;sum+$i</span><br><span class="line">  let i+&#x3D;2</span><br><span class="line">  echo $sum &gt;&gt; &#x2F;data&#x2F;nomad&#x2F;log&#x2F;one.log</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum &gt;&gt; &#x2F;data&#x2F;nomad&#x2F;log&#x2F;one.log</span><br></pre></td></tr></table></figure><p>执行任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nomad job run cron.nomad</span><br><span class="line">&#x3D;&#x3D;&gt; Monitoring evaluation &quot;71f82418&quot;</span><br><span class="line">    Evaluation triggered by job &quot;cron&quot;</span><br><span class="line">    Allocation &quot;15671c83&quot; created: node &quot;92bcf36d&quot;, group &quot;test&quot;</span><br><span class="line">    Allocation &quot;15671c83&quot; status changed: &quot;pending&quot; -&gt; &quot;running&quot; (Tasks are running)</span><br><span class="line">    Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;</span><br><span class="line">&#x3D;&#x3D;&gt; Evaluation &quot;71f82418&quot; finished with status &quot;complete&quot;</span><br></pre></td></tr></table></figure><h5><span id="周期任务">周期任务</span></h5><p>目前小组主要使用nomad来跑定时task，比如每5分钟、每30分钟执行的任务等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">job &quot;after&quot; &#123;</span><br><span class="line"></span><br><span class="line">datacenters &#x3D; [&quot;dc1&quot;]</span><br><span class="line"></span><br><span class="line">type &#x3D; &quot;batch&quot;</span><br><span class="line"></span><br><span class="line">  periodic &#123;</span><br><span class="line">    cron             &#x3D; &quot;*&#x2F;3 * * * * *&quot;</span><br><span class="line">    prohibit_overlap &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">group &quot;test&quot; &#123;</span><br><span class="line">count &#x3D; 1</span><br><span class="line"></span><br><span class="line">task &quot;two&quot; &#123;</span><br><span class="line">driver &#x3D; &quot;raw_exec&quot;</span><br><span class="line"></span><br><span class="line">config &#x3D; &#123;</span><br><span class="line">command &#x3D; &quot;&#x2F;data&#x2F;nomad&#x2F;two.sh&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="ui">UI</span></h4><p>nomad支持可视化页面，对任务、集群进行查看和管理</p><p>URL：http://*:4646/ui/jobs</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190618-163725.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作业调度系统nomad介绍与使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.xiaocc.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>架构设计——高性能</title>
    <link href="http://www.xiaocc.xyz/2019-06-04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    <id>http://www.xiaocc.xyz/2019-06-04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD/</id>
    <published>2019-06-04T08:30:00.000Z</published>
    <updated>2019-06-05T03:45:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>架构设计相关阅读笔记</p><a id="more"></a><h4><span id="引子">引子</span></h4><p>上篇说到，架构设计是为了解决软件系统中的复杂问题，这些问题归纳起来可以分为几个方面：</p><ul><li>高性能</li><li>高可用</li><li>高可扩展</li></ul><p>一个系统的性能往往是工程师最为关注的，因为用户无法忍受长时间的等待，响应耗时每增加100ms，就有相当比例的用户流失。</p><p>该篇讲讲高性能相关架构设计问题</p><p>高性能可分为两大类：</p><ul><li>计算高性能</li><li>存储高性能</li></ul><h4><span id="计算高性能">计算高性能</span></h4><p>一个系统往往有复杂的计算逻辑，该计算会消耗大量时间，如果系统中只有一台机器处理计算请求，那么会造成请求排队、堆积，导致响应延迟增加。</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190604-164032.jpg"></p><p>计算有个特点，只要输入保持不变，计算逻辑过程保持不变，那么计算结果也会不变。</p><p>所以，为了提高计算性能，我们可以选择水平扩展的方式——也就是增加机器，以扩大计算性能。</p><p>现在面临两个新问题，由于初始时候只有一台机器，所有请求都可以传递给该机器进行处理</p><p>现在有两台、乃至多台机器，如何进行任务分配？</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190604-164256.jpg"></p><p>计算有同构和异构的问题，也就是说有些计算过程只能在某些特定机器处理，不能在所有机器处理</p><p>举个例子，有两个计算问题，其中一个特别消耗内存，我们打算通过增加机器的方式来提高计算性能，如果我们只是扩容了一台普通内存的机器，那么消耗大内存的计算问题，无法在新扩容机器上进行计算，如果只是简单按照高配置扩容，性价比又不高，因为另外一个计算问题不需要大内存。</p><p><strong>如何解决上面提到的问题？</strong></p><p>这个时候，需要<strong>任务分配器</strong>来进行任务分配和调度</p><h5><span id="任务分配器">任务分配器</span></h5><p>任务分配器的基本功能是进行任务分配，任务分配根据需求场景不同，采用不同的原则，例如：负载均衡策略、最小耗时策略、异构策略等等。</p><p>任务分配器需要监控下游任务机器，如果机器异常，则不能再对其分配任务，常见策略有心跳检测、负反馈剔除等。</p><p>还有其它任务分配策略：</p><ul><li>轮询</li><li>加权轮询</li><li>根据来源ip、session路由，将用户请求路由到特定机器处理，主要是考虑到缓存问题</li><li>随机</li></ul><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190604-172606.jpg"></p><h4><span id="存储高性能">存储高性能</span></h4><p>主要是解决存储层读写性能低问题，常见的方式有</p><ul><li>读写分离</li><li>数据分片</li><li>添加缓存</li></ul><p>软件系统没有银弹能解决所有问题，上述解决方式会有对应的问题</p><h5><span id="读写分离">读写分离</span></h5><p>该方式适合读多写少的场景，通过增加机器水平扩展，使得读性能同步提高。<br>该架构往往采用主从架构，主机写，从机读，但是主从同步需要时间，特别是网络状况差的情况下，耗时能到分钟级别。</p><p>这个时候，主、从数据往往不一致，由此导致数据延迟问题</p><p>为了应对该问题，引出以下解决方案：</p><ul><li>读己之写，自己数据读主库，他人数据读从库</li><li>核心数据读主库，其它数据读从库</li><li>通过db-proxy层解决</li></ul><p>上述解决方案为侵入式，需要在代码层面手动设置，容易出错</p><h5><span id="数据分片">数据分片</span></h5><p>当单机无法存储全部数据时，需要对数据进行分片存储<br>如何设计分片、寻址算法成为关键</p><p>常用有以下几种方式：</p><ul><li>hash取模</li><li>一致性hash</li><li>路由表</li></ul><p>hash取模法由于机器增减时，需要大量迁移数据，不适用</p><p>一致性hash，有割环法、google函数法两种，数据迁移量小，适用</p><p>路由表，本质上是分离了数据分片和数据寻址，数据属于某一分片id永不变，但是该id的数据部署在哪台机器，由路由表指定</p><h5><span id="缓存">缓存</span></h5><p>数据落地存储一般在SSD或者硬盘中，其吞吐量大但是延迟高，而缓存一般以内存为载体，速度高但是容量低。</p><p>可以将热数据放在缓存中，这样处理请求时不必访问低速的最终存储，转而访问高速的缓存，这样可以减少响应耗时。</p><p>但是缓存也有相应的问题：</p><ul><li>数据一致性</li><li>缓存穿透</li><li>缓存雪崩</li></ul><p>缓存顾名思义只是一种临时存储，其独立于最终存储之外，虽然可以设计缓存更新策略，尽量减少两者数据不一致，但不能避免。</p><p>其实，缓存原本只是作为一种临时存储，用来存储一些非易变的非核心数据，但是由于其使用方便，越来越多的开发者把缓存当做万金油，无缓存不开发，严重依赖缓存，这其实有些滥用。</p><p>缓存穿透：<br>由于缓存中没有数据，导致miss，请求直接打到后端存储层，造成存储层压力过大，甚至整体不可服务。<br>可以将空数据也当做一种数据保存于缓存中，这样不会导致miss，也不会到最终存储层查找，降低存储层压力。<br>异常增多空查询往往由于黑客暴力扫描破解、或者功能设计不合理导致。</p><p>缓存雪崩：<br>缓存中数据由于过期时间到被淘汰，需要重新生成数据以缓存，但是该过程耗时很长，导致大量请求miss，进而均计算数据，进一步导致系统压力增长，最终雪崩。<br>可以通过分布式锁限制数据计算的个数，或者采用后台线程归并本机计算请求，独立计算并更新缓存，其它工作线程等待或者直接返回已过期数据等方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构设计相关阅读笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>架构设计目的与本质</title>
    <link href="http://www.xiaocc.xyz/2019-05-20/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%E4%B8%8E%E6%9C%AC%E8%B4%A8/"/>
    <id>http://www.xiaocc.xyz/2019-05-20/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%E4%B8%8E%E6%9C%AC%E8%B4%A8/</id>
    <published>2019-05-20T04:30:00.000Z</published>
    <updated>2019-05-21T01:55:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>架构设计相关阅读笔记</p><a id="more"></a><h4><span id="架构设计目的">架构设计目的</span></h4><p><strong>架构设计目的是解决软件工程中的复杂问题</strong></p><p>软件工程经历过几个大的变革</p><ul><li>编程语言开发效率低的问题。最初的编程语言只有低级的汇编语言，编写应用软件非常不便利，也不利于调试。为了解决这个问题，诞生了C语言，之后又诞生了C++、Java等语言，解决了第一次软件危机</li><li>多核、多机问题。随着硬件发展，处理器多核架构诞生，传统的单进程架构无法利用多核优势，这时候诞生了多进程、多线程架构，以充分利用单机多核优势，之后诞生的分布式架构，将多机协调工作以完成单机无法做到的工作</li><li>随着软件系统的功能愈发复杂，这时候其它问题成为主要矛盾，例如：如何快速添加新需求而不用更改过多代码，如何保证系统稳定性以应对突发流量，如何测试和升级系统以最小化影响用户</li></ul><h4><span id="为什么要进行架构设计">为什么要进行架构设计</span></h4><p>是不是一定要进行架构设计？<br>没有进行架构设计的系统，也运行得好好的，为什么要做架构设计？<br>架构是不是设计得越复杂越好，是不是只有高大上的设计才能称为架构设计？</p><p>以上是架构设计中经常碰到的问题，还有如下问题也经常碰到：</p><p>别人进行了架构设计，那么我也要做架构设计<br>为了高性能、高可用，所以要做架构设计<br>公司要求必须要做架构设计<br>架构设计可以减少代码量、缩短开发时间，提高开发效率</p><p>会提出这些问题，主要是对架构设计的本质没有理解。</p><p>架构设计的目的是什么？</p><p>不是为了显摆架构师的水平有多深，而是要实实在在的解决当前软件系统中的问题。<br>不能说淘宝用了某某架构、微信用了某某架构，我们也得采用某某设计方案，这些考虑都是脱离实际的，淘宝、微信的业务与我们的业务、用户量级不一样，它们碰到的问题，不一定是我们需要解决的问题，如果照搬，会闹笑话。</p><h4><span id="架构设计三原则">架构设计三原则</span></h4><ul><li>简单原则</li><li>适用原则</li><li>演进原则</li></ul><p>简单的方案有利于实施和测试，复杂的方案开发周期长，如果开发中引入某些bug，在测试中难以发现。简单方案还有另外一个好处，容易找出性能瓶颈点，并进行性能优化。</p><p>架构设计要满足适用原则，能够解决实际问题，而不是为了显摆技术能力，或者照搬大厂的某某方案，由于与大厂在业务维度、技术储备维度、人力资源维度均有较大差异，适合大厂的方案不一定适合自己系统。</p><p>由于软件系统不是一成不变的，为了满足用户需求，需要随时调整与添加功能，不要想着一下子做一个万金油式的方案，一劳永逸。可以采用小步快跑的方式，先开发一个最小化的原型，并保留扩展能力，然后随着业务发展持续优化。</p><h4><span id="架构设计案例分析">架构设计案例分析</span></h4><p>文中以”前浪微博”为例，讲解架构设计详细步骤</p><p>前浪微博与新浪微博业务类似，用户注册后需要通知其它模块，例如：新手礼物模块、vip等级模块、消息发送模块等等，之前采用的是注册模块直接调用相关模块的接口进行通知，这种设计随着系统功能的庞大，越来越不适应。<br>用户点击注册按钮后，注册服务需要与多个模块交互，用户等待延迟长，体验差，另一方面，相关模块经常出问题，导致注册服务通知调用失败，最终给用户的反馈就是注册失败。</p><p>架构师经过分析，主要是各个模块之间耦合严重，决定利用消息队列来对用户注册事件进行分发，其它对该事件感兴趣模块自由监听该事件消息，这样就解决了上面提到的两个问题。</p><p>当前系统负载情况如下：<br>用户注册qps大约1200/s，下游需要监听该事件的模块数量约10个。<br>推论出消息队列写qps大约1200/s，读qps约<code>1200 * 10 = 1.2w/s</code>。</p><p>接下来进行方案选型，备选方案一般选择<code>3-4</code>个，低于3个一般是思维狭隘、眼界不够，多于4个会导致方案辩论时间过长，甚至无法选择出最终方案。</p><p>接下来是团队背景信息：</p><ol><li>开发团队人员5人，技术栈为Java，但有两个同事C/C++特别牛</li><li>中间件团队人员5人</li><li>运维团队人员3人</li></ol><p>备选方案有3个，开源方案kafka、Mysql+自研、纯自研</p><p>接下来进行360度方案评估：</p><table><thead><tr><th>360</th><th align="center">kafka</th><th align="center">Mysql</th><th align="center">纯自研</th></tr></thead><tbody><tr><td>开发团队</td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td>中间件团队</td><td align="center">4</td><td align="center">5</td><td align="center">6</td></tr><tr><td>运维团队</td><td align="center">7</td><td align="center">8</td><td align="center">9</td></tr></tbody></table><p>评估核心：</p><ul><li>kafka<ul><li>开发团队、中间件团队无意见，主要依赖运维团队，后者表示对kafka不熟悉，并且监控告警机制不完善，担心开源组件稳定性，如果出现问题，无法解决</li></ul></li><li>Mysql<ul><li>开发团队无意见，运维团队对Mysql非常熟练无意见，中间件团队表示无意见，少量开发工作，有利于提高其部门开发实力，同时利于在公司内部露脸彰显技术实力</li></ul></li><li>纯自研<ul><li>开发团队、运维团队表示对中间件团队开发该量级大系统能力表示怀疑，纯自研组件可靠性、稳定性待检测，开发周期长，时间上不允许 </li></ul></li></ul><p>最后架构师基于相关背景、资源，在该约束情况下选择Mysq自研的方式，同时考虑到以下几点：</p><ul><li>Mysql的稳定性、可靠性高，社区活跃、文档多</li><li>Mysql单机性能不错，可以达到2000/s，架构设计时对消息分片以利用多机能力</li><li>运维团队对Mysql熟悉，监控、告警机制齐全</li></ul><p>接下来进行详细的方案设计与讨论</p><h4><span id="总结">总结</span></h4><p>综上，架构设计是为了解决项目中的复杂问题，在有约束情况下(团队技术栈、运维资源)寻找最优解，而不是盲目崇拜大厂方案。<br>技术最终是为了业务而服务，需要遵循架构设计的演化原则，不要想着一步登天，一下子做一个全球领先的方案，以适用业务为原则，只要能实际解决业务遇到的迫切问题就是好方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构设计相关阅读笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>单点登录(SSO)阅读笔记</title>
    <link href="http://www.xiaocc.xyz/2019-04-20/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95(SSO)%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.xiaocc.xyz/2019-04-20/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95(SSO)%E7%AC%94%E8%AE%B0/</id>
    <published>2019-04-20T08:00:00.000Z</published>
    <updated>2019-04-20T10:07:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>分析实现SSO的几种方式</p><a id="more"></a><h4><span id="为什么需要sso">为什么需要SSO</span></h4><p>首先看看什么叫SSO，也即一次登录、多次使用。<br>比如一个公司内部有很多个管理系统，这些系统在功能上互相独立，我们可以对每个系统做一套独立的账号系统，但是这样做，每个用户需要申请多个账号，并且每打开一个新系统的页面都需要登录，非常繁琐。<br>而且由于账号分散到各个系统，也不利于权限的统一管理。</p><p>如下图：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-161602.jpg"></p><p>所以，我们需要一个系统能够解决以上问题，我们将该问题拆解成如下几个子问题进行解决。</p><h4><span id="单系统保持登录状态">单系统保持登录状态</span></h4><p>首先看看最简单的一个问题，某个系统M，如果用户A已经登录，关闭该系统页面，并重新打开，如何自动登录。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-162302.jpg"></p><p>用户通过浏览器访问系统M，能不能在浏览器侧保存某种信息，以记录用户的登录状态？</p><p>可以的，浏览器可以保存数据到cookie中，并进行持久存储，那么可以将用户登录状态保存其中。</p><p>用户首次访问系统M，由于未登录，弹出登录框，用户输入账号、密码信息，后台系统验证通过后，生成一个带有效期的SessionID信息，并将其下发给client侧，后者将其保存在cookie中，之后的请求中均带上SessionID信息，这样服务器侧根据该信息就知道用户具体信息，而不需要用户再次登录。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-163144.jpg"></p><p>这样当用户再次访问系统M时，首先检查cookie信息，并将其与服务器校验有效性，如果其依然处于有效期，则不用输入账号、密码，直接登录成功。</p><h4><span id="多系统保持登录状态">多系统保持登录状态</span></h4><p>这里的多系统分为两种情况：</p><ul><li>多个系统处于同一个域名下，例如：公司内部的管理系统，m.oa.com，n.oa.com</li><li>多个系统域名不同，例如：微信、QQ均可以采用某种账号登录，m.wx.com，m.qq.com</li></ul><h5><span id="同域名登录">同域名登录</span></h5><p>在之前的讨论中，用户访问M系统(m.oa.com)，在其输入账号、密码并登录成功后，其将服务器下发的SessionID信息保存到cookie中，这时候保存的域为<code>m.oa.com</code>，要想实现同域下的访问，只需要将cookie保存的域更改为<code>.oa.com</code>即可。</p><p>如此之后，用户访问N系统(n.oa.com)，由于两者处于同一个域下，即可访问刚才由M系统保存的cookie信息，从而实现自动登录。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-165028.jpg"></p><h5><span id="跨域名登录">跨域名登录</span></h5><p>不同域名的两个系统如何实现单点登录？根据浏览器cookie规则，不允许跨域访问，主要是为了安全性。<br>我们想象一下，如果不采用SSO单点登录，那么用户登录两个系统，m.wx.com，m.qq.com，均需要输入账号、密码，而这个账号密码页的域名是同一个，sso.oa.com。</p><p>那么我们能不能借助该共同信息，以实现SSO单点登录。</p><p>答案是可以的，只是由于跨域和安全性问题，流程比较复杂，具体流程如下：</p><div id="sequence-0"></div><p>用户在此之后，如果再次访问域名M，由于该域的cookie下有登录ticket，只需要拿着该ticket向服务器进行校验，即可实现自动登录。</p><p>在此之后，如果用户访问跨域页面N，看看如何自动登录：</p><div id="sequence-1"></div><p>如此，即实现了域名N的自动登录。</p><h4><span id="核心">核心</span></h4><ul><li>将公用登录SessionID信息保存到登录页面SSO域的cookie中</li><li>各自系统的登录状态、ticket信息保存到各自域的cookie中</li><li>各个系统生成独立的ticket，主要是为了避免cookie泄漏等漏洞。避免黑客攻破一个系统M，拿到cookie信息，即可自动登录其它系统。</li><li>已登录状态下，SSO页面会询问用户是否授权登录另一系统N</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">用户->域名M:请求访问域名M->域名SSO:用户未登录，重定向到登录界面域名SSO->SSO后台:用户输入账号、密码并登录SSO后台->域名SSO:信息校验成功，生成SessionID，并针对域名M生成ticket_M域名SSO->域名SSO:将SessionID保存到cookie的sso.oa.com域下域名SSO->域名M:重定向，并传递参数ticket_M域名M->M后台:将参数ticket_M传递M后台->SSO后台:校验ticket_M合法性SSO后台->M后台:校验通过M后台->域名M:登录成功域名M->域名M:保存ticket_M到cookie的m.wx.com域下域名M->M后台:其它请求</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">用户->域名N:请求访问域名N->域名SSO:用户未登录，重定向到登录界面域名SSO->域名SSO:由于SSO域名的cookie下，有已登录的SessinID信息域名SSO->用户:询问是否授权登录用户->域名SSO:授权登录域名SSO->SSO后台:拿着SessionID进行校验SSO后台->域名SSO:信息校验成功，针对域名N生成ticket_N域名SSO->域名N:重定向，并传递参数ticket_N域名N->N后台:将参数ticket_N传递N后台->SSO后台:校验ticket_N合法性SSO后台->N后台:校验通过N后台->域名N:登录成功域名N->域名N:保存ticket_N到cookie的m.qq.com域下域名N->N后台:其它请求</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析实现SSO的几种方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>服务响应时间与分布</title>
    <link href="http://www.xiaocc.xyz/2019-04-13/%E6%9C%8D%E5%8A%A1%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%B8%8E%E5%88%86%E5%B8%83/"/>
    <id>http://www.xiaocc.xyz/2019-04-13/%E6%9C%8D%E5%8A%A1%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%B8%8E%E5%88%86%E5%B8%83/</id>
    <published>2019-04-13T06:00:00.000Z</published>
    <updated>2019-04-13T11:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>分析服务响应时间分布，如：均值、中位值、P95值、P99值等如何计算</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>最近看得多，写得少，所谓</p><blockquote><p>学而不思则罔，思而不学则殆</p></blockquote><p>还是得记录笔记，以加强理解。</p><p>有篇博客提到服务响应时间各种值之优劣，特记录之。</p><h4><span id="平均值">平均值</span></h4><p>我们考察一个服务器的性能，除了QPS数据外，还会考察响应时间，当服务器负载增高时，往往会伴随着响应时间的增长，但是这个值该如何度量，以精准的表现服务器当前之负载呢？</p><p>最常用的值为平均值，表示服务的平均响应时间，通过该值我们能够知道服务当前响应的所有请求耗时的平均值。<br>例如平均耗时为100ms，表示服务器当前<code>请求的总耗时/请求总数量</code>，通过该值，我们大体能知道服务运行情况。<br>但是对于具体有多少个请求的耗时比100ms要大，大多少，是200ms，还是500ms，还是1000ms，我们无从得知。<br>而且，平均值这个数据容易掩盖一些<strong>异常值</strong>问题，比如，我的财富加马云财富的平均值也能过亿，所以，平均值这个数据项过于简单，提供的信息量太少。</p><p>那为什么我们通常采用平均值来衡量或者监控服务性能呢？</p><p>主要是由于该值容易计算，采用两个变量<code>S</code>、<code>N</code>，即可持续计算平均值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S &#x3D; S + X</span><br><span class="line">N &#x3D; N + 1</span><br><span class="line">V &#x3D; S&#x2F;N</span><br></pre></td></tr></table></figure><p>通过该公式，当有新的耗时值<code>X</code>需要考量，很方便的就能算出平均值，就算QPS到几十万/s，也不在话下。</p><p>注意，该公式有个隐含问题，即是<code>S</code>增长过快问题，如果QPS过高，<code>X</code>值过大，很容易导致<code>S</code>溢出，从而导致结果计算异常。</p><p>可将该公式做如下改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vs &#x3D; S&#x2F;N</span><br><span class="line">Vn &#x3D; (S+X)&#x2F;(N+1) &#x3D; (Vs*N+X)&#x2F;(N+1) &#x3D; Vs + (X - Vs)&#x2F;(N+1)</span><br></pre></td></tr></table></figure><p>该算法也只需要两个变量，未考量数据<code>X</code>时——平均值<code>Vs</code>、数据个数N<br>但是，该算法由于不累加<code>S</code>，而只累加<code>N</code>，而<code>N</code>的增长极慢，不易导致溢出问题。</p><h4><span id="中位值">中位值</span></h4><p>如上所述，由于平均值不能反映数据分布及极端异常值的问题，可以考虑采用<strong>中位值</strong>来作为度量。</p><p>中位值如何计算？</p><p>我们假设某服务在1s内响应了100个请求，耗时为X1、X2 … X100，可以对这100个数按照从小到大的顺序进行排序，在排序后的列表的中间位置的值——即为中位值，假设为150ms。</p><p>那这个值，150ms，表示什么意思呢？<br>它表示，服务器响应的这100个请求里面有50个的请求耗时小于150ms，另有50个请求的耗时大于150ms。</p><p>如果，我们有一个服务qps为3万/s，经过计算响应耗时中位值为100ms，那么我们可以推断有1.5万个请求的耗时小于100ms，也就是说我们有一半的用户的响应耗时小于100ms，据此我们就可以评估服务响应性能是否可以满足业务要求。</p><p>但是，这个中位值还有另外一个问题，我们只知道还有一半的请求耗时大于100ms，具体是大多少，大200ms，还是500ms，我们无法得知。</p><h4><span id="p95值与p99值">P95值与P99值</span></h4><p>由于中位值只能反映中位数的问题，不能反馈更多信息，例如，我想知道该服务80%的请求耗时在多少ms以内，这些问题需要额外的数据指标。</p><p>P95——响应耗时从小到大排列，顺序处于95%位置的值即为P95值。</p><p>还是采用上面那个例子，100个请求按照响应时间从小到大排列，位置为95的值，即为P95值。<br>我们假设该值为180ms，那这个值又表示什么意思呢？</p><p>意思是说，我们对95%的用户的响应耗时在180ms之内，只有5%的用户的响应耗时大于180ms，据此，我们掌握了更精确的服务响应耗时信息。</p><h4><span id="p999值">P99.9值</span></h4><p>亚马逊经常采用P99.9值，也就是99.9%用户耗时作为指标，也就是1000个用户里面，999个用户的耗时上限，如果测量与优化该值，即可保证绝大多数用户的使用体验。<br>至于P99.99值，优化成本过高，而且服务响应由于网络波动、系统抖动等不能解决之情况，故暂不考虑该指标。</p><h4><span id="如何计算p分位值">如何计算P分位值</span></h4><p>如上说过平均值的计算方式，而P值需要将响应耗时从小到大排序，然后取得对应百分位之值。</p><p>如果服务qps较低，例如：100/秒，记录这100个耗时数据，然后排序，然后取得P分位值，倒不是难事。<br>而如果qps较高，例如：30万/秒，如果还是采用<code>记录+排序</code>的方式，可以预见需要消耗大量内存与计算资源。</p><p>有没有简单的计算方式呢？</p><p>可以采用直方图来进行计算，该计算方式虽不是完全准确值，但精度非常高，误差较小。</p><p>直方图需要界定两个直方之间的跨度，一般采用等分形式，例如对于耗时统计需求，我们可以假定一个耗时上界，然后等分，比如划分成100个区间，对于每个响应耗时落入对应的直方，如下图：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190413-183557.jpg"></p><p>这样就避免了对全部数据进行排序，只需要根据各个直方中的数据数量，即可计算出95%位置位于哪个直方，然后在该直方内部采用插值方法，计算出P95值。</p><p>另外，考虑到数据分布特点，服务耗时异常数据应该只是少数，但是异常值跨度可能很大，大部分耗时数据均靠近正常值，如果直方统计采用等分形式，会导致大量数据堆积在一个直方中，如何解决这个问题？</p><p>可以采用非等分的跨度划分方式，例如采用<strong>指数</strong>形式划分，耗时越低的区间，跨度越小，精度约高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析服务响应时间分布，如：均值、中位值、P95值、P99值等如何计算&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统调用流程</title>
    <link href="http://www.xiaocc.xyz/2019-01-17/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.xiaocc.xyz/2019-01-17/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2019-01-17T14:00:00.000Z</published>
    <updated>2019-01-17T15:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>linux系统调用流程分析</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>在前篇中我们讲到，使用<code>kill</code>系统调用进行<code>signal</code>投递之流程，其中有个点没有提到，系统调用详细流程究竟是怎样的。</p><p>大家应该知道传统的系统调用方式，即通过<code>int 0x80</code>指令，以软中断的形式触发系统调用，并将系统调用号放置在<code>rax</code>寄存器中，系统调用其它参数也通过寄存器传递。</p><p>由于通过软中断实现系统调用比较低效，现在普遍采用<code>syscall</code>指令形式。</p><p>本篇主要讲解以软中断方式实现系统调用之流程，理解了这个方式，再去研究其他方式会更容易。</p><h4><span id="中断向量表">中断向量表</span></h4><p>在CPU中有中断向量表，可以理解为一个数组，数组的内容为地址，也就是当对应中断发生时候的处理地址。</p><p>按照<code>int 0x80</code>指令的字面意思，应该是触发了中断号为<code>0x80</code>的中断，那么其处理函数是什么呢？</p><h4><span id="初始化中断表">初始化中断表</span></h4><p>以<code>x86</code>-32位架构为例，在内核启动时候，会调用<code>trap_init</code>函数，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /arch/x86/kernel/traps.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EISA</span></span><br><span class="line"><span class="keyword">void</span> __iomem *p = early_ioremap(<span class="number">0x0FFFD9</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (readl(p) == <span class="string">'E'</span> + (<span class="string">'I'</span>&lt;&lt;<span class="number">8</span>) + (<span class="string">'S'</span>&lt;&lt;<span class="number">16</span>) + (<span class="string">'A'</span>&lt;&lt;<span class="number">24</span>))</span><br><span class="line">EISA_bus = <span class="number">1</span>;</span><br><span class="line">early_iounmap(p, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">set_intr_gate(<span class="number">0</span>, &amp;divide_error);</span><br><span class="line">set_intr_gate_ist(<span class="number">2</span>, &amp;nmi, NMI_STACK);</span><br><span class="line"><span class="comment">/* int4 can be called from all */</span></span><br><span class="line">set_system_intr_gate(<span class="number">4</span>, &amp;<span class="built_in">overflow</span>);</span><br><span class="line">set_intr_gate(<span class="number">5</span>, &amp;bounds);</span><br><span class="line">set_intr_gate(<span class="number">6</span>, &amp;invalid_op);</span><br><span class="line">set_intr_gate(<span class="number">7</span>, &amp;device_not_available);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">set_task_gate(<span class="number">8</span>, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">set_intr_gate_ist(<span class="number">8</span>, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">set_intr_gate(<span class="number">9</span>, &amp;coprocessor_segment_overrun);</span><br><span class="line">set_intr_gate(<span class="number">10</span>, &amp;invalid_TSS);</span><br><span class="line">set_intr_gate(<span class="number">11</span>, &amp;segment_not_present);</span><br><span class="line">set_intr_gate_ist(<span class="number">12</span>, &amp;stack_segment, STACKFAULT_STACK);</span><br><span class="line">set_intr_gate(<span class="number">13</span>, &amp;general_protection);</span><br><span class="line">set_intr_gate(<span class="number">15</span>, &amp;spurious_interrupt_bug);</span><br><span class="line">set_intr_gate(<span class="number">16</span>, &amp;coprocessor_error);</span><br><span class="line">set_intr_gate(<span class="number">17</span>, &amp;alignment_check);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">set_intr_gate_ist(<span class="number">18</span>, &amp;machine_check, MCE_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">set_intr_gate(<span class="number">19</span>, &amp;simd_coprocessor_error);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reserve all the builtin and the syscall vector: */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FIRST_EXTERNAL_VECTOR; i++)</span><br><span class="line">set_bit(i, used_vectors);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line">set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);</span><br><span class="line">set_bit(IA32_SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</span><br><span class="line">set_bit(SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Should be a barrier for any external CPU state:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cpu_init();</span><br><span class="line"></span><br><span class="line">x86_init.irqs.trap_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中进行了大量中断处理函数的设置，注意到其中有这么一句：<br><code>set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</code></p><p>而<code>SYSCALL_VECTOR</code>是多少呢？</p><p>其在<code>/arch/x86/include/asm/irq_vectors.h</code>中定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SYSCALL_VECTOR 0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>是熟悉的<code>0x80</code>，那么<code>system_call</code>，就是这个中断发生时候的处理函数咯。</p><p>我们再找找，看看这个函数具体内容。</p><h4><span id="system_call">system_call</span></h4><p>其在<code>/arch/x86/kernel/entry_32.S</code>中以汇编的形式定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(system_call)</span><br><span class="line">RING0_INT_FRAME# can&#39;t unwind into user space anyway</span><br><span class="line">pushl_cfi %eax# save orig_eax</span><br><span class="line">SAVE_ALL</span><br><span class="line">GET_THREAD_INFO(%ebp) # system call tracing in operation &#x2F; emulation</span><br><span class="line">testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)</span><br><span class="line">jnz syscall_trace_entry</span><br><span class="line">cmpl $(nr_syscalls), %eax</span><br><span class="line">jae syscall_badsys</span><br><span class="line">syscall_call:</span><br><span class="line">call *sys_call_table(,%eax,4)</span><br><span class="line">movl %eax,PT_EAX(%esp)# store the return value</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中<code>ENTRY</code>在<code>include/linux/linkage.h</code>中定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ENTRY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENTRY(name) \</span></span><br><span class="line">  .globl name; \</span><br><span class="line">  ALIGN; \</span><br><span class="line">  name:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在<code>system_call</code>中经过一系列处理，最终调用<br><code>call *sys_call_table(,%eax,4)</code><br>也就是说系统调用号保存在<code>%rax</code>中，并根据其值在系统调用表<code>sys_call_table</code>中进行查找，然后调用其值。</p><h4><span id="sys_call_table-32系统的初始化">sys_call_table 32系统的初始化</span></h4><p>32位系统的初始化比较直接，其在<code>arch/x86/kernel/syscall_table_32.S</code>直接定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line">.long sys_restart_syscall&#x2F;* 0 - old &quot;setup()&quot; system call, used for restarting *&#x2F;</span><br><span class="line">.long sys_exit</span><br><span class="line">.long ptregs_fork</span><br><span class="line">.long sys_read</span><br><span class="line">.long sys_write</span><br><span class="line">.long sys_open&#x2F;* 5 *&#x2F;</span><br><span class="line">.long sys_close</span><br><span class="line">.long sys_waitpid</span><br><span class="line">.long sys_creat</span><br></pre></td></tr></table></figure><h4><span id="sys_call_table-64系统的初始化">sys_call_table 64系统的初始化</span></h4><p>64位系统的初始化稍微复杂，其定义在<code>arch/x86/kernel/syscall_64.c</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* System call table for x86-64. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/linkage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cache.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/asm-offsets.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NO_STUBS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) extern asmlinkage void sym(void) ;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_64.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) [nr] = sym,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sys_call_ptr_t</span>)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sys_ni_syscall</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Smells like a like a compiler bug -- it doesn't work</span></span><br><span class="line"><span class="comment">*when the &amp; below is removed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line">#include &lt;<span class="keyword">asm</span>/unistd_64.h&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，<code>sys_call_table</code>是一个数组，其值为<code>typedef void (*sys_call_ptr_t)(void);</code>类型的函数指针。</p><p>在其中<code>#include &lt;asm/unistd_64.h&gt;</code>两次，有什么作用，又有什么区别呢？</p><p>直接看看<code>asm/unistd_64.h</code>文件内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file contains the system call numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: holes are not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* at least 8 syscall per cacheline */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read0</span></span><br><span class="line">__SYSCALL(__NR_read, sys_read)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write1</span></span><br><span class="line">__SYSCALL(__NR_write, sys_write)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open2</span></span><br><span class="line">__SYSCALL(__NR_open, sys_open)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close3</span></span><br><span class="line">__SYSCALL(__NR_close, sys_close)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat4</span></span><br><span class="line">__SYSCALL(__NR_stat, sys_newstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat5</span></span><br><span class="line">__SYSCALL(__NR_fstat, sys_newfstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat6</span></span><br><span class="line">__SYSCALL(__NR_lstat, sys_newlstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll7</span></span><br><span class="line">__SYSCALL(__NR_poll, sys_poll)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在其中定义了每个系统调用对应的调用号</p><p>那么再回头看看<code>arch/x86/kernel/syscall_64.c</code>文件内容，其首先对<code>__SYSCALL</code>进行重新定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) extern asmlinkage void sym(void) ;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_64.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样就可以对每个系统调用原型进行声明，其展开为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">extern</span> asmlinkage <span class="keyword">void</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> asmlinkage <span class="keyword">void</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>继续往下看，其对<code>__SYSCALL</code>又进行重定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) [nr] = sym,</span></span><br></pre></td></tr></table></figure><p>所以，<code>sys_call_table</code>展开为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Smells like a like a compiler bug -- it doesn't work</span></span><br><span class="line"><span class="comment">*when the &amp; below is removed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>] = sys_read,</span><br><span class="line">[<span class="number">1</span>] = sys_write,</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此，根据系统调用号，即可在<code>sys_call_table</code>中找到对应的系统调用函数。</p><h4><span id="终">终</span></h4><p>至此，<code>sys_call_table</code>中保存了系统调用的处理地址，执行<code>call *sys_call_table(,%rax,4)</code>即可转入对应系统调用函数进行真正处理。</p><p>精简流程为：<br><code>int 0x80</code>触发软中断<br>-&gt;<br>在中断向量表中查找处理函数，<code>system_call</code><br>-&gt;<br>根据<code>%rax</code>值(系统调用号)查找系统调用处理函数<br>-&gt;<br>执行系统调用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux系统调用流程分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux信号投递机制</title>
    <link href="http://www.xiaocc.xyz/2019-01-15/Linux%E4%BF%A1%E5%8F%B7%E6%8A%95%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.xiaocc.xyz/2019-01-15/Linux%E4%BF%A1%E5%8F%B7%E6%8A%95%E9%80%92%E6%9C%BA%E5%88%B6/</id>
    <published>2019-01-15T14:00:00.000Z</published>
    <updated>2019-01-15T15:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>分析Linux信号投递流程</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>最近在学习CMU的计算机系统课程，<code>CSAPP —— Computer Systems: A Programmer&#39;s Perspective</code>，这英文名估计很多人没听说，但是其书的中文名《深入理解计算机系统》，相信大家一定听过。</p><p>我学习的是<em>Fall 2018</em>版，<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f18/www/schedule.html" target="_blank" rel="noopener">课程schedule地址</a></p><p>在<code>ECF: Signals &amp; Nonlocal Jumps</code>这一章中提到：<br>如果进程有信号k处于<code>pending</code>状态，那么，其它投递到该进程的信号k，将被丢弃。</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190115-221302.jpg"></p><p>由于对这块只有个模糊的印象，所以怀着探索精神，决定深入源码一探究竟。</p><h4><span id="信号投递">信号投递</span></h4><p>不管是glibc的kill函数，还是linux的kill命令，最终都是调用得<code>kill</code>系统调用，且其函数名为<code>sys_kill</code>，只不过新版本的内核，从安全性角度考虑，用宏对其做了复杂包装。</p><p>一般定义为<code>SYSCALL_DEFINEx</code>，其中x为参数个数</p><p>就拿<code>kill</code>系统调用来说，其glibc函数原型为：</p><p><code>int kill(pid_t pid, int sig);</code></p><p>可知其参数个数为<code>2</code>，所以推断在内核中<code>kill</code>系统调用，其声明为<code>SYSCALL_DEFINE2(kill</code>得形式，很快就能定位到其所定义的文件<code>kernel/signal.c</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  sys_kill - send a signal to a process</span></span><br><span class="line"><span class="comment"> *  @pid: the PID of the process</span></span><br><span class="line"><span class="comment"> *  @sig: signal to be sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">info.si_signo = sig;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = SI_USER;</span><br><span class="line">info.si_pid = task_tgid_vnr(current);</span><br><span class="line">info.si_uid = current_uid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其将发送信号的<code>pid</code>、<code>uid</code>做了记录，然后转发调用<code>kill_something_info</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kill_something_info() interprets pid in interesting ways just like kill(2).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * POSIX specifies that kill(-1,sig) is unspecified, but what we have</span></span><br><span class="line"><span class="comment"> * is probably wrong.  Should make it like BSD or SYSV.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">ret = __kill_pgrp_info(sig, info,</span><br><span class="line">pid ? find_vpid(-pid) : task_pgrp(current));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_process(p) &#123;</span><br><span class="line"><span class="keyword">if</span> (task_pid_vnr(p) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">!same_thread_group(p, current)) &#123;</span><br><span class="line"><span class="keyword">int</span> err = group_send_sig_info(sig, info, p);</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">if</span> (err != -EPERM)</span><br><span class="line">retval = err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = count ? retval : -ESRCH;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里假定给特定进程发信号，所以<code>pid &gt; 0</code>，然后调用<code>kill_pid_info</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill_pid_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error = -ESRCH;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">retry:</span><br><span class="line">p = pid_task(pid, PIDTYPE_PID);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">error = group_send_sig_info(sig, info, p);</span><br><span class="line"><span class="keyword">if</span> (unlikely(error == -ESRCH))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The task was unhashed in between, try again.</span></span><br><span class="line"><span class="comment"> * If it is dead, pid_task() will return NULL,</span></span><br><span class="line"><span class="comment"> * if we race with de_thread() it will find the</span></span><br><span class="line"><span class="comment"> * new leader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其调用<code>group_send_sig_info</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * send signal info to all the members of a group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">group_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = check_kill_permission(sig, info, p);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line">ret = do_send_sig_info(sig, info, p, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其调用<code>do_send_sig_info</code>，并将第4个参数设置为<code>true</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> ret = -ESRCH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lock_task_sighand(p, &amp;flags)) &#123;</span><br><span class="line">ret = send_signal(sig, info, p, group);</span><br><span class="line">unlock_task_sighand(p, &amp;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，<code>group</code>参数为<code>true</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">send_signal</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *t,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> from_ancestor_ns = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PID_NS</span></span><br><span class="line">from_ancestor_ns = si_fromuser(info) &amp;&amp;</span><br><span class="line">   !task_pid_nr_ns(current, task_active_pid_ns(t));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __send_signal(sig, info, t, group, from_ancestor_ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="__send_signal">__send_signal</span></h4><p>关键函数来了，就是这货</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *t,</span><br><span class="line"><span class="keyword">int</span> group, <span class="keyword">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="keyword">int</span> override_rlimit;</span><br><span class="line"></span><br><span class="line">trace_signal_generate(sig, info, t);</span><br><span class="line"></span><br><span class="line">assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prepare_signal(sig, t, from_ancestor_ns))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Short-circuit ignored signals and support queuing</span></span><br><span class="line"><span class="comment"> * exactly one non-rt signal, so that we can get more</span></span><br><span class="line"><span class="comment"> * detailed information about the cause of the signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fast-pathed signals for kernel-internal things like SIGSTOP</span></span><br><span class="line"><span class="comment"> * or SIGKILL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (info == SEND_SIG_FORCED)</span><br><span class="line"><span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment"> * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment"> * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment"> * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment"> * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment"> * make sure at least one signal gets delivered and don't</span></span><br><span class="line"><span class="comment"> * pass on the info struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,</span><br><span class="line">override_rlimit);</span><br><span class="line"><span class="keyword">if</span> (q) &#123;</span><br><span class="line">list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_USER;</span><br><span class="line">q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">task_active_pid_ns(t));</span><br><span class="line">q-&gt;info.si_uid = current_uid();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line"><span class="keyword">if</span> (from_ancestor_ns)</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info)) &#123;</span><br><span class="line"><span class="keyword">if</span> (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue overflow, abort.  We may abort if the</span></span><br><span class="line"><span class="comment"> * signal was rt and sent by user using something</span></span><br><span class="line"><span class="comment"> * other than kill().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trace_signal_overflow_fail(sig, group, info);</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a silent loss of information.  We still</span></span><br><span class="line"><span class="comment"> * send the signal, but the *info bits are lost.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trace_signal_lose_info(sig, group, info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">signalfd_notify(t, sig);</span><br><span class="line">sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">complete_signal(sig, t, group);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>group</code>为<code>true</code>，所以</p><p><code>pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</code></p><p>选择将信号投递到进程的<code>shared_pending</code>中</p><p>接着往下看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">legacy_queue</span><span class="params">(struct sigpending *signals, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (sig &lt; SIGRTMIN) &amp;&amp; sigismember(&amp;signals-&gt;signal, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果<code>sig &lt; SIGRTMIN</code>，也就是常说的传统信号、非实时信号、非可靠信号。<br>并且，该进程已经投递过该信号<code>sigismember(&amp;signals-&gt;signal, sig)</code>，<br><code>legacy_queue</code>将返回<code>true</code>，这时，<code>__send_signal</code>将直接结束，不会再次投递该信号。</p><p>至此心中的谜团解开</p><p>而对于<code>sig &gt;= SIGRTMIN</code>，也就是常说的实时信号，会进行排队。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析Linux信号投递流程&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
