<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曾经浮华的小窝</title>
  
  <subtitle>hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaocc.xyz/"/>
  <updated>2018-06-10T05:36:24.113Z</updated>
  <id>http://www.xiaocc.xyz/</id>
  
  <author>
    <name>曾经浮华</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPU Cache与一致性</title>
    <link href="http://www.xiaocc.xyz/2018-06-10/cpu%E7%9A%84cache%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://www.xiaocc.xyz/2018-06-10/cpu的cache与一致性/</id>
    <published>2018-06-10T02:00:00.000Z</published>
    <updated>2018-06-10T05:36:24.113Z</updated>
    
    <content type="html"><![CDATA[<p>现代计算机多核CPU的多级缓存构成与一致性算法</p><a id="more"></a><p>最近看了CPU Cache相关的资料，涉及Cache的构成及一致性解决办法，现总结并记录</p><h4><span id="存储层次构成">存储层次构成</span></h4><p>由于CPU运行速度非常快，而主内存相对来说很慢，因此CPU并不直接访问主内存，两者之间有多次缓存结构。</p><p>存储层次，如下图：</p><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-101826.jpg" alt=""></p><p><em>图片来源：<a href="https://mp.weixin.qq.com/s/y1NSE5xdh8Nt5hlmK0E8Og" target="_blank" rel="noopener">内核月谈——CPU Cache Line伪共享问题的总结和分析</a></em></p><p>从上图可以看出，register与主memory访问速度相差约<strong>40倍</strong>，而磁盘访问一次耗时大约5ms，主memory与其访问速度相差约<strong>100倍</strong>。</p><h4><span id="cpu的cache架构">CPU的Cache架构</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-103044.jpg" alt=""></p><p><em>图片来源：<a href="https://mp.weixin.qq.com/s/y1NSE5xdh8Nt5hlmK0E8Og" target="_blank" rel="noopener">内核月谈——CPU Cache Line伪共享问题的总结和分析</a></em></p><p>如上图所示：<br>一个物理CPU有四个物理core，每个物理core有两个HT(Hyper Thread)<br>每个物理core内的所有HT，共享：L1-指令cache、L1-数据cache、L2-cache<br>所有物理core共享L3-cache</p><h4><span id="cache的一致性问题">Cache的一致性问题</span></h4><p>通过了解CPU的Cache架构可以发现，每个物理CPU都有自己的Cache，如何解决Cache的不一致问题。</p><h5><span id="不一致问题的产生">不一致问题的产生</span></h5><p>假设多核CPU在每个CPU内不单独设置Cache，而是所有物理CPU共享一个Cache，这样全部CPU的读写操作均串行通过同一个Cache。</p><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-104418.jpg" alt=""></p><p>这样，当其中一个CPU进行写操作，而另一个CPU进行读操作，总是能读到正确的值。<br>但是，所有CPU共享同一个Cache的设计，会极大的降低系统的运算速度，因为所有CPU均需要串行的访问Cache以获取数据，大部分时间均在等待Cache使用权。</p><p>如果引入多个Cache，就会涉及到Cache的一致性问题。<br>所以，Cache的一致性问题，不是因为多CPU导致，而是多Cache导致。</p><h5><span id="一致性协议">一致性协议</span></h5><p>参考WIKI关于Cache一致性的解释：<a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache_coherence</a><br>常用的一致性协议有 <code>snooping</code> 协议，也称为窥探协议。</p><p>该协议对总线上的操作进行监听，例如：一个CPU_A，对变量X进行了写操作，但是还未回写到memory，而另外一个CPU_B需要读取变量X，这时如果直接从memory获取变量X的值，是过期值，<br>这时CPU_A能够从总线上窥探到该次读操作，其把X值写入memory，而CPU_B的读操作由于未得到响应，其会重新发起读请求，这时就能从memory读取到最新值。</p><p>以上只是简单讲解，具体有 <code>MESI</code> 协议，其把Cache分为几个状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I: Invalid（无效），该CPU中该Cache字段失效</span><br><span class="line">S: Shared（共享），多个CPU的Cache均共享该数据</span><br><span class="line">E: Exclusive（独占），数据只在该CPU独有，其它CPU变为Invalid状态</span><br><span class="line">M: Modified（已修改），与E状态类似，但是数据已经被修改，在其变为Invalid状态时，需要先将数据回写到内存</span><br></pre></td></tr></table></figure><p>状态机如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-110431.jpg" alt=""></p><p><em>图片来源：<a href="http://www.pandan.xyz/2016/09/23/mesi%20%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">MESI 缓存一致性协议</a></em></p><p>参考文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/y1NSE5xdh8Nt5hlmK0E8Og" target="_blank" rel="noopener">CPU Cache Line伪共享问题的总结和分析</a></li><li><a href="http://www.pandan.xyz/2016/09/23/mesi%20%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">MESI 缓存一致性协议</a> </li><li><a href="http://www.infoq.com/cn/articles/cache-coherency-primer/" target="_blank" rel="noopener">缓存一致性（Cache Coherency）入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代计算机多核CPU的多级缓存构成与一致性算法&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>服务框架设计</title>
    <link href="http://www.xiaocc.xyz/2018-06-03/%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.xiaocc.xyz/2018-06-03/服务框架设计/</id>
    <published>2018-06-03T09:30:00.000Z</published>
    <updated>2018-06-03T12:27:03.602Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究raft论文，想动手实现一下，但是手上没有合适的网络框架，花了几天造了个轮子。</p><a id="more"></a><h4><span id="起因">起因</span></h4><p>raft论文去年看过一遍，最近重读，发现上次阅读的东西，一点都不记得。。。<br>决定这次跟着论文简单的实现一遍，加深理解，手上没有合适的网络框架，学go呢，又来不及，花了几天造了个轮子，总算是跑起来了。</p><p><strong>设计思想参考公司内部网络框架，将其部分精简</strong></p><h4><span id="框架设计">框架设计</span></h4><p>底层网络框架依托ZMQ，采用事件驱动形式，client与server端交互图如下：<br><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-174640.jpg" alt=""></p><h4><span id="worker_dispatcher">worker_dispatcher</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-175915.jpg" alt=""><br>以ZMQ_ROUTER的形式对接监听tcp端口，将client请求通过内部inproc的socket负载均衡的转发给worker进行处理<br>数据转发给worker时，将ZMQ_ROUTER的identity帧一并发送，这样待worker处理完毕，通过inproc的socket返回数据时，ZMQ_ROUTER能将数据返回给请求对应的client</p><h4><span id="worker">worker</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-181150.jpg" alt=""><br>创建ZMQ_DEALER的inproc的socket，并与worker_dispatcher连接，以此处理其转发过来的client的请求<br>当其要请求其它服务时，统一通过client_dispatcher对外处理</p><h4><span id="client_dispather">client_dispather</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-201920.jpg" alt=""><br>其通过inproc的socket接收worker中对其它服务的请求，并管理对外连接，释放长时间不使用的连接等<br>待下游服务返回数据，其通过inproc的socket返回给对应的worker</p><p><em>下次讲一下定时器的设计</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究raft论文，想动手实现一下，但是手上没有合适的网络框架，花了几天造了个轮子。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存检测工具AddressSanitizer</title>
    <link href="http://www.xiaocc.xyz/2018-05-28/AddressSanitizer/"/>
    <id>http://www.xiaocc.xyz/2018-05-28/AddressSanitizer/</id>
    <published>2018-05-28T11:30:00.000Z</published>
    <updated>2018-05-28T13:53:27.533Z</updated>
    
    <content type="html"><![CDATA[<p>Google出品的内存检测工具AddressSanitizer介绍与分析</p><a id="more"></a><h4><span id="介绍">介绍</span></h4><p>AddressSanitizer是Google旗下的一个内存问题检测工具，项目地址：<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizer</a></p><p>它与传统的内存问题检测工具，例如 <code>Valgrind</code> ，有何区别？</p><p>用过 <code>Valgrind</code> 的朋友应该都清楚，其会极大的降低程序运行速度，大约降低10倍，而 <code>AddressSanitizer</code> 大约只降低2倍，这是什么概念，果然是Google大法好！</p><h4><span id="具体使用">具体使用</span></h4><p>在LLVM及高版本编译器中已经自带了该工具，编译时添加 <code>-fsanitize=address</code> 选项。<br>正常运行程序，如有内存相关问题，即会打印异常信息。</p><h4><span id="工具原理">工具原理</span></h4><p>工具用法比较简单，这里想重点说说该工具的原理。</p><p>可参考文档：<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm</a></p><p>由于是内存检测工具，其需要对每一次内存读写操作进行检查：<br><code>*address = ...;  // or: ... = *address;</code></p><p>进行如下的逻辑判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsPoisoned(address)) &#123;</span><br><span class="line">  ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br><span class="line">*address = ...;  <span class="comment">// or: ... = *address;</span></span><br></pre></td></tr></table></figure><p>如果指针读写异常，则统计及打印异常信息，可见整个工具的关键在于 <code>IsPoisoned</code> 如何实现，该函数需要快速而且准确。</p><h4><span id="内存映射">内存映射</span></h4><p>其将内存分为两块：</p><ul><li>主内存：程序常规使用</li><li>影子内存：记录主内存是否可用等meta信息</li></ul><p>如果有个函数 <code>MemToShadow</code> 可以根据主内存地址获取到对应的影子内存地址，那么内存检测的实现，可以改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shadow_address = MemToShadow(address);</span><br><span class="line"><span class="keyword">if</span> (ShadowIsPoisoned(shadow_address)) &#123;</span><br><span class="line">  ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="影子内存">影子内存</span></h4><p><code>AddressSanitizer</code> 用 1 byte 的影子内存，记录主内存中 8 bytes 的数据。</p><p>为什么是 8 bytes ，因为malloc分配内存是按照 8 bytes 对齐。</p><p>这样，8 bytes 的主内存，共构成 9 种不同情况：</p><ul><li>8 bytes 的数据可读写，影子内存中的value值为 <strong>0</strong></li><li>8 bytes 的数据不可读写，影子内存中的value值为 <strong>负数</strong></li><li>前 k bytes 可读写，后 (8 - k) bytes 不可读写，影子内存中的value值为 <strong>k</strong> 。</li></ul><p>如果 <code>malloc(13)</code> ，根据 8 bytes 字节对齐的原则，需要 2 bytes 的影子内存，第一个byte的值为 0，第二个byte的值为 5。</p><p>这时，整个判断流程，可改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">byte *shadow_address = MemToShadow(address);</span><br><span class="line">byte shadow_value = *shadow_address;</span><br><span class="line"><span class="keyword">if</span> (shadow_value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (SlowPathCheck(shadow_value, address, kAccessSize)) &#123;</span><br><span class="line">    ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the cases where we access first k bytes of the qword</span></span><br><span class="line"><span class="comment">// and these k bytes are unpoisoned.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SlowPathCheck</span><span class="params">(shadow_value, address, kAccessSize)</span> </span>&#123;</span><br><span class="line">  last_accessed_byte = (address &amp; <span class="number">7</span>) + kAccessSize - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (last_accessed_byte &gt;= shadow_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="主内存映射到影子内存">主内存映射到影子内存</span></h4><p><code>MemToShadow</code> 采用简单直接映射的方式<br>64-bit <code>Shadow = (Mem &gt;&gt; 3) + 0x7fff8000;</code><br>32-bit <code>Shadow = (Mem &gt;&gt; 3) + 0x20000000;</code></p><h4><span id="例子">例子</span></h4><p>如何检测数组访问越界：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">8</span>];</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddressSanitizer</code> 将其改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> redzone1[<span class="number">32</span>];  <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">8</span>];          <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">char</span> redzone2[<span class="number">24</span>];</span><br><span class="line">  <span class="keyword">char</span> redzone3[<span class="number">32</span>];  <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">int</span>  *shadow_base = MemToShadow(redzone1);</span><br><span class="line">  shadow_base[<span class="number">0</span>] = <span class="number">0xffffffff</span>;  <span class="comment">// poison redzone1</span></span><br><span class="line">  shadow_base[<span class="number">1</span>] = <span class="number">0xffffff00</span>;  <span class="comment">// poison redzone2, unpoison 'a'</span></span><br><span class="line">  shadow_base[<span class="number">2</span>] = <span class="number">0xffffffff</span>;  <span class="comment">// poison redzone3</span></span><br><span class="line">  ...</span><br><span class="line">  shadow_base[<span class="number">0</span>] = shadow_base[<span class="number">1</span>] = shadow_base[<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// unpoison all</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/20180528214308.png" alt=""><br>将 <code>char a[8]</code> 两侧用 <code>redzone</code> 包夹，这样数组访问越界时，立马能够侦测。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google出品的内存检测工具AddressSanitizer介绍与分析&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hbase schema design阅读笔记</title>
    <link href="http://www.xiaocc.xyz/2018-05-28/hbase_schema_design/"/>
    <id>http://www.xiaocc.xyz/2018-05-28/hbase_schema_design/</id>
    <published>2018-05-28T09:00:00.000Z</published>
    <updated>2018-05-28T09:10:45.054Z</updated>
    
    <content type="html"><![CDATA[<p>图床终于弄好，可以图文结合了<br>上传一篇以前的阅读笔记，关于hbase的rowkey设计的<br><a id="more"></a></p><p>hbase schema design <a href="http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf" target="_blank" rel="noopener">文章pdf地址</a></p><h5><span id="hbase-存储视图">hbase 存储视图</span></h5><p><img src="http://p9ffylu89.bkt.clouddn.com/6397885A-85FF-4D6D-AB04-E2D0BA46045A.png" alt=""></p><p><strong>文中，以Twitter关注模式为例，讲解存储设计</strong></p><h5><span id="场景分析">场景分析</span></h5><p>首先分析问题，读、写场景有哪些？</p><p><strong>读：</strong></p><ol><li>用户A关注了哪些用户？</li><li>检查用户A是否关注用户B</li><li>哪些用户关注了用户A？</li></ol><p><strong>写：</strong></p><ol><li>用户A关注用户B</li><li>用户A取消关注用户B</li></ol><p>循序渐进的讲解存储设计：</p><p>1.简单的列表存储，用下标做column qualifie，用户名做value，但是读2问题，需要遍历列表解决。同时，新增关注时，不知道下一个下标数值，需要遍历获取。<br><img src="http://p9ffylu89.bkt.clouddn.com/A1223DE1-8F32-46A8-B5B5-464BD723F202.png" alt=""></p><p>2.针对设计1的问题，增加一个额外的column（count），记录当前关注用户数量，但是HBase多API之间的并发问题不容易解决。同时写2问题，用户取消关注B，需要遍历整个列表来delete，同时删除之后的空洞问题无法解决（count数量与下一个下标值无法对应）<br><img src="http://p9ffylu89.bkt.clouddn.com/0D529E1B-23ED-4450-BE1C-6B2D45F1FF27.png" alt=""></p><p>3.针对HBase的column是可变的，非预定义的，同时是bytes []的，所以可以把关注的用户名B作为column qualifier。<br><img src="http://p9ffylu89.bkt.clouddn.com/7DFEF1A3-4124-4681-B3C3-DC858C7DD1EE.png" alt=""></p><p>这个设计可以很方便的查找用户AK关注了哪些用户，但是针对于哪些用户关注了AK，只能遍历整个table来查找。</p><p>4.针对HBase的rowkey是bytes []，同时是有序的、且方便scan，可以存储一些信息在rowkey中。<br><img src="http://p9ffylu89.bkt.clouddn.com/AEB8F7E0-7711-447C-9E70-7FB4691F9A0E.png" alt=""><br><img src="http://p9ffylu89.bkt.clouddn.com/0A2ED8B4-E54A-4E7E-845A-78DA718B84A2.png" alt=""></p><p>将rowkey设计为 follower + followed形式</p><p>如何查找AK关注了哪些用户——通过扫描HBase的rowkey符合 AK* 模式</p><p>如何查找哪些用户关注了AK——通过扫描HBase的rowkey符合 *AK 模式</p><p>5.如何解决用户名长度不一致问题，可以选择归一化用户名或者采用保存md5的形式<br><img src="http://p9ffylu89.bkt.clouddn.com/CE8EFA5B-299D-43F9-8EBF-E73D4B79AA6B.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图床终于弄好，可以图文结合了&lt;br&gt;上传一篇以前的阅读笔记，关于hbase的rowkey设计的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>极低概率bug排查</title>
    <link href="http://www.xiaocc.xyz/2018-05-26/%E6%9E%81%E4%BD%8E%E6%A6%82%E7%8E%87bug%E6%8E%92%E6%9F%A5/"/>
    <id>http://www.xiaocc.xyz/2018-05-26/极低概率bug排查/</id>
    <published>2018-05-26T10:00:00.000Z</published>
    <updated>2018-05-26T12:05:47.351Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个bug，需要运行百万次才触发一次，该如何排查这个问题？</p><a id="more"></a><h4><span id="起因">起因</span></h4><p>前几天在内部论坛看到一篇技术贴，关于一个极低概率触发的bug，如何分析与排查。</p><p>借此机会，写一下阅读心得。</p><p>知乎上有一个段子，说是一个面试官出了道题，如果一个bug运行百万次才能触发一次，该如何排查？<br>面试者当场懵逼，很多人讨伐面试官，说这个题目就是故意为难人，考察不到实质内容。</p><p>其实这个问题，挺有意思，可以考察被面试者，在碰到不熟悉的领域以及高困难环境下的分析与应对情况。</p><h4><span id="现象">现象</span></h4><p>文中，作者做https的通用接入平台，每天数百亿次的请求，需要高性能，因而对nginx的底层代码更改很多，特别是握手那块逻辑。<br>自测没问题，线上小流量测试，总是跑个一天左右，会出现进程core的情况。</p><p>如何解决这个棘手的问题？</p><h4><span id="core文件">core文件</span></h4><p>要解决一个bug，最好能够拿到bug触发后的现场，也就是coredump文件，这是进程挂掉最后的遗言。</p><p>也有高手，通过逐行看代码来进行排查，但是面对代码量几十万行的项目，犹如大海捞针。</p><p>开启系统core文件生成后，看看能不能从core文件中有所发现。</p><p>由于nginx的网络框架，数据read后，可能走两个不同的分支逻辑，例如第一次接收数据后，请求包不完整，调用函数A，第二次接收数据后，整个请求包完整，调用函数B，这个时候core文件产生，函数调用栈中只能看到函数B，没有函数A的相关信息，而问题可能是函数A导致，所以整个coredump文件分析下来，没有直接发现问题。</p><p>只是有一个点比较极怪，有一个不可能为空的指针，居然出现为空的情况，这个指针是会话创建之初构建的。</p><h4><span id="复现bug">复现bug</span></h4><p>要排查一个bug，如果能够将bug复现，甚至于必现，那将极大的加快排查速度，可以对关键路径添加日志，然后测试新代码。</p><p>可是一个极低概率触发的bug，如何复现？</p><p>可以自己构造请求以复现，作者特地开发压测工具，以几万/秒的请求量进行压测，晚上开启压测工具，第二天上午就可以收到core文件。</p><h4><span id="排查bug">排查bug</span></h4><p>虽然有了复现bug的方法，也有了core文件，可是从core文件中并不能分析出来有价值的信息。</p><p>那只能通过修改代码，添加日志的方式来进行排查。</p><p>通过添加日志来进行排查，就有讲究了。</p><p>如果日志过多过细，将导致服务性能上不来，原本服务性能几万/秒，可能降低到几百/秒，而且由于日志过多，降低了并发性能，bug可能借此被掩盖而不触发。</p><p>如果日志过少，没有一次请求的全路径信息，不能分析出bug具体出现在哪个点。</p><p>面对这个两难的选择，如何解决？</p><p>作者针对日志系统做了改进，增加日志的粒度，由于bug是低概率触发，绝大部分请求的处理逻辑都是正常的，日志打出来也没用，最好日志系统能抓到那次有问题的请求。<br>作者针对于海量请求，随机触发该次请求的全路径详细日志打印，这样既不会过于降低性能，也不会丢失全路径的详细信息。</p><p>接下来，就是将改进后的代码上线，用工具进行压测，然后，等。。。</p><p>撞大运的事情，终究还是没有发生。。。</p><p>但是，整个日志改造的过程中，作者对于项目代码愈发熟练，对于请求的整个处理流程犹如刻在脑海。</p><h4><span id="分析bug">分析bug</span></h4><p>作者通过与同事讨论交流，分析bug的触发时间点，均在凌晨4-6点，而白天正常，一次core也未发生，这比较奇怪。</p><p>突然灵机一动，联想到凌晨网络运营商会进行维护，可能产生大量异常请求包，是不是这个原因导致的bug发生。</p><p>作者对压测工具进行改造，故意构造一些异常请求，例如tcp三次握手，发了sync包后，就直接将连接close，请求包不完整等等case。</p><p>功夫不负有心人，新版压测工具上线后，不出一个小时就能复现bug，结合网络异常这个点，将代码相关逻辑检查、添加日志，很快就分析出了bug具体原因，session复用机制导致的问题。</p><h4><span id="总结">总结</span></h4><p>这篇文章给出了排查极低概率bug的套路：</p><ul><li>复现bug，可以考虑构造压测工具</li><li>分析bug，可以通过core文件或者在可疑点添加日志</li><li>与同事交流、讨论、思考，分析bug可能触发的原因与场景</li><li>针对性修改压测工具、添加关键点日志</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个bug，需要运行百万次才触发一次，该如何排查这个问题？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于PayPal支付接入的思考——通知校验机制</title>
    <link href="http://www.xiaocc.xyz/2018-05-15/%E5%85%B3%E4%BA%8EPayPal%E9%80%9A%E7%9F%A5%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://www.xiaocc.xyz/2018-05-15/关于PayPal通知校验的思考/</id>
    <published>2018-05-15T11:30:00.000Z</published>
    <updated>2018-05-15T13:10:42.826Z</updated>
    
    <content type="html"><![CDATA[<p>PayPal支付中通知校验机制的思考<br><a id="more"></a></p><h4><span id="校验机制介绍">校验机制介绍</span></h4><p>PayPal支付流程中，待用户支付完毕后，会以WebHook的形式异步通知商户。</p><p>所谓的异步通知，其实就是以Post的形式调用商户提前在PayPal网站注册的一个URL。</p><p>可见，该URL任何第三方亦可调用，以伪装成支付成功，所以商户接收到Notification的时候，需要<strong>校验</strong>其是否PayPal下发。</p><p>PayPal开发者文档中提供了一个API用以校验Notification的真实性。<br>文档地址：<a href="https://developer.paypal.com/docs/api/webhooks/#verify-webhook-signature" target="_blank" rel="noopener">https://developer.paypal.com/docs/api/webhooks/#verify-webhook-signature</a><br>校验流程为，将接收到的相关信息以Post形式请求PayPal校验接口，其会返回：SUCCESS、FAILURE</p><p>Post的数据格式为Json，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;transmission_id&quot;: &quot;69cd13f0-d67a-11e5-baa3-778b53f4ae55&quot;,</span><br><span class="line">  &quot;transmission_time&quot;: &quot;2016-02-18T20:01:35Z&quot;,</span><br><span class="line">  &quot;cert_url&quot;: &quot;cert_url&quot;,</span><br><span class="line">  &quot;auth_algo&quot;: &quot;SHA256withRSA&quot;,</span><br><span class="line">  &quot;transmission_sig&quot;: &quot;xxxx&quot;,</span><br><span class="line">  &quot;webhook_id&quot;: &quot;1JE4291016473214C&quot;,</span><br><span class="line">  &quot;webhook_event&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>webhook_event</code> 字段的Value为<strong>Object</strong>，其它字段的Value均为<strong>String</strong>。</p><p>按照API文档使用curl工具自测，返回 <code>FAILURE</code><br>使用Postman工具测试，亦返回 <code>FAILURE</code><br>翻看文档，尝试各种解决方案，无果，只能求助万能的google。</p><p>还真有人反馈这个问题：<a href="https://github.com/paypal/PayPal-Python-SDK/issues/175" target="_blank" rel="noopener">https://github.com/paypal/PayPal-Python-SDK/issues/175</a>，其中一个解答者为PayPal官方开发者。<br>经过尝试，发现调整 <code>webhook_event</code> 这个Object中某些key的顺序就可以顺利通过检查。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;webhook_event&quot;:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:&quot;WH-64U11527U2666304T-3BK004431V7313539&quot;,</span><br><span class="line">    &quot;event_version&quot;:&quot;1.0&quot;,</span><br><span class="line">    &quot;create_time&quot;:&quot;2016-12-07T09:10:39Z&quot;, </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API校验<strong>失败</strong></p><p>然而，调整 <code>create_time</code> 与 <code>event_version</code> 的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;webhook_event&quot;:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:&quot;WH-64U11527U2666304T-3BK004431V7313539&quot;,</span><br><span class="line">    &quot;create_time&quot;:&quot;2016-12-07T09:10:39Z&quot;, </span><br><span class="line">    &quot;event_version&quot;:&quot;1.0&quot;,</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API却校验<strong>成功</strong></p><p>通过curl工具，我能方便的调整Post给PayPal的数据中字段的顺序，可是在代码中实测的时候，我却无法做到！</p><p><strong>为什么？</strong></p><p>因为通过Http接口Post给PayPal的数据本质上是一个 <code>String</code>，只不过在Http头中指定数据格式为Json，<code>Content-type: application/json</code>。<br>这个String肯定是通过调用Json对象的序列化函数得来，我没有办法去改变序列化函数的实现，从而调整序列化成String后Key的顺序。</p><h4><span id="校验机制的问题">校验机制的问题</span></h4><p><strong>为什么会导致校验失败？</strong></p><p>这得从 <code>webhook_event</code> 这个字段所需的值说起。<br>这个字段的值，实际上就是PayPal支付成功后通知商户的Notification的值。</p><p>我们复盘一下整个流程：</p><div id="sequence-0"></div><p>可见，最初PayPal传递给商户的数据<strong>nf_string</strong>，经过反序列化、再序列化之后得到的数据<strong>nf_string’</strong>，两者并不是byte尺度一致。</p><p><strong>商户的Json库序列化实现与PayPal侧的实现无法保证一致</strong></p><p>这就导致PayPal侧，在接收商户校验Notification请求时候，直接以序列化后新的String计算signature值产生偏差。</p><p>也可能，Notification生成服务与校验服务，Json相关序列化函数实现不一致，导致将Json对象转换为 <code>String</code> 后，计算signature两者不一致，从而导致校验失败。</p><h4><span id="思考">思考</span></h4><p>要解决该问题，有几种方式：</p><ul><li><p>PayPal侧保证数据顺序的一致性，在接收到商户发送来的校验请求数据 <code>post_data</code> 后，先反序列化成Json对象，取出 <code>webhook_event</code> 对象，再将其调用序列化函数转换成String，这样就能保证与最初下发给商户的 <code>nf_string</code> 在byte尺度一致，<strong>因为两个String都是在PayPal侧完成序列化</strong>。<br>  不管商户侧对这个 <code>nf_string</code> 如何调整key的顺序，最终校验签名需要的String，都是在PayPal侧序列化生成，能够保证其与最初下发给商户时的 <code>nf_string</code> 一致。</p></li><li><p><strong>回顾整个流程，症结在于商户序列化的实现</strong>，影响了PayPal侧对于签名的计算，所以可以修改API，将 <code>webhook_event</code> 字段的Value修改为<strong>String</strong>。<br>  这样，商户只需要将PayPal最初下发的 <code>nf_string</code> 填入即可，PayPal从商户post_data中取到的 <code>webhook_event</code> 值，即与最初异步通知下发时候一致。</p></li></ul><p>由于多平台、多语言的存在，对于需要byte级别一致的数据，不应该对客户的环境做任何假设，相关字段最好以 <code>String</code> 形式传递。</p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">PayPal->商户: post形式通知支付结果，nf_string商户-->商户: 根据nf_string反序列化成json对象，nf_object商户-->商户: 构造需要校验的Json对象，post_body商户-->商户: 将Json对象序列化成String，post_data商户->PayPal: 以http的形式将post_data发送</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PayPal支付中通知校验机制的思考&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于PayPal支付接入的思考——唯一ID的生成</title>
    <link href="http://www.xiaocc.xyz/2018-05-12/%E5%85%B3%E4%BA%8EPayPal%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://www.xiaocc.xyz/2018-05-12/关于PayPal支付接入的思考/</id>
    <published>2018-05-12T09:00:00.000Z</published>
    <updated>2018-05-15T12:57:05.349Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中需要接入PayPal支付，由此引发了关于唯一ID生成、签名校验机制的一些思考</p><a id="more"></a><h4><span id="系统框架">系统框架</span></h4><p>主要流程：<br>在页面引入PayPal支付购买物品，系统生成CDKey，用户拿着CDKey可以兑换物品。</p><p>框架如下：</p><div id="sequence-0"></div><p>其中，<strong>接入服务</strong>主要负责接入并与外围其它服务交互，而<strong>CDKey服务</strong>主要负责CDKey的维护，包括生成、校验、使用等。</p><h4><span id="paypal支付流程">PayPal支付流程</span></h4><p>既然是接入PayPay支付，阅读其说明文档就能理清整个交互流程，如下：</p><div id="sequence-1"></div><h5><span id="流程解释">流程解释</span></h5><ol><li>用户在web页面点击购买物品，server端做相关检查后，调用paypal接口进行<strong>订单创建</strong></li><li>paypal订单创建接口需要填入<strong>return_url与cancel_url</strong>，这两个字段的含义稍后解释。订单创建成功后，paypal会返回一个<strong>redirect_url</strong>，这个url页面是paypal的，<strong>server端需要让用户web页面重定向至该url</strong>。</li><li>用户web页面被重定向至redirect_url后，需要输入paypal账号、密码进行登录，<strong>如果确认支付</strong>，paypal会让页面跳转至return_url，<strong>如果用户取消支付</strong>，paypal会让页面跳转至cancel_url。</li><li>如果用户确认支付，paypal让用户web页面跳转至return_url的同时，会附带payment_id、user_id，server端需要拿着这些参数<strong>execute订单</strong>。</li><li>等待一小段时间，paypal会以异步通知的形式，通知server端支付结果信息</li><li>server端需要<strong>检查该notify信息是否真的paypal下发</strong>，并检查订单当前支付状态</li></ol><p><strong>注意：检查notify信息是否paypal下发，非常重要！</strong><br><strong>异步通知只是一个web接口的调用，任何第三方都可以调用该接口，以伪装支付成功！</strong></p><p>整个系统分为两个模块，一个模块负责与paypal交互，一个模块负责CDKey相关。</p><h4><span id="cdkey的生成">CDKey的生成</span></h4><p>CDKey本质上是一个唯一ID，且不是单纯的数字id，可以是大小写字母、数字组合。<br>知乎上有关于短链生成算法的讨论，可以借鉴其思想。</p><p>生成方式主要有几种：</p><ol><li><p>通过随机算法生成一个随机数，这个数要尽可能分散，如何解决<strong>碰撞问题</strong>是个难题，可以碰撞后再次尝试生成，但无法根本解决碰撞问题。<br>常用的实现可以对字符串进行hash，其中字符串可以是网站原始url或者自己构造的代表该次请求的唯一串。<br>hash函数要求散列性高，可以使用 <a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">MurmurHash</a>。</p></li><li><p>通过redis或者mysql产生自增id来当做唯一ID，该方式可以解决碰撞问题，但是该方式生成的唯一ID具有<strong>规律性</strong>。<br>而在我们这个使用场景中，用它来当做CDKey不满足要求，因为我们这个系统中CDKey是不记名式的。<br>如果用户知道CDKey=100可用，那么他会拿101这个新的CDKey尝试兑换，这样他就兑换走了其它用户购买的物品，因而不能采用该方式。</p></li><li><p>方式1 + 方式2<br>唯一ID分为两部分，<strong>hash部分 + 自增部分</strong>，其中自增部分保证唯一性，而hash部分解决单纯自增的规律性问题。<br>或者采用<strong>signature(自增id) + 自增id</strong>的方式，签名部分可以解决规律性问题、同时可以用来校验整个id的合法性。</p></li></ol><h4><span id="防刷-盗刷问题">防刷、盗刷问题</span></h4><p>由于物品兑换的唯一依据是不记名的CDKey，如何做防刷、盗刷？</p><ol><li><p>能不能单纯依靠增加CDKey的长度来解决盗刷问题<br>理论上不行，实际可行<br>假设CDKey长度6个字符，每个字符由大小写字母、数字构成，共计62种变化，6个字符约500亿种变化。按照100qps的速度扫描，需要18年才能扫完整个空间，CDKey长度每增加1个字符，扫描难度增大62倍。如果CDKey长度由6个字符，增加到12个字符，破解难度可想而知。</p></li><li><p>能不能通过限制每个ip的访问频率，来控制扫描破解CDKey的速度<br>不行<br>假设黑客控制了100台肉鸡，每台100qps的扫描速度，CDKey长度6个字符，那么他只需要65天，就能扫完整个CDKey空间，如果他控制了10000台呢，那就更快扫完了。</p></li><li><p>能不能对服务端的处理速度做限制，例如：每秒只处理10个请求<br>不行<br>这样虽然控制了黑客的扫描速度，但是也阻挡了正常用户的请求，降低了系统吞吐量</p></li><li><p>能不能针对CDKey做一些检测或者限制<br>不行<br>黑客每次扫描的CDKey都不相同，无规律性</p></li><li><p>那有什么好的解决办法呢？<br>可以考虑给CDKey增加Secret</p><ul><li>添加Secret，相当于增加了CDKey的长度，增加了黑客扫描破解的难度，他必须先猜中CDKey，再猜中Secret才能非法获取</li><li>可以对针对CDKey做一些安全性控制，如果CDKey的密码输入错误3次，冻结该ip及CDKey一段时间，这样可以极大的降低黑客扫描的速度，扫描破解，命中CDKey后，尝试扫描破解Secret密码，只要错误几次，该肉鸡的ip即被冻结，同时该CDKey也暂不可用，阻止黑客采用其它ip继续破解Secret。</li></ul></li></ol><p><em>关于PayPal中Notify的校验问题，下次讨论</em></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">User->接入服务: 购买接入服务->CDKey服务: 请求生成CDKeyNote right of CDKey服务: 根据算法生成CDKeyCDKey服务-->接入服务: CDKey接入服务-->User: CDKeyUser->接入服务: 用CDKey兑换物品接入服务->CDKey服务: 校验CDKeyCDKey服务-->接入服务: yes or no接入服务-->User: 物品</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">user->server: web页面点击购买物品server->paypal: 创建订单(填写return_url、cancel_url)paypal->server: 订单创建成功，返回redirect_urlserver->user: 让web页面302跳转到redirect_urluser->user: 输入paypal账号、密码登录user->user: 确认支付paypal-->user: 页面跳转至return_url并附加相关参数user->server: 将附加参数传递给server端server->paypal: execute订单paypal-->server: 异步notify订单支付信息server-->paypal: 校验notify信息server-->paypal: 检查订单支付状态</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作中需要接入PayPal支付，由此引发了关于唯一ID生成、签名校验机制的一些思考&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用C++安全的发送邮件</title>
    <link href="http://www.xiaocc.xyz/2018-05-10/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B62/"/>
    <id>http://www.xiaocc.xyz/2018-05-10/发送邮件2/</id>
    <published>2018-05-10T15:00:00.000Z</published>
    <updated>2018-05-11T13:06:43.031Z</updated>
    
    <content type="html"><![CDATA[<p>前文提到，使用SMTP协议发送邮件不安全，本文将解释具体原因与应对措施</p><a id="more"></a><p>要解释SMTP协议的不安全问题，得先说说http协议</p><h4><span id="http协议">HTTP协议</span></h4><p>具体解释可以参考wiki <a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTP协议</a></p><blockquote><p>它是一种用于分布式、协作式和超媒体信息系统的应用层协议<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p></blockquote><p>http交互内容是明文传输，例如获取google首页的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.google.com</span><br></pre></td></tr></table></figure><p>服务器返回内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 3059</span><br><span class="line">Server: GWS/2.0</span><br><span class="line">Date: Sat, 11 Jan 2003 02:44:04 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Cache-control: private</span><br><span class="line">Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy</span><br><span class="line">X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>这样有什么安全问题呢？整个交互内容除了Client和Server端，没有第三个人知道。<br>你可能有这样的疑问，其实不对，我们在网络上发送消息，并不是直接传递到Server端，中间会经过很多节点的转发，这样就存在干坏事的时机。</p><div id="sequence-0"></div><p>经常上网的你会碰到，有时候打开网页，莫名其妙的多了广告，而且有些是非常著名的网站，这些网站不会自主添加广告。</p><p><strong>那这些广告是哪里来的呢？</strong></p><p>其实是网络运营商对服务端返回的数据进行解析与篡改，由于整个交互内容是明文，很容易知道数据格式，就可以在返回数据中添加自己的广告，然后返回给用户。利用这个原理也可以做一些别的事情，例如：针对非法网页的打击。</p><div id="sequence-1"></div><p>这就是常说的 <code>中间人劫持</code>。</p><h4><span id="https">HTTPS</span></h4><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki解释</a></p><blockquote><p>超文本传输安全协议，是一种通过计算机网络进行安全通信的传输协议<br>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p></blockquote><h5><span id="与http的差异">与HTTP的差异</span></h5><blockquote><p>与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443<br>HTTP协议和安全协议同属于应用层（OSI模型的最高层），具体来讲，安全协议工作在HTTP之下，运输层之上：安全协议向运行HTTP的进程提供一个类似于TCP的套接字，供进程向其中注入报文，安全协议将报文加密并注入运输层套接字；或是从运输层获取加密报文，解密后交给对应的进程。<br>严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。<br><strong>HTTPS报文中的任何东西都被加密，包括所有报头和荷载</strong>。<br>除了可能的选择密文攻击之外，一个攻击者所能知道的只有在两者之间有一连接这一事实。</p></blockquote><p><strong>由此可见，https能够实现网页信息的安全传输</strong></p><h4><span id="smtps">SMTPS</span></h4><p>http协议有对应的安全版本https，其实，smtp协议也有对应的安全版本smtps。<br>smtps协议的 <a href="https://en.wikipedia.org/wiki/SMTPS" target="_blank" rel="noopener">wiki解释</a><br>与https协议类似，smtps协议也是通过 SSL/TLS 在传输层上通过对信息加密来保证安全性</p><h4><span id="实际例子">实际例子</span></h4><p>libcurl中有一个smtp + ssl的例子：<a href="https://curl.haxx.se/libcurl/c/smtp-ssl.html" target="_blank" rel="noopener">code</a></p><p><em>我想知道，还有什么功能是libcurl不能实现的。。。</em></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Client->Node1: dataNode1-->Node2: dataNode2-->Node3: dataNode3-->NodeN: dataNodeN->Server: data</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">Server->Node1: dataNode1->Node2: dataNode2-->NodeN: data->data'NodeN->Client: data'</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文提到，使用SMTP协议发送邮件不安全，本文将解释具体原因与应对措施&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用C++发送邮件</title>
    <link href="http://www.xiaocc.xyz/2018-05-07/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B61/"/>
    <id>http://www.xiaocc.xyz/2018-05-07/发送邮件1/</id>
    <published>2018-05-07T14:15:00.000Z</published>
    <updated>2018-05-11T13:07:09.255Z</updated>
    
    <content type="html"><![CDATA[<p>工作中需要发送邮件，本来用python几行代码就可以搞定的事情，可是为了与整个项目框架匹配，以利于监控和维护，只能采用C++形式了</p><a id="more"></a><p>C++发送邮件采用 <code>SMTP</code> 协议，具体原理可以参见 <a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki解释</a></p><h4><span id="操作流程">操作流程</span></h4><p>假设发送者邮箱为：<a href="mailto:ww@sina.com" target="_blank" rel="noopener">ww@sina.com</a>，注意：需要在设置中启用smtp选项<br>接收者邮箱为：<a href="mailto:yy@qq.com" target="_blank" rel="noopener">yy@qq.com</a></p><div id="sequence-0"></div><p>其中发送内容content为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From: ww@sina.com</span><br><span class="line">TO: yy@qq.com</span><br><span class="line">Subject: test</span><br><span class="line"></span><br><span class="line">hello，this is a test</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p><strong>其中邮件正文以：\r\n.\r\n 结束</strong></p><h4><span id="代码实现">代码实现</span></h4><p>根据这个流程就可以编写C++代码，没什么难度，注意：每次往server端发送命令，以 <code>\r\n</code> 结尾</p><p>发送邮件代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMTP_LOG(n) \</span></span><br><span class="line"><span class="keyword">if</span> (recv_len &gt;= <span class="number">0</span>)\</span><br><span class="line">&#123;\</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"step "</span> <span class="meta">#n <span class="meta-string">" recv data, ret:"</span> &lt;&lt; recv_len &lt;&lt; <span class="meta-string">", value:"</span> &lt;&lt; std::string(buff, recv_len) &lt;&lt; endl; \</span></span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">else</span>\</span><br><span class="line">&#123;\</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"step "</span> #n <span class="string">" recv data error, ret:"</span> &lt;&lt; recv_len &lt;&lt; <span class="built_in">endl</span>; \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendEmail</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user_account, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user_passwd, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; dest_account, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> smtp_url;</span><br><span class="line">    <span class="keyword">int</span> smtp_port = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取smtp服务器地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos = user_account.find(<span class="string">'@'</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        smtp_url = <span class="string">"smtp."</span> + user_account.substr(pos + <span class="number">1</span>);</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"smtp_url:"</span> &lt;&lt; smtp_url &lt;&lt; <span class="string">", port:"</span> &lt;&lt; smtp_port &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"get smtp_url error, user_account:"</span> &lt;&lt; user_account &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = ::socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    hostent* he = ::gethostbyname(smtp_url.c_str());</span><br><span class="line">    <span class="keyword">if</span> (he == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"get host error, smtp_url:"</span> &lt;&lt; smtp_url &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;addr.sin_addr, he-&gt;h_addr_list[<span class="number">0</span>], he-&gt;h_length);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(smtp_port);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (::connect(sock, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"connect error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    timeout.tv_sec = <span class="number">2</span>;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsockopt (sock, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *)&amp;timeout,</span><br><span class="line">                <span class="keyword">sizeof</span>(timeout)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"set recv timeout error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsockopt (sock, SOL_SOCKET, SO_SNDTIMEO, (<span class="keyword">char</span> *)&amp;timeout,</span><br><span class="line">                <span class="keyword">sizeof</span>(timeout)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"set send timeout error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(buff);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//step 1: connect</span></span><br><span class="line">    <span class="keyword">int</span> recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 2: EHLO</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">send</span><span class="params">(<span class="string">"EHLO "</span>)</span></span>;</span><br><span class="line">    send += smtp_url;</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">    recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 3: AUTH LOGIN</span></span><br><span class="line">    send = <span class="string">"AUTH LOGIN\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">    recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 4: account_name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> account_name;</span><br><span class="line">    pos = user_account.find(<span class="string">"@"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        account_name = user_account.substr(<span class="number">0</span>, pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send = TC_Base64::encode(account_name);</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">    recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//step 5: account_pwd</span></span><br><span class="line">    send = TC_Base64::encode(user_passwd);</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">    recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">string</span>(buff, recv_len).find(<span class="string">"235"</span>) == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"account password error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 6: MAIL FROM</span></span><br><span class="line">    send = <span class="string">"MAIL FROM: "</span>;</span><br><span class="line">    send += <span class="string">"&lt;"</span> + user_account + <span class="string">"&gt;"</span>;</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">    recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 7: RCPT TO</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != dest_account.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        send = <span class="string">"RCPT TO: "</span>;</span><br><span class="line">        send += <span class="string">"&lt;"</span> + dest_account[i] + <span class="string">"&gt;"</span>;</span><br><span class="line">        send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">        ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">        recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">        SMTP_LOG(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//step 8: DATA</span></span><br><span class="line">    send = <span class="string">"DATA"</span>;</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">    recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step 9: content</span></span><br><span class="line">    send = <span class="string">""</span>;</span><br><span class="line">    send += <span class="string">"FROM: "</span> + user_account;</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    send += <span class="string">"TO: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != dest_account.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            send += <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        send += dest_account[i];</span><br><span class="line">    &#125;</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    send += <span class="string">"SUBJECT: 测试"</span>;</span><br><span class="line">    send += <span class="string">"\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    send += content;</span><br><span class="line">    send += <span class="string">"\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    send += <span class="string">"."</span>;</span><br><span class="line">    send += <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"email:"</span> &lt;&lt; send &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    ::send(sock, send.data(), send.size(), <span class="number">0</span>);</span><br><span class="line">    recv_len = ::recv(sock, buff, len, <span class="number">0</span>);</span><br><span class="line">    SMTP_LOG(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式:<br> <code>A (账号：gg@sina.com，密码：xxxx)</code><br>发送给:<br><code>B (ww@sina.com)</code><br><code>C (yy@qq.com)</code><br>内容为：<br><code>hello world!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; dest;</span><br><span class="line">dest.push_back(&quot;ww@sina.com&quot;);</span><br><span class="line">dest.push_back(&quot;yy@qq.com&quot;);</span><br><span class="line"></span><br><span class="line">std::string content = &quot;hello world!&quot;;</span><br><span class="line"></span><br><span class="line">sendEmail(&quot;gg@sina.com&quot;, &quot;xxxx&quot;, dest, content);</span><br></pre></td></tr></table></figure><h4><span id="思考">思考</span></h4><p>这个方案有一个安全问题，整个交互都是以明文形式，如果存在中间人劫持，很容易获取邮件正文，风险很大<br><strong>那么，如何解决这个安全问题呢？</strong><br>http的不安全问题导致了https的产生，那么有没有安全的smtp协议呢？</p><p><em>请听下回分解</em></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">client->server: telnet smtp.sina.com 25server-->client: xxxclient->server: EHLO smtp.sina.comserver-->client: xxxclient->server: AUTH LOGINserver-->client: xxxclient->server: base64(邮箱账号名)server-->client: xxxclient->server: base64(邮箱密码)server-->client: xxxclient->server: MAIL FROM: &lt;ww@sina.com&gt;server-->client: xxxclient->server: RCPT TO: &lt;yy@sina.com&gt;server-->client: xxxclient->server: DATA:server-->client: xxxclient->server: 发送内容contentserver-->client: xxx</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中需要发送邮件，本来用python几行代码就可以搞定的事情，可是为了与整个项目框架匹配，以利于监控和维护，只能采用C++形式了&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac OS环境下利用Hexo搭建个人博客</title>
    <link href="http://www.xiaocc.xyz/2018-05-06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.xiaocc.xyz/2018-05-06/博客搭建/</id>
    <published>2018-05-06T14:30:00.000Z</published>
    <updated>2018-05-06T14:49:26.982Z</updated>
    
    <content type="html"><![CDATA[<p>在网上查找资料时候碰到很多有意思的技术博客，也一直想拥有个人主页，可是拖延症晚期患者，<br>总是由于各种原因，迟迟未能动手搭建。<br>昨天周六在公司加班，没什么特别紧急的事情，决定把这个坑填上。经过多方面查找资料与实践，有了如今这个小窝，感谢各位知识的分享者。</p><a id="more"></a><p><strong>注意：本人搭建环境为Mac OS</strong></p><p><em>暂未找到合适的图床，只能先用纯文字表述了。。</em></p><h4><span id="大体步骤">大体步骤</span></h4><ul><li>在github创建个人主页仓库</li><li>安装git</li><li>安装nodejs</li><li>安装hexo</li><li>网站预览与推送</li><li>域名申请与绑定</li><li>更换主题等个性化配置</li></ul><h4><span id="详细步骤">详细步骤</span></h4><h4><span id="github相关">github相关</span></h4><p>首先注册github账号，然后创建github pages，创建方法可以自行搜索或者阅读 <a href="https://pages.github.com/" target="_blank" rel="noopener">github官方指引</a> 点击new repository创建一个新仓库，其中仓库名字比较特殊为：<code>xxx.github.io</code> ，其中xxx为自己的github账号名，例如我的仓库名就是：<code>xiaocc2012.github.io</code> 。</p><h4><span id="安装git">安装git</span></h4><h5><span id="安装">安装</span></h5><p>我在mac环境下安装软件，一般是通过homebrew进行，它的安装和使用可以自行搜索一下。<br>执行 <code>brew install git</code> 进行git安装，这时如果遇到错误，一般是因为mac环境的git依赖CommandLineTools需要对其进行安装。</p><h5><span id="配置">配置</span></h5><p>git安装完毕后需要对其进行相关配置<br>设置user.name和user.mail信息<br><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p><h5><span id="ssh-秘钥">ssh 秘钥</span></h5><p>执行 <code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code><br>直接3个回车即可，默认不需要设置密码<br>在 <code>~/.ssh/</code> 目录下会生成 id_rsa、id_rsa.pub 文件，其中 id_rsa.pub 为公钥文件<br>执行 <code>cat id_rsa.pub</code> 打印公钥文件内容，打开 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">github ssh keys设置</a>，创建一个新的ssh key，其中Title随便填写，Key内容即为公钥文件内容。<br>执行 <code>ssh git@github.com</code> 检测公钥是否设置成功</p><p><strong>为什么需要设置ssh 秘钥？</strong></p><p>github每次推送时候都会检查用户是否合法，就需要输入用户名和密码来进行检测，为了省去每次输入密码的步骤，采用ssh非对称加密形式，将公钥保存在github网站，私钥保存在电脑上，每次推送的时候，github会检查私钥是否能与公钥匹配，从而判断用户是否合法。</p><h4><span id="安装nodejs">安装nodejs</span></h4><p>同样采用homebrew进行安装<br><code>brew install node</code><br>执行 <code>node -v</code> 查看nodejs是否安装成功<br>执行 <code>npm -v</code> 查看npm是否安装成功</p><h4><span id="安装hexo">安装hexo</span></h4><p>参考 <a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">hexo官方文档</a>进行安装</p><p>执行 <code>npm install -g hexo-cli</code> 安装hexo<br>执行 <code>hexo init blog</code> 创建blog目录，并进行相关初始化工作<br><code>cd blog</code><br><code>npm install</code><br>创建一个页面来检查网站<br><code>hexo new test_page</code><br><code>hexo g</code><br>启动网站 <code>hexo s</code></p><p><strong>注意：hexo 3需要单独安装 hexo server</strong></p><p>执行 <code>npm install hexo-server --save</code> 进行安装<br>安装完server端后，再次执行 <code>hexo s</code> 启动网站</p><h4><span id="网站预览与推送">网站预览与推送</span></h4><p>待hexo server端启动后，用浏览器打开：localhost:4000，即可查看网站</p><p><strong>hexo与github pages联系</strong></p><p>打开blog根目录下的 <code>_config.yml</code> 文件，该文件存储了站点相关配置<br>找到底部 <code>deploy:</code> 相关，填入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xiaocc2012/xiaocc2012.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>其中repo内容填写自己在github上新建仓库的完整url路径，记得url最后要添加 <strong>.git</strong><br>保存配置文件，这里做的配置其实就是给 <code>hexo d</code> 命令使用，告诉hexo要把blog部署在哪里<br>安装git部署插件 <code>npm install hexo-deployer-git --save</code><br>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>对网站进行clean，重新生成，并启动服务<br>再次在浏览器打开：localhost:4000 进行网站预览</p><p><strong>将网站推送至github</strong><br>网站预览无误后，执行 <code>hexo d</code> 将网站内容推送至github，这时在github查看仓库内容，会发现多了一些文件。<br>在浏览器输入：xiaocc2012.github.io（即为最开始创建的仓库名称），就可以看到刚才一样的博客网站了，也即咱们的博客可以在互联网上进行访问。</p><p><em>我遇到的问题：</em><br>在浏览器通过输入github地址方式访问，一直提示404错误，后来尝试各种折腾，在 <code>Settings</code> 页面的子选项 <code>GitHub Pages</code> 中选择了一个主题theme，然后网页就能正常展示了。</p><h4><span id="域名申请与绑定">域名申请与绑定</span></h4><p>申请一个自己喜欢的域名<br>在解析中新建两条配置：</p><ol><li>新建一条解析，记录类型选择 <code>CNAME</code> ，主机记录：<code>www</code> ，记录值：xiaocc2012.github.io <em>(就是github pages直接访问的那个url地址)</em></li><li>执行 <code>ping xiaocc2012.github.io</code> 获取IP地址W，新建一条解析，记录类型为 <code>A</code>, 主机记录：<code>@</code>，记录值：W <em>(就是刚才通过 ping 获取的ip地址)</em></li></ol><p><strong>在github上的配置</strong><br>在仓库的 <code>Settings</code> 页面的子选项 <code>GitHub Pages</code> 中的 <code>Custom domain</code> 选项中填入自己申请的域名：<code>www.xxx.yyy</code><br>等待约1分钟，待github重新发布页面，就可以通过自己的域名访问网站啦</p><h4><span id="更换主题等个性化配置">更换主题等个性化配置</span></h4><p>hexo默认主题个人不是很喜欢，更换成了next主题，流程如下：<br>进入blog目录 <code>cd blog</code><br>执行 <code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code> 下载next主题<br>打开站点的 <code>_config.yml</code> 配置文件，将主题更换为next主题 <code>theme: next</code><br>执行预览网站的相关命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>在浏览器打开：localhost:4000 预览网站，会发现网站主题样式已经更改<br>将新网站推送至github<br><code>hexo d</code><br>通过自己申请的域名进行访问，也会发现网站样式已经更改</p><p>至此，采用hexo + github pages搭建博客全流程完毕，其它hexo用法与配置就需要各位去探索啦<br><em>enjoy a good time！</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上查找资料时候碰到很多有意思的技术博客，也一直想拥有个人主页，可是拖延症晚期患者，&lt;br&gt;总是由于各种原因，迟迟未能动手搭建。&lt;br&gt;昨天周六在公司加班，没什么特别紧急的事情，决定把这个坑填上。经过多方面查找资料与实践，有了如今这个小窝，感谢各位知识的分享者。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从strncpy的实现说起</title>
    <link href="http://www.xiaocc.xyz/2018-05-05/linux-kernel-strncpy/"/>
    <id>http://www.xiaocc.xyz/2018-05-05/linux-kernel-strncpy/</id>
    <published>2018-05-05T05:32:37.000Z</published>
    <updated>2018-05-06T04:37:24.167Z</updated>
    
    <content type="html"><![CDATA[<p><code>strncpy</code>函数的内核实现与分析</p><a id="more"></a><p>第一次阅读内核源码是在网上浏览博客的时候，有个博主说<code>strncpy</code>的执行效率很低，而且并不是绝对安全，也存在缓冲区溢出的风险。</p><p>先贴出来其实现，再逐行分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HAVE_ARCH_STRNCPY</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strncpy - Copy a length-limited, %NUL-terminated string</span></span><br><span class="line"><span class="comment"> * @dest: Where to copy the string to</span></span><br><span class="line"><span class="comment"> * @src: Where to copy the string from</span></span><br><span class="line"><span class="comment"> * @count: The maximum number of bytes to copy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The result is not %NUL-terminated if the source exceeds</span></span><br><span class="line"><span class="comment"> * @count bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In the case where the length of @src is less than  that  of</span></span><br><span class="line"><span class="comment"> * count, the remainder of @dest will be padded with %NUL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = dest;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count) &#123;(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> ((*tmp = *src) != <span class="number">0</span>)(<span class="number">3</span>)</span><br><span class="line">            src++;(<span class="number">4</span>)</span><br><span class="line">        tmp++;(<span class="number">5</span>)</span><br><span class="line">        count--;(<span class="number">6</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;(<span class="number">7</span>)</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(<span class="built_in">strncpy</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3><span id="首先我们整体看一下函数的执行流程">首先，我们整体看一下函数的执行流程</span></h3><ol><li>行1，将tmp指向dest</li><li>行2，初次进入while循环时，count为dest大小</li><li>行3，将src的内容赋值给tmp</li><li>行4，如果src没有移动到字符串末尾的<code>\0</code>，则把src往后移动一个字节</li><li>行5，tmp向后移动一个字节</li><li>行6，count减1</li></ol><h4><span id="简单来说该函数把src的内容往dest拷贝最多拷贝count个字节">简单来说，该函数把src的内容往dest拷贝，最多拷贝count个字节</span></h4><h4><span id="但是这里有几个关键问题"><strong>但是这里有几个关键问题</strong></span></h4><ol><li>如果src的长度 &gt;= count 会发生什么？</li><li>如果src的长度 &lt; count，该函数性能如何？</li></ol><h4><span id="问题1">问题1：</span></h4><p>如果<code>src_len &gt;= count</code>，根据<code>行2</code>、<code>行3</code>可知，dest会被填充count字节，也就是说src的前count字节会被copy到dest，所以dest末尾并不是<code>\0</code>。</p><h4><span id="问题2">问题2：</span></h4><p>如果src_len &lt; count，考虑边界情况，假设当前src指向字符串末尾（也就是<code>\0</code>的前一个字符），则<code>行3</code>把src的值赋值到tmp，<code>行4</code>src往后移动一个字节，指向<code>\0</code>，行5、行6，把tmp向后移动一个字节，count减1，while循环进入下一次，<code>行3</code>把src的值（也就是<code>\0</code>）赋值给tmp，注意观察<code>行3</code>，此时<code>if</code>语句值为false，src不向后移动（所以src依然指向<code>\0</code>），行5、行6，tmp向后移动，count减1。再次进入下一次循环，<code>行3</code>，把src的当前值（<code>\0</code>）赋值给tmp，<code>if</code>语句值为false，src不向后移动，tmp向后移动，count减1。<strong>所以，此情况下，该函数会使用<code>\0</code>填充dest剩下的全部字节。</strong></p><h4><span id="看看如下常用的使用方式">看看如下常用的使用方式：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buff[1024];</span><br><span class="line">const char* src = &quot;hello world&quot;;</span><br><span class="line">strncpy(buff, src, sizeof(buff));</span><br></pre></td></tr></table></figure><p>把src内容拷贝到buff后，会将剩余的空间全部填充0，效率非常低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buff[5];</span><br><span class="line">const char* src = &quot;hello world&quot;;</span><br><span class="line">strncpy(buff, src, sizeof(buff));</span><br></pre></td></tr></table></figure><p>buff的长度比src长度要小，buff末尾并不是<code>\0</code>，需要添加如下语句才能避免缓冲区溢出问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buff[sizeof(buff) - 1] = 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;strncpy&lt;/code&gt;函数的内核实现与分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux kernel" scheme="http://www.xiaocc.xyz/tags/linux-kernel/"/>
    
      <category term="strncpy" scheme="http://www.xiaocc.xyz/tags/strncpy/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.xiaocc.xyz/2018-05-05/hello-world/"/>
    <id>http://www.xiaocc.xyz/2018-05-05/hello-world/</id>
    <published>2018-05-05T04:00:00.000Z</published>
    <updated>2018-05-29T02:12:44.428Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo用法简介</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo用法简介&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
