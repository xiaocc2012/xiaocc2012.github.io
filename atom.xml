<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曾经浮华的小窝</title>
  
  <subtitle>hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaocc.xyz/"/>
  <updated>2018-12-08T13:56:15.894Z</updated>
  <id>http://www.xiaocc.xyz/</id>
  
  <author>
    <name>曾经浮华</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协程原理解析(2)</title>
    <link href="http://www.xiaocc.xyz/2018-12-06/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/"/>
    <id>http://www.xiaocc.xyz/2018-12-06/协程原理解析2/</id>
    <published>2018-12-06T14:00:00.000Z</published>
    <updated>2018-12-08T13:56:15.894Z</updated>
    
    <content type="html"><![CDATA[<p>探讨与分析实现协程依赖的四大函数</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>接上篇讲到协程的实现需要依赖四大函数：</p><ul><li><code>int getcontext(ucontext_t *ucp);</code></li><li><code>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</code></li><li><code>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</code></li><li><code>int setcontext(const ucontext_t *ucp);</code></li></ul><p>本篇具体分析这四大函数的功能与实现，代码阅读工具采用：<br><a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq在线源码阅读平台</a></p><h4><span id="实际例子">实际例子</span></h4><p>先看看使用四大函数构造协程的一个简单例子，例子中函数<code>f1</code>、<code>f2</code>交替运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main-&gt;f1-&gt;f2</span></span><br><span class="line"><span class="comment">//ut[0]-&gt;ut[1]-&gt;ut[2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ucontext_t</span> ut[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"f1:%d\n"</span>, i);</span><br><span class="line">        swapcontext(&amp;ut[<span class="number">1</span>], &amp;ut[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"f2:%d\n"</span>, i);</span><br><span class="line">        swapcontext(&amp;ut[<span class="number">2</span>], &amp;ut[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> stack_buff[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> stack_buff2[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    getcontext(&amp;ut[<span class="number">1</span>]);</span><br><span class="line">    ut[<span class="number">1</span>].uc_stack.ss_sp = stack_buff;</span><br><span class="line">    ut[<span class="number">1</span>].uc_stack.ss_size = <span class="keyword">sizeof</span>(stack_buff);</span><br><span class="line">    ut[<span class="number">1</span>].uc_link = &amp;ut[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    makecontext(&amp;ut[<span class="number">1</span>], f1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    getcontext(&amp;ut[<span class="number">2</span>]);</span><br><span class="line">    ut[<span class="number">2</span>].uc_stack.ss_sp = stack_buff2;</span><br><span class="line">    ut[<span class="number">2</span>].uc_stack.ss_size = <span class="keyword">sizeof</span>(stack_buff2);</span><br><span class="line">    ut[<span class="number">2</span>].uc_link = &amp;ut[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    makecontext(&amp;ut[<span class="number">2</span>], f2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    swapcontext(&amp;ut[<span class="number">0</span>], &amp;ut[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="引子">引子</span></h4><p>在Stack Overflow上有一个问题：<br><a href="https://stackoverflow.com/questions/19503925/what-does-the-getcontext-system-call-ucontext-h-really-do" target="_blank" rel="noopener">What does the getcontext system call (ucontext.h) really do?</a></p><p>提问者问道：</p><ul><li><code>getcontext</code>究竟干了什么</li><li>与<code>makecontext</code>有什么区别</li><li>为什么不能直接定义一个<code>ucontext_t</code>结构，然后初始化并调用<code>makecontext</code>，再使用<code>swapcontext</code>或者<code>setcontext</code>激活context</li><li>为什么不按照man page要求的在调用<code>makecontext</code>之前调用<code>getcontext</code>，激活context就会报错</li></ul><p>为了解决这些疑惑，我们深入到源码级别，看看这些函数到底做了什么。</p><h4><span id="基础结构ucontext_t">基础结构<code>ucontext_t</code></span></h4><p>先看看这个最重要的结构的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span>         uc_sigmask;</span><br><span class="line">    <span class="keyword">stack_t</span>          uc_stack;</span><br><span class="line">    <span class="keyword">mcontext_t</span>       uc_mcontext;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure><p>其中:<br><code>uc_link</code>表示该context执行完毕之后，下一个需要激活的context<br><code>uc_sigmask</code>主要是该context需要屏蔽的信号<br><code>uc_stack</code>指定context运行时候的栈空间<br><code>mcontext_t</code>的定义依赖于特定平台，主要包含寄存器等结构</p><h4><span id="int-getcontextucontext_t-ucp">int getcontext(ucontext_t *ucp)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/getcontext.S.html" target="_blank" rel="noopener">getcontext在线代码</a></p><p>主要是将当前context的相关寄存器值保存，相当于保护现场</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq        (%rsp), %rcx</span><br><span class="line">movq        %rcx, oRIP(%rdi)</span><br><span class="line">leaq        8(%rsp), %rcx         /* Exclude the return address.  */</span><br><span class="line">movq        %rcx, oRSP(%rdi)</span><br></pre></td></tr></table></figure><p>这里需要对C++中函数调用栈熟悉，函数调用时候，先对参数压栈，再压入返回地址，再执行被调函数体指令。</p><p>由于是在当前context中调用得<code>getcontext</code>函数，所以<code>(%rsp)</code>中保存的即是函数返回地址，也就是执行完<code>getcontext</code>这个函数之后需要执行的下一个指令的地址。<br><code>8(%rsp)</code>值即是当前context的栈顶排除返回地址之后的值。</p><p>由于context即是由代码+数据组成，保存了相关寄存器的值主要是<code>rip</code>值，同时把当前栈的<code>rsp</code>值也保存，这样便可以通过这些数据恢复context以再次继续执行。</p><p>这其中还有一个很重要的操作，保存了浮点寄存器相关数据。</p><h4><span id="void-makecontextucontext_t-ucp-void-func-int-argc">void makecontext(ucontext_t <em>ucp, void (</em>func)(), int argc, …)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/makecontext.c.html" target="_blank" rel="noopener">makecontext在线代码</a></p><p>该函数由C语言实现，代码前部的注释中简明介绍了该函数的工作</p><p>该函数主要是进行栈准备工作，并保存相关值到<code>uc_mcontext</code>的寄存器结构中，同时把<code>uc_link</code>值也做了保存，而需要传递给<code>func</code>函数的参数，一部分保存在寄存器中，剩下的保存在栈中。</p><p>栈布局结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           +-----------------------+</span><br><span class="line">           | next context          |</span><br><span class="line">           +-----------------------+</span><br><span class="line">           | parameter 7-n         |</span><br><span class="line">           +-----------------------+</span><br><span class="line">           | trampoline address    |</span><br><span class="line">%rsp -&gt;    +-----------------------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Setup context ucp.  */</span><br><span class="line">/* Address to jump to.  */</span><br><span class="line">ucp-&gt;uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;</span><br><span class="line">/* Setup rbx.*/</span><br><span class="line">ucp-&gt;uc_mcontext.gregs[REG_RBX] = (uintptr_t) &amp;sp[idx_uc_link];</span><br><span class="line">ucp-&gt;uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;</span><br><span class="line"></span><br><span class="line">sp[0] = (uintptr_t) &amp;__start_context;</span><br><span class="line">sp[idx_uc_link] = (uintptr_t) ucp-&gt;uc_link;</span><br></pre></td></tr></table></figure><p>这其中一个巧妙之处在于，如何实现在该context执行完毕后自动激活<code>uc_link</code>并执行？</p><p>在该函数中把返回地址巧妙的设置为<code>__start_context</code>，这样，当<code>func</code>函数执行完毕后即会转到<code>__start_context</code>执行，而在该函数中即可实现激活<code>uc_link</code>并执行。</p><h4><span id="int-swapcontextucontext_t-oucp-ucontext_t-ucp">int swapcontext(ucontext_t <em>oucp, ucontext_t </em>ucp)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/swapcontext.S.html" target="_blank" rel="noopener">swapcontext在线代码</a></p><p>当<code>makecontext</code>做好准备工作后，即由该函数进行context切换，把执行流程切到另外一个context。</p><p>该函数首先将当前context的相关寄存器值保存到<code>oucp</code>中，而第54-57行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq        (%rsp), %rcx</span><br><span class="line">movq        %rcx, oRIP(%rdi)</span><br><span class="line">leaq        8(%rsp), %rcx       /* Exclude the return address.  */</span><br><span class="line">movq        %rcx, oRSP(%rdi)</span><br></pre></td></tr></table></figure><p>当前<code>rsp</code>指向的地址中存储的即是返回地址，也就是调用<code>swapcontext</code>后当前协程需要执行的下一个指令地址。<br><code>swapcontext</code>函数没有返回值，因为在其内部会发生执行流程的跳转，控制权会转移到另外的context。<br><code>8(%rsp)</code>的值即是排除返回地址后的当前栈顶地址。<br>保存当前context的相关信息后，将来控制权再切回来时，就能正确的恢复现场。</p><p>剩下的工作即是用<code>ucp</code>中保存的信息，设置相关寄存器值，如<code>rsp</code>、<code>rbp</code>等。<br>我们知道程序的指令寄存器为<code>rip</code>，只有改变该寄存器值才能改变程序的执行流程，关键在于函数底部的第231-248行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* The following ret should return to the address set with</span><br><span class="line">        getcontext.  Therefore push the address on the stack.  */</span><br><span class="line">movq        oRIP(%rdx), %rcx</span><br><span class="line">pushq        %rcx</span><br><span class="line">/* Setup registers used for passing args.  */</span><br><span class="line">movq        oRDI(%rdx), %rdi</span><br><span class="line">movq        oRSI(%rdx), %rsi</span><br><span class="line">movq        oRCX(%rdx), %rcx</span><br><span class="line">movq        oR8(%rdx), %r8</span><br><span class="line">movq        oR9(%rdx), %r9</span><br><span class="line">/* Setup finally %rdx.  */</span><br><span class="line">movq        oRDX(%rdx), %rdx</span><br><span class="line">/* Clear rax to indicate success.  */</span><br><span class="line">xorl        %eax, %eax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>将<code>ucp</code>中保存的<strong>返回地址压栈</strong>，该返回地址即是该协程之前执行<code>swapcontext</code>的那个点，因为只有执行该函数才能将控制权转移给别的协程，现在如果把控制权再切回该协程，下一个需要执行的指令地址是多少呢？<br>即是当初调用<code>swapcontext</code>函数时候的返回地址，然后执行<code>ret</code>指令，该指令将当前栈上的值弹出并保存到<code>rip</code>，到这里控制权完成切换，从协程<code>oucp</code>切换到<code>ucp</code>。</p><h4><span id="int-setcontextconst-ucontext_t-ucp">int setcontext(const ucontext_t *ucp)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/setcontext.S.html" target="_blank" rel="noopener">setcontext在线代码</a></p><p>该函数功能与<code>swapcontext</code>类似，将控制权转移到<code>ucp</code>中。</p><h4><span id="为什么必须调用getcontext">为什么必须调用<code>getcontext</code></span></h4><p>在<code>getcontext</code>中保存了浮点寄存器相关值，该值在<code>swapcontext</code>、<code>setcontext</code>中都有使用，否则调用时会发生异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探讨与分析实现协程依赖的四大函数&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>协程原理解析(1)</title>
    <link href="http://www.xiaocc.xyz/2018-12-05/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901/"/>
    <id>http://www.xiaocc.xyz/2018-12-05/协程原理解析1/</id>
    <published>2018-12-05T15:00:00.000Z</published>
    <updated>2018-12-05T15:12:41.992Z</updated>
    
    <content type="html"><![CDATA[<p>探讨C/C++协程实现原理，分析协程实现依赖的四大函数</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>前两天跟同事讨论C++中的协程，我提到微信开源的协程库libco，性能高、稳定性好。<br>在看点项目后期，有些模块也引入该协程库，以解决异步调用复杂，代码逻辑难以梳理，维护性差，出bug后不易排查等问题。<br>引入协程库后，代码以顺序性书写，易于理解，而执行时则是异步调用，性能不减。</p><h4><span id="协程用法">协程用法</span></h4><p>协程库核心即是在用户线程中模拟操作系统线程并进行调度，一个协程A调用网络写请求write后，然后调用<code>yield</code>将控制权交出，协程调度器从所有协程中获取满足唤醒条件的协程（如：远端服务返回数据或sleep时间到等等），对其调用<code>resume</code>，使该协程继续执行。</p><p>例如协程版网络库封装如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendAndRecv</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; recv_data, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; send_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过socket发送数据</span></span><br><span class="line">    write(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将协程控制权交出</span></span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//远端服务器返回数据后，该协程被调度器resume，从yield后继续执行</span></span><br><span class="line">    read(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，上层逻辑代码写起来非常直接，例如某个处理需要先请求A服务获取特定数据，再请求B服务获取特定数据，两种数据整合后再返回给请求方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//请求A服务获取数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_recv_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造请求数据包</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_send_data = ....;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用协程库接口</span></span><br><span class="line">    SendAndRecv(a_recv_data, a_send_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求B服务获取数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> b_recv_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造请求数据包</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> b_send_data = ....;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用协程库接口</span></span><br><span class="line">    SendAndRecv(b_recv_data, b_send_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//整合A、B服务的数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不采用协程方式，要么：</p><ol><li>使用网络库同步版API，该代码书写方式在请求量大时候，服务性能不足，线程大量时间阻塞在等待远端服务返回数据，整体吞吐量不高。</li><li>针对每个请求，改造与管理session，并与事件框架结合，待远端服务返回数据，事件框架通知后采用回调形式。这样，原本连贯的处理逻辑，会被切分得支离破碎。<br>示例代码如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造session</span></span><br><span class="line">    Session* session = m_SessionMgr.AddSession();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//往服务A发送请求以获取数据</span></span><br><span class="line">    <span class="comment">//将session_id发送至服务A，同时服务A将该session_id原样返回</span></span><br><span class="line">    <span class="comment">//构造请求数据包</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_send_data = ....;</span><br><span class="line">    SendData(a_send_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数由事件框架调用，当远端服务器有数据返回时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRecvRemoteData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; recv_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从recv_data中解析出session_id</span></span><br><span class="line">    <span class="keyword">uint32_t</span> session_id = GetSessionID(recv_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从session管理器获取session</span></span><br><span class="line">    Session* ps = m_SessionMgr.GetSession(session_id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//session中有step标记，以区分是服务A返回还是服务B返回</span></span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;step == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Session结构中缓存A服务返回的数据</span></span><br><span class="line">        ps-&gt;recv_a_data = recv_data;</span><br><span class="line">        </span><br><span class="line">        ps-&gt;step = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//请求B服务获取数据</span></span><br><span class="line">        <span class="comment">//同样需要将session_id带至远端</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> b_send_data = ....;</span><br><span class="line">        SendData(b_send_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//服务B的数据已经返回</span></span><br><span class="line">        <span class="comment">//可以进行总处理</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data_a = ps-&gt;recv_a_data;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data_b = recv_data;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//核心数据处理流程</span></span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放session</span></span><br><span class="line">        m_SessionMgr.DelSession(session_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上方案对比可以发现，采用协程后代码逻辑清晰易懂，同时代码量也更少，出问题后更利于排查。</p><h4><span id="协程原理">协程原理</span></h4><p>协程按类型分为：</p><ul><li><code>非对称式协程</code>，协程之间有调用链关系，一个协程A释放控制权有2种方式<ul><li>通过调用<code>yield</code>，将控制权返还给协程A的创建协程</li><li>通过调用<code>resume</code>，将控制权交给一个子协程</li></ul></li><li><code>对称式协程</code>，与<code>非对称式协程</code>不同，各个协程之间可以互相转移控制权，类似于goto语句，这种方式，即使非常有经验的程序员也很难理清调用流程。同时该协程方式实现困难，性能不高。</li></ul><p>业内实现的C/C++协程基本都采用<code>非对称</code>的协程方式。</p><p>协程实现主要依赖以下四个系统级函数：</p><ul><li><code>int getcontext(ucontext_t *ucp);</code></li><li><code>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</code></li><li><code>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</code></li><li><code>int setcontext(const ucontext_t *ucp);</code></li></ul><p>相关函数定义均在<code>ucontext.h</code>，通过查询man page可以大略知道各个函数的作用<br>可参考文档：<a href="https://linux.die.net/man/3/makecontext" target="_blank" rel="noopener">文档</a></p><ul><li>getcontext——可以认为是用当前执行环境初始化<code>ucontext_t</code>结构</li><li>makecontext——更改ucp结构，该结构必须先通过调用getcontext进行初始化，同时进行stack相关赋值，待该ucp通过swapcontext或setcontext激活时，其会从func函数开始执行</li><li>swapcontext——把当前执行环境保存到oucp，并激活ucp进行执行</li><li>setcontext——激活ucp并进行执行</li></ul><p>接下来会详细分析这几个函数的实现，并参考云风的协程库进行分析。</p><p>参考文档：</p><ol><li><a href="https://www.zhihu.com/question/52193579" target="_blank" rel="noopener">腾讯开源的 libco 号称千万级协程支持，那个共享栈模式原理是什么?</a></li><li><a href="https://github.com/cloudwu/coroutine" target="_blank" rel="noopener">云风的协程库</a></li><li><a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">我所理解的ucontext族函数</a></li><li><a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq源码阅读网站</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探讨C/C++协程实现原理，分析协程实现依赖的四大函数&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++17学习笔记(3)——容器、指针、线程</title>
    <link href="http://www.xiaocc.xyz/2018-09-30/C++17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://www.xiaocc.xyz/2018-09-30/C++17学习笔记3/</id>
    <published>2018-09-30T12:30:00.000Z</published>
    <updated>2018-09-30T14:22:01.823Z</updated>
    
    <content type="html"><![CDATA[<p>C++17学习笔记系列</p><a id="more"></a><ol><li><p>容器</p><ul><li><p>std::array<br>与 std::vector 区别：栈内存、固定大小</p></li><li><p>std::forward_list<br>单链表、不提供size()函数</p></li><li><p>无序容器</p><ul><li>unordered_map</li><li>unordered_multimap</li><li>unordered_set</li><li>unordered_multiset</li></ul></li><li><p>元组 std::tuple</p><ul><li>std::make_tuple 构造元组</li><li>std::get&lt;N&gt;() 获得元组中某个位置的值<br> 其中N为编译期固定值，包括数字常量值、constexpr值<br> 如何在运行期获取tuple中的值，接下来会介绍</li><li><p>std::tie 从tuple中获取解值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packing/unpacking tuples</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::make_tuple, std::tie</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line">  <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">char</span>&gt; mytuple;</span><br><span class="line"></span><br><span class="line">  mytuple = <span class="built_in">std</span>::make_tuple (<span class="number">10</span>, <span class="number">2.6</span>, <span class="string">'a'</span>);          <span class="comment">// packing values into tuple</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tie (myint, <span class="built_in">std</span>::ignore, mychar) = mytuple;   <span class="comment">// unpacking tuple into variables</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myint contains: "</span> &lt;&lt; myint &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mychar contains: "</span> &lt;&lt; mychar &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在运行期索引tuple值<br>利用 <code>boost::variant</code> 配合变长模板参数的黑魔法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/variant.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> n, <span class="keyword">typename</span>... T&gt;</span><br><span class="line">boost::variant&lt;T...&gt; _tuple_index(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;T...&gt;&amp; tpl) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;n&gt;(tpl);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="keyword">sizeof</span>...(T) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"越界."</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> _tuple_index&lt;(n &lt; <span class="keyword">sizeof</span>...(T)<span class="number">-1</span> ? n+<span class="number">1</span> : <span class="number">0</span>)&gt;(i, tpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line">boost::variant&lt;T...&gt; tuple_index(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;T...&gt;&amp; tpl) &#123;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;<span class="number">0</span>&gt;(i, tpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><code>std::tuple</code> tpl 在其定义时，其能保存的元素个数已经确定，并且在编译期可以获取，也就是 <code>sizeof...(T)</code> 。</li><li><code>std::get&lt;N&gt;()</code> 中 <code>N</code> 只能是常量值，既然要运行期获取tpl中某index值，那么该index可取值区间为 <code>[0, Len - 1]</code> ，那么可以采取一种笨方法，通过获取 <code>get&lt;0&gt;,get&lt;1&gt; ... get&lt;Len - 1&gt;</code> 逐个与index比较，最终即可获取到下标为index的值。</li><li><code>tuple_index</code> 函数，从 <code>0</code> 开始尝试，并在编译期实例化大量的 <code>_tuple_index</code> 函数，即 <code>_tuple_index&lt;0&gt;</code>，<code>_tuple_index&lt;1&gt;</code>，… <code>_tuple_index&lt;Len - 1&gt;</code>，而其中每个函数即可调用 <code>std::get&lt;0&gt;</code>，<code>std::get&lt;1&gt;</code>，… <code>std::get&lt;Len - 1&gt;</code>。</li><li>详细过程：<br>在 <code>_tuple_index&lt;0&gt;</code> 中判断 <code>i</code>，<code>n</code> 值，如果不符，继续往上递归增长式调用 <code>_tuple_index&lt;1&gt;</code>，再次判断 <code>i</code>，<code>n</code>值，如果不符，则调用 <code>_tuple_index&lt;2&gt;</code>，如此往复，直到某个 <code>n</code> 值与 <code>i</code> 相等，则此时调用 <code>std::get&lt;n&gt;(tpl)</code> 获取tpl中值。</li></ol><p><strong>使用方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">tuple_len</span><span class="params">(T &amp;tpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tuple_size&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != tuple_len(new_tuple); ++i) &#123;</span><br><span class="line">    <span class="comment">// 运行期索引</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuple_index(i, new_tuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>指针</p><ul><li><p>std::shared_ptr<br>std::make_shared</p></li><li><p>std::unique_ptr<br>一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全<br>可以利用 <code>std::move</code> 转移给其它的 unique_ptr<br>std::make_unique</p></li><li><p>std::weak_ptr<br>解决 <code>std::shared_ptr</code> 之间循环引用，析构时无法释放问题</p></li></ul></li><li><p>线程与并发</p><ul><li><p>std::thread</p></li><li><p>std::mutex</p><ul><li>std::lock_guard<br> RAII，构造函数lock，析构函数unlock</li><li>std::unique_lock<br> 默认行为与std::lock_guard一致，但是提供lock、unlock函数手动操作mutex</li></ul></li><li><p>std::packaged_task、std::future、std::promise<br>关于 <code>std::future</code>，<code>std::promise</code> 会再写一篇详细介绍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>()&gt; task([]()&#123;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f = task.get_future();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread(<span class="built_in">std</span>::move(task)).detach();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait result ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    f.wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = f.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"get result:"</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>std::conditiaon_variable 信号量</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++17学习笔记系列&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++17学习笔记(2)——语言运行期强化</title>
    <link href="http://www.xiaocc.xyz/2018-09-19/C++17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://www.xiaocc.xyz/2018-09-19/C++17学习笔记2/</id>
    <published>2018-09-19T00:30:00.000Z</published>
    <updated>2018-09-19T05:01:19.705Z</updated>
    
    <content type="html"><![CDATA[<p>C++17学习笔记系列</p><a id="more"></a><ol><li><p>Lambda表达式</p><ul><li><p>Lambda 表达式的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>捕获列表</p><ul><li><p>值捕获</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">learn_lambda_func_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value_1 = [value_1] &#123;</span><br><span class="line">        <span class="keyword">return</span> value_1;</span><br><span class="line">    &#125;;</span><br><span class="line">    value_1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value_1 = copy_value_1();</span><br><span class="line">    <span class="comment">// 这时, stored_value_1 == 1, 而 value_1 == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value_1 在创建时就保存了一份 value_1 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用捕获</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">learn_lambda_func_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value_2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value_2 = [&amp;value_2] &#123;</span><br><span class="line">        <span class="keyword">return</span> value_2;</span><br><span class="line">    &#125;;</span><br><span class="line">    value_2 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value_2 = copy_value_2();</span><br><span class="line">    <span class="comment">// 这时, stored_value_2 == 100, value_1 == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value_2 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>隐式捕获</li></ul><blockquote><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用 <code>引用捕获</code>或者 <code>值捕获</code>。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] 空捕获列表</span><br><span class="line">[name1, name2, ...] 捕获一系列变量</span><br><span class="line">[&amp;] 引用捕获, 让编译器自行推导捕获列表</span><br><span class="line">[=] 值捕获, 让编译器执行推导应用列表</span><br></pre></td></tr></table></figure></li></ul></li><li><p>泛型Lambda</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数对象包装器</p><ul><li>std::function</li><li><p>std::bind/std::placeholder</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + (<span class="number">2</span> * b) + (<span class="number">3</span> * c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + important + <span class="number">5</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func2(<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindfoo = <span class="built_in">std</span>::bind(foo2, <span class="number">5</span>, _1, _2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bindfoo(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>右值引用</p><ul><li>左值</li><li>右值<ul><li>纯右值</li><li>将亡值</li></ul></li><li>左值引用</li><li>右值引用<blockquote><p>需要拿到一个将亡值，就需要用到右值引用的申明：T &amp;&amp;，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p></blockquote></li></ul><ul><li>移动语义<ul><li>移动构造函数</li><li>移动赋值函数</li></ul></li><li><p>完美转发<br>  一个声明的右值引用其实是一个左值</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">rv2 += <span class="string">"Test"</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,string,Test</span></span><br><span class="line"></span><br><span class="line">reference(rv2); <span class="comment">// 输出左值</span></span><br></pre></td></tr></table></figure><p>   rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值</p></li></ul></li></ol><p><strong>引用坍缩规则：</strong></p><blockquote><p>在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引用，又能右引用。</p></blockquote><table><thead><tr><th style="text-align:center">函数形参类型</th><th style="text-align:center">实参参数类型</th><th style="text-align:center">推导后函数形参类型</th></tr></thead><tbody><tr><td style="text-align:center">T&amp;</td><td style="text-align:center">左引用</td><td style="text-align:center">T&amp;</td></tr><tr><td style="text-align:center">T&amp;</td><td style="text-align:center">右引用</td><td style="text-align:center">T&amp;</td></tr><tr><td style="text-align:center">T&amp;&amp;</td><td style="text-align:center">左引用</td><td style="text-align:center">T&amp;</td></tr><tr><td style="text-align:center">T&amp;&amp;</td><td style="text-align:center">右引用</td><td style="text-align:center">T&amp;&amp;</td></tr></tbody></table><blockquote><p>因此，模板函数中使用 T&amp;&amp; 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。这才使得 v 作为左值的成功传递。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"左值引用"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"右值引用"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"普通传参:"</span>;</span><br><span class="line">    reference(v);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::move 传参:"</span>;</span><br><span class="line">    reference(<span class="built_in">std</span>::move(v));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::forward 传参:"</span>;</span><br><span class="line">    reference(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传递右值:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    pass(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传递左值:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    pass(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传递右值:</span><br><span class="line">普通传参:左值引用</span><br><span class="line">std::move 传参:右值引用</span><br><span class="line">std::forward 传参:右值引用</span><br><span class="line">传递左值:</span><br><span class="line">普通传参:左值引用</span><br><span class="line">std::move 传参:右值引用</span><br><span class="line">std::forward 传参:左值引用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++17学习笔记系列&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++17学习笔记(1)——语言可用性强化</title>
    <link href="http://www.xiaocc.xyz/2018-09-18/c++17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://www.xiaocc.xyz/2018-09-18/c++17学习笔记1/</id>
    <published>2018-09-18T03:50:00.000Z</published>
    <updated>2018-09-20T14:27:28.270Z</updated>
    
    <content type="html"><![CDATA[<p>C++17学习笔记系列1</p><a id="more"></a><ol><li>nullptr</li><li>constexpr</li><li>if/switch 中定义临时变量</li><li><p>初始化列表 <code>initializer_list</code></p><ul><li><p>类构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MagicFoo(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">            it != <span class="built_in">list</span>.end();</span><br><span class="line">            ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        vec_.push_back(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;::const_iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">            it != <span class="built_in">list</span>.end();</span><br><span class="line">            ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>统一的初始化语法<br><code>MagicFoo magicFoo = {1, 2, 3, 4, 5};</code> </p></li></ul></li><li><p>结构化绑定 tuple</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; f() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">"456"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = f();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">", "</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>类型推导</p><ul><li><p>auto 针对变量进行类型推导<br>   auto 不能用于函数传参<br>   auto 不能用于推导数组类型<br>   <code>auto i = 5;  // i 被推导为 int</code></p></li><li><p>decltype 针对表达式进行类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure></li><li><p>尾返回类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x+y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>decltype(auto) 函数转发的返回类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>  <span class="title">lookup1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">lookup2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) look_up_a_string_1() &#123;</span><br><span class="line">    <span class="keyword">return</span> lookup1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) look_up_a_string_2() &#123;</span><br><span class="line">    <span class="keyword">return</span> lookup2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>区间 for 迭代</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>); itr != vec.end())</span><br><span class="line">        *itr = <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;                      <span class="comment">// writeable</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>模板</p><ul><li><p>变长参数模板<br><code>template&lt;typename... Ts&gt; class Magic;</code></p><blockquote><p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<br>  <code>class Magic&lt;&gt; nothing;</code></p><p>如果不希望产生的模板参数个数为 <code>0</code> ，可以手动的定义至少一个模板参数：<br>  <code>template&lt;typename Require, typename... Args&gt; class Magic;</code></p></blockquote></li><li><p>应用到模板函数上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str, Args... args)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>如何对参数解包：</p><ul><li><p>参数个数 <code>sizeof…</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对参数解包</p><ul><li><p>递归模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T value, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"123"</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>c++17中简略写法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t0 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    if constexpr (sizeof...(t) &gt; 0) printf(t...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化列表展开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译这个代码需要开启 -std=c++14</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print</span><span class="params">(T value, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;] &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;(), value)...&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="number">1</span>, <span class="number">2.1</span>, <span class="string">"123"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>折叠表达式</strong></p><blockquote><p><a href="https://zh.cppreference.com/w/cpp/language/fold" target="_blank" rel="noopener">折叠表达式 cppreference</a><br><a href="https://blog.csdn.net/zwvista/article/details/53981696" target="_blank" rel="noopener">C++17尝鲜：fold expression</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>面向对象</p><ul><li>委托构造</li><li>继承构造</li><li>显式虚函数重载 <code>override、final</code></li><li><p>显式禁用默认函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Magic() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">        Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">        Magic(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++17学习笔记系列1&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>穷，是一种病</title>
    <link href="http://www.xiaocc.xyz/2018-09-12/%E7%A9%B7%E6%98%AF%E4%B8%80%E7%A7%8D%E7%97%85/"/>
    <id>http://www.xiaocc.xyz/2018-09-12/穷是一种病/</id>
    <published>2018-09-12T15:00:00.000Z</published>
    <updated>2018-09-18T03:45:44.421Z</updated>
    
    <content type="html"><![CDATA[<p>观看《我不是药神》后，一直想就这个话题写点东西，三十年的邻居突患病离世，更添些许压抑。</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>前段时间跟老婆一起看了口碑爆棚的神作《我不是药神》，影片很好的反应当代现实与社会问题。<br>特别是里面有句台词，<code>世上有一种病叫穷病——没得治</code>。</p><p>在这里不想讨论大道理，如：医药公司是否过于暴利、政府的缺位等等，只想说一下亲身体会。</p><h4><span id="亲人患病">亲人患病</span></h4><h5><span id="初诊">初诊</span></h5><p>大约7月份的时候，堂弟突然微信联系我，发来一些检查报告，是他岳母的。<br>检查报告先出来，周一才能找医生会诊，心里比较着急，让我找同学帮忙问问报告内容具体什么意思。</p><p>赶紧与同学联系，她是麻醉师，医院各科室都认识人。<br>她找人看了一下检查报告，对方提出需要查看图片影像，以增加信息辅助判断，但是根据检查报告初步怀疑肺癌。</p><p>收到信息后，马上给堂弟打电话，他对此已有所预感，待周一拿上相关资料与医生当面会诊。</p><p><strong>为什么会这样？</strong></p><p>犹如晴天霹雳，今年初的时候还到他们家做客，岳母才47岁，非常年轻，刚当上外婆，宝宝才1岁，为什么这个不幸的病会找上她。<br>且宝宝刚出生时，由于感染，在中心医院住院治疗一个多月，没有明显恢复，后又转院到同济医院，前后花了十多万，举债累累。<br>万幸的是治疗后，宝宝没有后遗症、恢复很好，让人欣慰。</p><p>去年宝宝患病，今年岳母患病，让这个本就不富裕的家庭，更捉襟见肘。</p><p>这可如何是好？虽还没确诊，但我已有如此担忧。</p><h5><span id="确诊">确诊</span></h5><p>周一下午，打电话给堂弟询问具体诊断结果，医生初步怀疑肺癌，需要做病理检查，进一步确认。</p><p>按照医生的要求，一项项检查，焦急的等等……</p><p>周五堂弟打电话过来，确诊：<strong>肺腺癌晚期</strong>。<br>医生反馈由于是晚期，且带有一些扩散，无法进行手术治疗，可以尝试进行<strong>靶向治疗</strong>，但是需要先进行基因检测。</p><p>赶紧打电话给同学，将最新信息同步于她，并寻求建议、打听基因检测价格、靶向药物价格等等。</p><h5><span id="靶向治疗">靶向治疗</span></h5><p>预约基因检测，待拿到检测结果后，再预约医生制定具体治疗方案。<br>基因检测结果显示，可以使用靶向药物，药名：<strong>吉非替尼</strong>，俗名：<strong>易瑞沙</strong>。</p><p>这个药已经国产，一盒大约2000多块钱，疗程10天，一个月大约6000多块钱。</p><p>虽然国产后已便宜许多，但是一个月6000多的药物费用，依然让这个家庭特别吃力。</p><p>这时想起《我不是药神》的情节，这个药有没有印度版？价格怎么样？</p><p>立马在各种同学群找他们帮忙，打听药物渠道、价格如何、疗效怎样。</p><p>由于《药神》上映后，海关检查特别严格，药物不好带，他们多方打听也没有合适渠道。</p><p>不放弃，最后找到一个渠道，印度直接邮寄过来，先来一盒看看疗效，以验证药物是否靠谱，最后药价大约是正版药的<strong>1/5</strong>。</p><p>堂弟将岳母接回老家吃药静养，带带宝宝，放松心情，每半个月复查一次。</p><p>这一切才刚刚开始。</p><h4><span id="隔壁邻居患病离世">隔壁邻居患病离世</span></h4><p>周六定时给家里打电话，老爸突然说道，隔壁华爷爷去世。</p><p>怎么可能？</p><p>年初回家过年，还跟他打招呼着呢。<br>他喜欢喝酒，喝完后拿着泡着茶的保温杯，嘴里叼一根烟，一踱一踱的走着，笑呵呵的对我说，“回来过年啦”，“是啊，过年必须要回来呀，城市过年没气氛，有钱没钱，回家过年”。</p><p>他腿是去年摔断的，这事儿也是听老爸说的。</p><p>当时吃了酒席喝了酒，主人家要送他回家。他偏不，倔得很，非要自己骑摩托车回来，不幸摔跤，休养了约半年才好。</p><p>老爸说，华爷爷是今年3-4月份村里大检查时排查出来的，<strong>肺癌晚期</strong>。<br>他又不配合治疗，不打针、不吃药，按他的说法，“还不如拿治病的钱喝酒呢，反正治不好，多花些冤枉钱”。</p><p>也可能是，不想为子女添加负担吧。农村年收入才2-3万元，按最便宜的治疗方案，初期怎么也得花费大几万，后面每个月还有固定开销，对农村家庭真是难以承受。</p><p><strong>穷，真是一种病</strong></p><p>9月6号当晚，可能是疼痛难忍，自己喝药走了。</p><p>这就是华爷爷，看着我长大的华爷爷，就这样走了。</p><p>俗话说，远亲不如近邻，特别是在农村，这种感受尤为强烈。</p><p>深深的无力感，就我认识的人，患癌症的就有7-8个人。</p><p>三姨妈淋巴癌晚期带转移，已经化疗几个疗程，人都瘦得不行，靶向药：<strong>美罗华</strong>，50ml药价25000。<br>姑爹，胃癌，4月份刚去世。<br>舅舅，肺癌，16年去世。<br>堂弟岳母、隔壁华爷爷、隔壁健爹刚45岁胃癌已去世……</p><p><strong>这个世道怎么了？</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观看《我不是药神》后，一直想就这个话题写点东西，三十年的邻居突患病离世，更添些许压抑。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.xiaocc.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>linux hook机制研究</title>
    <link href="http://www.xiaocc.xyz/2018-09-08/linux%E4%B8%8Bhook%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/"/>
    <id>http://www.xiaocc.xyz/2018-09-08/linux下hook机制研究/</id>
    <published>2018-09-08T15:00:00.000Z</published>
    <updated>2018-09-18T03:46:09.984Z</updated>
    
    <content type="html"><![CDATA[<p>在研究C++中协程机制时，发现有些实现通过hack掉glibc的read、write等IO操作函数，以达到迁移协程框架时，最小化代码改动，遂小小研究一下linux下的hook机制。</p><a id="more"></a><h4><span id="引子">引子</span></h4><p>在linux下调用C库中的函数，主要是调用得 <code>libc.so.6</code> 这个动态链接库中的函数。<br>那么我们有没有办法让应用程序改调其它函数，而应用程序无感知，也就是hack掉应用程序中调用的某些函数。</p><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180908-232110.jpg" alt=""></p><p>由于是调用得动态链接库中函数，我们可以通过劫持该函数的方式引入额外处理。<br>例如通过劫持 <code>malloc</code>、<code>free</code> 来追踪内存使用情况等等。</p><h4><span id="实际操作">实际操作</span></h4><h5><span id="so文件">so文件</span></h5><p>我们先创建一个 <code>my_hook.c</code> 文件，并编写需要hook的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRY_LOAD_HOOK_FUNC(name) <span class="meta-keyword">if</span> (unlikely(!g_sys_##name)) &#123;g_sys_##name = (sys_##name##_t)dlsym(RTLD_NEXT,#name);&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (*<span class="keyword">sys_malloc_t</span>)(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sys_malloc_t</span> g_sys_malloc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TRY_LOAD_HOOK_FUNC(<span class="built_in">malloc</span>);</span><br><span class="line">    <span class="keyword">void</span> *p = g_sys_malloc(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in malloc hook function ...\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sys_free_t</span>)</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sys_free_t</span> g_sys_free = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TRY_LOAD_HOOK_FUNC(<span class="built_in">free</span>);</span><br><span class="line">    g_sys_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in free hook function ...\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用 <code>RTLD_NEXT</code> 来获取系统glibc的 <code>malloc</code> 函数地址，由于待会使用 <code>LD_PRELOAD</code> 来优先加载我们创建的 <code>so</code> 文件，因而系统的 <code>libc.so.6</code> 排在第二位，也就是 <code>next</code> 。</p><p>编译该文件生成一个 <code>so</code> 库：<br><code>gcc -fPIC -shared -o libmyhook.so my_hook.c -ldl</code></p><h5><span id="测试程序">测试程序</span></h5><p>接下来创建测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter main...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"returning to main...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"aa"</span>, <span class="string">"bb"</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hook strcmp\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not match\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="hack测试">hack测试</span></h4><p>对上面的测试程序，直接编译并运行<br><code>gcc -o main main.c</code><br><code>./main</code></p><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enter main...</span><br><span class="line">returning to main...</span><br><span class="line">not match</span><br></pre></td></tr></table></figure><p>可以清楚的看到，我们创建的 <code>so</code> 中函数并没有被调用到，也就是说<strong>hack失败</strong>！</p><p>等等！目前为止我们生成的 <code>so</code> 文件，并没有与测试程序产生关联，所以 <code>malloc</code>、<code>free</code> 函数没有被hack掉，理所应当。</p><p><strong>那么，如何才能让两者产生关联呢？</strong></p><p><strong>LD_PRELOAD</strong>这个环境变量，能够影响程序运行时候动态链接库的加载，可以通过设置其来优先加载某些库，进而覆盖掉某些函数。</p><p>这里只需要<strong>稍加更改运行方式</strong>：<br><code>LD_PRELOAD=./libmyhook.so ./main</code></p><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enter main...</span><br><span class="line">in malloc hook function ...</span><br><span class="line">returning to main...</span><br><span class="line">in free hook function ...</span><br><span class="line">not match</span><br></pre></td></tr></table></figure><p>大功告成，我们自定义的 <code>malloc</code>、<code>free</code> 被调用到，<strong>hack成功</strong>！</p><h4><span id="问题">问题</span></h4><p>在尝试对<code>strcmp</code> 函数进行hack时，按照如上方式并不能hack成功，通过查阅资料，原来编译器对很多函数进行了内联优化，并不会调用到 <code>so</code> 库中的函数，因而通过优先加载自定义动态库的方式不可行。<br>不过，可以在编译测试程序时，添加 <code>-fno-builtin-strcmp</code>，关闭 <code>strcmp</code> 函数的优化<br><code>gcc -o main main.c -fno-builtin-strcmp</code></p><p>以相同的方式运行测试程序：<br><code>LD_PRELOAD=./libmyhook.so ./main</code></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enter main...</span><br><span class="line">in malloc hook function ...</span><br><span class="line">returning to main...</span><br><span class="line">in free hook function ...</span><br><span class="line">in strcmp hook function ...</span><br><span class="line">hook strcmp</span><br></pre></td></tr></table></figure><h4><span id="参考资料">参考资料</span></h4><ul><li><a href="https://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="noopener">警惕UNIX下的LD_PRELOAD环境变量</a></li><li><a href="https://stackoverflow.com/questions/44606523/hook-strcmp-using-ld-preload-in-linux" target="_blank" rel="noopener">如何hack strcmp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在研究C++中协程机制时，发现有些实现通过hack掉glibc的read、write等IO操作函数，以达到迁移协程框架时，最小化代码改动，遂小小研究一下linux下的hook机制。&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>数据分页拉取机制探讨</title>
    <link href="http://www.xiaocc.xyz/2018-08-20/%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E6%8B%89%E5%8F%96%E6%9C%BA%E5%88%B6%E6%8E%A2%E8%AE%A8/"/>
    <id>http://www.xiaocc.xyz/2018-08-20/数据分页拉取机制探讨/</id>
    <published>2018-08-20T15:30:00.000Z</published>
    <updated>2018-09-18T03:44:08.502Z</updated>
    
    <content type="html"><![CDATA[<p>评论系统及各种时间线feeds系统，数据分页拉取机制讨论。</p><a id="more"></a><h4><span id="业务形态">业务形态</span></h4><p>分页拉取机制使用场景较多，在各种产品的评论模块、基于时间线feeds的产品中，均能见到其身影。<br>由于该机制使用的普遍性，本文分析常见实现中的问题，并探讨优化方案。</p><p>本文主要基于 <a href="https://developer.twitter.com/en/docs/tweets/timelines/guides/working-with-timelines" target="_blank" rel="noopener">拉取twitter时间线</a> 整理而来，可以认为是一篇阅读心得。</p><h4><span id="常见实现">常见实现</span></h4><p>一般是凭直觉设计API，请求参数包含 <code>page + count</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//请求第一页</span><br><span class="line">page = 0;</span><br><span class="line">count = 5;</span><br><span class="line"></span><br><span class="line">//请求第二页</span><br><span class="line">page = 1;</span><br><span class="line">count = 5;</span><br></pre></td></tr></table></figure><p>服务端根据 <code>page</code>、<code>count</code> 检索数据并返回，流程如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/20180820203459.png" alt=""><br>(图片借用自 twitter 博客图片，原图底部就缺失……)</p><h5><span id="问题">问题</span></h5><p>假如世界静止，一切不变的情况下，该机制运行良好。</p><p>如果，在第一次拉取后，时间线新插入2条数据，这时拉取第二页会发生什么情况。<br>如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/20180820204642.png" alt=""></p><p>服务端根据 <code>page = 1，count = 5</code>，从top往下找，到第5条（id 为 <code>Tweet 7</code>），获取count条数据，然后返回给前端。</p><p>可以明显发现问题：返回给前端的数据存在重复，id为<code>Tweet 7、Tweet 6</code>的两条数据，在client第一次拉取时，已经返回过该数据。<br>并且，在client两次拉取间隔内，新插入时间线的数据条数越多，发生重复返回的数据条数越多。</p><h5><span id="如何解决该问题">如何解决该问题</span></h5><p>思考一下，上面提到的拉取机制为什么会存在重复问题？</p><p>由于两次拉取均以实时<code>top</code> 作为基准线，而这个基准线会因为数据新增而浮动，所以后续拉取会出现数据重复问题。</p><p>我们能不能在第一次拉取后，返回一个 <code>cursor</code> 作为下次拉取的top，并以该top来获取数据？</p><h4><span id="max_id机制">max_id机制</span></h4><p>经过上面的思考，我们对server端返回的数据结构做改造，新增 <code>max_id</code>参数作为下次拉取的top。<br>如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/20180820210640.png" alt=""></p><p>client第一次拉取：不用传递 <code>max_id</code> 参数，server端返回数据的同时返回 <code>max_id</code> 参数。</p><p>client第二次拉取：以 <code>max_id + count</code> 作为参数，server端返回 <code>max_id</code> 之后的 <code>count</code> 条数据。</p><p>注意：该处有一个小优化，如果 <code>max_id</code> 是数字型，而不是字符串型，server端可以使用 <code>max_id - 1</code> 来过滤数据。<br><img src="http://p9ffylu89.bkt.clouddn.com/20180820211305.png" alt=""></p><p>至此，采用该机制，我们能很好的拉取<strong>存量数据</strong>。</p><h4><span id="since_id机制">since_id机制</span></h4><p>如上图，经过2次拉取后，id为 <code>Tweet 10</code> 到 <code>Tweet 1</code> 的数据均已返回给前端，用户如何获取新增的数据呢？</p><p>直接开始一个新的拉取周期，传递 <code>count = 5</code> 会有什么问题？</p><p>首次拉取会返回 <code>Tweet 12</code> 到 <code>Tweet 8</code> 的数据，其中有三条数据是已经处理过的！</p><p><strong>糟糕！除了让client端做id级别的去重，有别的处理办法吗？</strong></p><p>其实，我们可以记录上一个拉取周期的top，这样开始下一个周期的时候，只需要拉取当前top到上个周期top之间的数据，也即新增数据。</p><p>如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/20180820212548.png" alt=""></p><p>第二个拉取周期的第一次拉取，传递 <code>count</code>的同时，传递 <code>since_id</code> 参数，server端返回 <code>Tweet 18</code> 到 <code>Tweet 14</code> 的数据。</p><p>在第二次拉取的时候，server端根据 <code>max_id</code>、<code>since_id</code> 只会返回 <code>3</code> 条新增数据，而不会返回已经处理过的 <code>Tweet 10</code>、<code>Tweet 9</code>这两条数据。</p><h4><span id="结语">结语</span></h4><p>经过以上讨论，该优化机制可以很好的解决基于时间线的分页数据拉取问题。</p><p>但是，对于乱序数据，例如：评论根据点赞数而非时间排序，在用户两次分页拉取之间，由于其他用户的点赞操作，列表数据会上下波动、甚至发生剧烈变化，该 <code>max_id + since_id</code> 的机制并不能工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;评论系统及各种时间线feeds系统，数据分页拉取机制讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://www.xiaocc.xyz/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>频控设计与思考</title>
    <link href="http://www.xiaocc.xyz/2018-08-19/%E9%A2%91%E6%8E%A7%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>http://www.xiaocc.xyz/2018-08-19/频控设计与思考/</id>
    <published>2018-08-19T15:00:00.000Z</published>
    <updated>2018-09-18T03:43:29.275Z</updated>
    
    <content type="html"><![CDATA[<p>频控系统是后台服务自我保护的很重要的一个子系统，本文讨论几种常见的设计思路、并探讨使用redis进行频控设计中的相关问题</p><a id="more"></a><h4><span id="基本概念">基本概念</span></h4><h5><span id="什么是频控">什么是频控？</span></h5><p>从字面意义理解，<code>频控</code>就是频率控制，多用来对服务及接口进行保护，避免突发大流量请求冲击系统，进而引起系统雪崩，无法对外继续提供服务。<br>另外，也有一些业务层面利用该手段进行自我保护，例如：防刷系统，通过限制用户访问某种资源的频率来阻挡恶意请求。</p><h4><span id="如何进行频控">如何进行频控？</span></h4><p>频控级别主要分为两块：</p><ul><li>系统级频控</li><li>个人级频控</li></ul><p>以下将分别介绍实现方式与相关问题</p><h5><span id="系统级频控"><code>系统级频控</code></span></h5><p>该级别频控有多种实现如下：</p><ul><li>基于内存计数</li><li>基于内存的double-buffer计数</li><li>令牌桶</li></ul><p>1.基于内存计数的实现比较简单，伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uint32_t qps = 0;</span><br><span class="line">time_t monitor_start_time = 0;    //qps记录开始时间</span><br><span class="line"></span><br><span class="line">uint32_t add_qps()</span><br><span class="line">&#123;</span><br><span class="line">    time_t cur_time = ::time(NULL);</span><br><span class="line">    if (cur_time != monitor_start_time)</span><br><span class="line">    &#123;</span><br><span class="line">        //开始新1s的记录</span><br><span class="line">        qps = 1;</span><br><span class="line">        monitor_start_time = cur_time;</span><br><span class="line">        </span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return __sync_add_and_fecth(&amp;qps, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：判断该次请求是累加到记录周期，还是重新开始一次记录周期。</p><p>2.基于内存的double-buffer的实现，主要是优化<code>实现1</code>中的时间判断逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint32_t qps[2] = &#123;0, 0&#125;;</span><br><span class="line"></span><br><span class="line">uint32_t add_qps()</span><br><span class="line">&#123;</span><br><span class="line">    time_t cur_time = ::time(NULL);</span><br><span class="line">    </span><br><span class="line">    qps[(time + 1) % 2] = 0;</span><br><span class="line">    </span><br><span class="line">    return __sync_add_and_fecth(&amp;qps[time % 2], 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现利用<code>uint32_t qps[2]</code>的数组，分别记录当前秒的qps、下一秒的qps，对于每一次<code>add_qps</code>请求，将下一秒记录qps数据的槽位<code>清0</code>，累加当前秒的qps并返回结果。</p><p>3.基于令牌桶的实现，该实现以一定速度将令牌放入桶中，待请求到来，检查当前秒的已放行请求数量是否小于桶中令牌数量，否则，不予通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const uint32_t qps_limit = 9527;</span><br><span class="line">uint64_t start_time_ms = 0;</span><br><span class="line">uint32_t cur_pass_count = 0;</span><br><span class="line"></span><br><span class="line">bool check_pass_qps()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t cur_time_ms = getTimeMS();</span><br><span class="line">    </span><br><span class="line">    if (!check_in_same_second(cur_time_ms, start_time_ms))</span><br><span class="line">    &#123;</span><br><span class="line">        //清空数据，开始新的周期</span><br><span class="line">        start_time_ms = getStartMS(cur_time_ms);</span><br><span class="line">        cur_pass_count = 1;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //计算桶中令牌数量</span><br><span class="line">    uint32_t can_pass_count = time_sub(cur_time_ms, start_time_ms) * qps_limit / 1000.0;</span><br><span class="line">    </span><br><span class="line">    //不予通过</span><br><span class="line">    if (cur_pass_count &gt;= can_pass_count)</span><br><span class="line">    &#123;</span><br><span class="line">        retun false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ++cur_pass_count;</span><br><span class="line">    retun true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该伪代码中设置控制粒度为ms，也就是 qps_limit / 1000.0的由来。</p><h5><span id="用户级频控"><code>用户级频控</code></span></h5><p>主要有基于内存的设计，包括KV存储、Key过期淘汰策略等，这些基本需求与当今热门的NoSql系统<code>redis</code>的功能一样，因而可以用其来进行频控。</p><h4><span id="redis频控">redis频控</span></h4><p>官方有一个针对ip进行频控的例子：<a href="https://redis.io/commands/incr" target="_blank" rel="noopener">地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">ts = CURRENT_UNIX_TIME()</span><br><span class="line">keyname = ip + &quot;:&quot; + ts</span><br><span class="line">current = GET(keyname)</span><br><span class="line">IF current != NULL AND current &gt; 10 THEN</span><br><span class="line">    ERROR &quot;too many requests per second&quot;</span><br><span class="line">ELSE</span><br><span class="line">    MULTI</span><br><span class="line">        INCR(keyname,1)</span><br><span class="line">        EXPIRE(keyname,10)</span><br><span class="line">    EXEC</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>其中key的设计有两种方案：ip + ts、ip</p><p>对第一种key的方案<code>ip + ts</code>样例中采用 <code>MULTI + EXEC</code>对命令进行包裹，以解决单独调用<code>INCR</code>后<code>EXPIRE</code>崩溃的问题。可以思考一下，在当前这种key的设计方式下，由于key是<code>ip + ts</code>，就算由于小概率崩溃，导致<code>EXPIRE</code>未执行，对系统无根本性影响，不影响该ip下一秒的调用及频控。</p><p>而第二种key的方案<code>ip</code>，如果不采用<code>MULTI + EXEC</code>对命令进行包裹，如果<code>EXPIRE</code>未执行，完蛋，由于是ip维度进行计数，如果该ip超频，由于没有时机去清理该key，导致该ip超频后一直处于超频状态，永远无法请求相关服务。</p><p>同时官方样例中也说明，可以采用<code>lua脚本</code>的形式来执行命令，因为server端崩溃的概率极低，基本不可能出现该特殊情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local current</span><br><span class="line">current = redis.call(&quot;incr&quot;,KEYS[1])</span><br><span class="line">if tonumber(current) == 1 then</span><br><span class="line">    redis.call(&quot;expire&quot;,KEYS[1],1)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4><span id="结语">结语</span></h4><p>在之前的paypal支付系统中，由于兑换码是无记名设计，出于安全角度考虑，对ip的请求进行频控，以打击遍历兑换码空间进而恶意兑换的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;频控系统是后台服务自我保护的很重要的一个子系统，本文讨论几种常见的设计思路、并探讨使用redis进行频控设计中的相关问题&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://www.xiaocc.xyz/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>一点感悟</title>
    <link href="http://www.xiaocc.xyz/2018-08-06/%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/"/>
    <id>http://www.xiaocc.xyz/2018-08-06/一点感悟/</id>
    <published>2018-08-06T15:30:00.000Z</published>
    <updated>2018-09-18T03:46:59.282Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了工作，博客也停更好久，有点懈怠，需要坚持。</p><a id="more"></a><h4><span id="一点唠叨">一点唠叨</span></h4><p>由于各种原因，再次折腾了一把，从上家公司离职，换了如今这家公司。</p><p>技术栈和业务都变了，才发觉IT技术的变化真是日新月异，你稍微不进步，很快就被落下。</p><p>新公司的工作语言是Java，这门语言当初一直没有下决心好好学习、深入了解，对之抱有技术的偏见和固执，一直守着C++不放，如今业内已很少有公司依然在使用它。</p><p>要么是Java，要么使用go，C++虽说运行效率高，但是对开发人员要求极高，加之目前硬件性能突飞猛进，对程序性能要求没那么高，只要是堆机器能解决的问题，就不是问题。</p><p>反而业务开发效率、迭代速度、版本发布流程、服务扩容流程、监控等等更为重要。</p><p>使用C++需要很多轮子的配合，网络库、服务发现机制、负载均衡和容灾、监控、配置系统等等，面对于目前火热的大数据相关领域，如HBase、HDFS、Hive等等，也是有心无力，还是使用Java开发业务更为方便。</p><p>Java语法不算复杂，可是由于反射机制导致的相关生态很多，例如dubbo，spring，mybatic等等，这些甚至于比语言本身还要复杂，如果这些组件不了解，开发现代Java项目会很棘手。</p><h4><span id="写作计划">写作计划</span></h4><p>前几天看博客，对一句话感触很深：</p><blockquote><p><strong>看书如果不思考，那不是在看书，是在背书！</strong></p></blockquote><p>接下来的时间，我将以一个初学者的心态、一切归零，深入学习Java语言，包括基本语法、相关生态等。</p><p>即将写的博客主题内容：</p><ul><li>使用redis进行ip频控</li><li>评论分页拉取设计</li><li>linux hook机制</li><li>future与promise编程模型</li><li>单点登录SSO设计</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近换了工作，博客也停更好久，有点懈怠，需要坚持。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.xiaocc.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>定时器的设计</title>
    <link href="http://www.xiaocc.xyz/2018-06-23/%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.xiaocc.xyz/2018-06-23/定时器的设计/</id>
    <published>2018-06-23T05:30:00.000Z</published>
    <updated>2018-09-18T03:43:43.392Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间学习raft论文，自己造了个服务框架的轮子，网络通信采用ZMQ，还需要设计定时器，以实现周期性功能，如心跳发布。</p><a id="more"></a><p>定时器的设计有多种方案，常见的实现有以下两种：</p><h4><span id="周期遍历">周期遍历</span></h4><p>该方案通过在event loop中周期性检查是否到达timer的触发时间，如果到达，则调用timer的处理函数。<br>而timer的管理可以通过堆、map、时间轮等多种形式，按照timer的触发时间排序。<br>这样当找到第一个触发时间比当前时间大的timer，那么其之后的timer都不需要检查是否应该触发，该轮触发检查可以直接结束。</p><p>伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Event::run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*注意：该处等待时间不能填-1，否则下面定时器无法周期性触发*/</span></span><br><span class="line">        epoll_wait(....);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*处理网络事件*/</span></span><br><span class="line">        <span class="keyword">do</span> something ...</span><br><span class="line">        </span><br><span class="line">        now = get_now_time();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*all_timer管理所有需要触发的timer，按照触发时间，从小至大排序*/</span></span><br><span class="line">        <span class="keyword">for</span> item in all_timer:</span><br><span class="line">            <span class="keyword">if</span> item.expire_time &lt;= now:</span><br><span class="line">                <span class="comment">/*调用timer的处理函数*/</span></span><br><span class="line">                item.call_back()</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/*由于定时器按照触发时间排序，该item之后的timer均未到触发时间*/</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案设计简单、容易实现，但是与事件驱动框架不协调，显得比较怪异。</p><h4><span id="timer_fd">timer_fd</span></h4><p>该方案通过linux的timer_fd机制，将定时器统一通过事件框架触发。<br>通过timerfd_create能够创建一个定时器fd，再通过timerfd_settime设置超时时间，当超时时间到达，该fd上即可收到read事件，然后再查找all_timer中需要触发的timer。</p><p>伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Event:init()</span><br><span class="line">&#123;</span><br><span class="line">    tfd_ = timerfd_create(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将定时器fd加入事件框架，统一处理*/</span></span><br><span class="line">    add_event(tfd_, EV_READ, timer_call_back);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Event::run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*注意，该处等待超时时间可以填入-1，定时器不再单独处理*/</span></span><br><span class="line">    epoll_wait(....);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*处理事件*/</span></span><br><span class="line">    <span class="keyword">do</span> something ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Event::timer_call_back()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*read事件*/</span></span><br><span class="line">    read(tfd_, ...)</span><br><span class="line">    </span><br><span class="line">    now = get_now_time();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*处理需要触发的timer*/</span></span><br><span class="line">    <span class="keyword">do</span> something</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*调整tfd_下次超时时间*/</span></span><br><span class="line">    timerfd_settime(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与方案一的区别：</p><ul><li>整体通过事件触发，模型统一</li><li>方案一中，需要定时检查是否可以触发timer，就算任何一个timer的触发时间未到，该检查步骤无法避免</li><li>方案二中，一部分timer触发后，可以直接获取下一个待触发的timer的触发时间，从而设置tfd_的超时，在超时时间到达之前，tfd_不会被事件框架触发</li></ul><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180623-142645.jpg" alt=""><br>如图所示：<br>方框中数字为timer需要触发的时刻，假设当前时刻为 <code>3</code> ，那么前4个timer需要触发，下一个待触发的timer的时刻为 <code>8</code>，所以我们可以调整tfd_相对超时时间为 <code>5</code>，在那之前tfd_上都不会有read事件，当然也不会触发事件框架。</p><h4><span id="几个关键问题">几个关键问题</span></h4><h5><span id="定时器模式">定时器模式</span></h5><p>定时器有两种常用模式</p><ul><li>一次性定时器，设置在某个时间点触发一次，可以称为 <code>run_after</code></li><li>周期性定时器，需要周期性触发，可以称为 <code>run_every</code></li></ul><p>我们看看这两种定时器如何实现<br>两者其实有相似之处，所谓的周期性定时器，只不过是该次timer触发以后，需要再次添加一个timer到管理器中以待下次触发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Event::timer_call_back()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*read事件*/</span></span><br><span class="line">    read(tfd_, ...)</span><br><span class="line">    </span><br><span class="line">    now = get_now_time();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*从all_timer中取出所有需要触发的timer，注意：将这些timer从all_timer中删除*/</span></span><br><span class="line">    expired_timers = get_all_expired_timers(now);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> item in expired_timers:</span><br><span class="line">        <span class="comment">/*调用timer处理函数*/</span></span><br><span class="line">        item.call_back()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/*添加周期性定时器，以待下次触发*/</span></span><br><span class="line">    <span class="keyword">for</span> item in expired_timers:</span><br><span class="line">        <span class="keyword">if</span> item.repeated:</span><br><span class="line">            add_timer(next_expire_time, ....)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*调整tfd_下次超时时间*/</span></span><br><span class="line">    next_expire_time = get_next_expire_time();</span><br><span class="line">    </span><br><span class="line">    timerfd_settime(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="在timer处理函数中再次添加timer">在timer处理函数中再次添加timer</span></h5><p>以上讨论均没有考虑一个问题，如果在timer的响应函数中添加一个timer，会发生什么？</p><p>先看看方案一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item in all_timer:</span><br><span class="line">    <span class="keyword">if</span> item.expire_time &lt;= now:</span><br><span class="line">        <span class="comment">/*调用timer的处理函数*/</span></span><br><span class="line">        item.call_back()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">/*由于定时器按照触发时间排序，该item之后的timer均未到时间*/</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>由于timer的添加是在遍历 <code>all_timer</code> 的过程中，如果直接添加到 <code>all_timer</code> 中会引起该存储结构改变，引起迭代器失效，进而导致进程挂掉。</p><p>所以，可以在遍历开始之前，设置标记位 <code>run_in_timer_loop</code>，同时在 <code>add_timer</code> 中特殊处理，如果当前设置了该标记位，那么将需要添加的timer暂存到一个临时存储，待循环遍历完毕之后，统一进行添加处理。</p><p>再看看方案二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从all_timer中取出所有需要触发的timer，注意：将这些timer从all_timer中删除*/</span></span><br><span class="line">expired_timers = get_all_expired_timers(now);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> item in expired_timers:</span><br><span class="line">    <span class="comment">/*调用timer处理函数*/</span></span><br><span class="line">    item.call_back()</span><br></pre></td></tr></table></figure><p>可以看到，对于需要触发的timer，并不是直接在 <code>all_timer</code> 中进行遍历检查触发，而是将其已经从 <code>all_timer</code> 中剥离，因而在 <code>item.call_back()</code> 中调用 <code>add_timer</code> ，可以将timer直接添加到 <code>all_timer</code>，而不需要进行额外特殊处理。</p><p>参考资料：</p><ul><li>muduo定时器的设计 <a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">https://github.com/chenshuo/muduo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间学习raft论文，自己造了个服务框架的轮子，网络通信采用ZMQ，还需要设计定时器，以实现周期性功能，如心跳发布。&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://www.xiaocc.xyz/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>2018年端午小记</title>
    <link href="http://www.xiaocc.xyz/2018-06-19/2018%E5%B9%B4%E7%AB%AF%E5%8D%88%E8%8A%82/"/>
    <id>http://www.xiaocc.xyz/2018-06-19/2018年端午节/</id>
    <published>2018-06-19T14:30:00.000Z</published>
    <updated>2018-09-18T03:44:18.452Z</updated>
    
    <content type="html"><![CDATA[<p>2018年端午与亲戚团聚过节，特此小记。</p><a id="more"></a><p>由于老婆回岳阳老家，我一个人在深圳，没什么安排，广州有几个亲戚，约了多次，终于决定去见见他们，一起过节。</p><h4><span id="通行方案">通行方案</span></h4><p>网上查好地点，广州黄埔，属于广州的郊区。</p><ul><li>如果坐火车，则需要从广州市区坐一个多小时地铁才能到达黄埔区，火车等待及运行时间约2小时。</li><li>如果坐大巴，直接到达，总耗时约1.5小时，简单直接。</li></ul><p>可见，有些时候高大上的东西，不一定划算，原始的东西，可能有意想不到的效果。<br>做软件系统设计也是如此，不要追求系统华丽而导致过度设计，<code>KISS</code> 原则效果更好，一方面利于设计开发，另一方面利于系统维护。</p><h4><span id="出发">出发</span></h4><p>八点起床，街边小店吃完早餐，由于地图显示汽车客运站不远，决定走路过去。<br>走啊走，走啊走。。。<br>终于走到，耗时20min。<br>购票，师傅，麻烦买一张到广州黄埔的车票，不好意思，这里没有到黄埔的汽车，你得到总站坐车。<br>完蛋，功课信息有误。<br><strong>怎么办？</strong><br>迅速调整思路，旁边有摩的，直接谈价格，走人。<br>软件设计与运行中，会出现各种各样的问题。如果在问题出现之前，就能考虑到该问题与解决方案，这叫做 <code>fault tolerance</code>。其它突发问题，就得转变思路，先解决问题，再排查原因，优先恢复服务。面对于线上突发问题，例如服务core掉，如果问题根源不能在短时间内分析解决，可以考虑其它方案，例如调整配置文件、将该机器从集群中踢掉等等方式，第一时间恢复服务。我碰到过一些同事，面对于该事件，思路一直陷在排查问题原因，而没有想到及时恢复服务。</p><h4><span id="表弟一家">表弟一家</span></h4><p>表弟比我小4岁，却先当了爸爸，他到车站接我，晒黑得跟碳似的，这是生活留下的印记。<br>小侄女长得很可爱，一岁多点，爱动，好奇心强，不怕生人，我刚到，她就把玩具全部搬出来，让我陪她玩，我也算是提前上课了，哈哈。<br>吃完中饭，她就开始睡午觉，我们几个人则谈论着今年的境遇。<br>小侄女睡醒后，带着她出去遛弯，刚好旁边有划龙舟训练的，她高兴地不得了，踉踉跄跄的往前跑。<br>走路看似不稳、要摔倒，其实不然，经我观察，她有很强的自我调节能力，会调整重心把自己稳住。高一点的台阶，则是手脚并用着爬上去，地上的小蜗牛，也够她看好久的。</p><p>是什么让我们不愿停下匆匆的脚步，对生活不再好奇，背负着一身皮囊，上班、下班，无止境。<br>生活的乐趣，本来的意义，又在哪里？<br>人生短短几十年。<br>又让我想起了那句台词：<code>成年人的生活里，没有容易二字</code>。</p><p><strong>愿小侄女健康成长，欢声笑语伴其一生！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年端午与亲戚团聚过节，特此小记。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.xiaocc.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>CPU Cache与一致性</title>
    <link href="http://www.xiaocc.xyz/2018-06-10/cpu%E7%9A%84cache%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://www.xiaocc.xyz/2018-06-10/cpu的cache与一致性/</id>
    <published>2018-06-10T02:00:00.000Z</published>
    <updated>2018-09-18T03:45:20.271Z</updated>
    
    <content type="html"><![CDATA[<p>现代计算机多核CPU的多级缓存构成与一致性算法</p><a id="more"></a><p>最近看了CPU Cache相关的资料，涉及Cache的构成及一致性解决办法，现总结并记录</p><h4><span id="存储层次构成">存储层次构成</span></h4><p>由于CPU运行速度非常快，而主内存相对来说很慢，因此CPU并不直接访问主内存，两者之间有多次缓存结构。</p><p>存储层次，如下图：</p><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-101826.jpg" alt=""></p><p><em>图片来源：<a href="https://mp.weixin.qq.com/s/y1NSE5xdh8Nt5hlmK0E8Og" target="_blank" rel="noopener">内核月谈——CPU Cache Line伪共享问题的总结和分析</a></em></p><p>从上图可以看出，register与主memory访问速度相差约<strong>40倍</strong>，而磁盘访问一次耗时大约5ms，主memory与其访问速度相差约<strong>100倍</strong>。</p><h4><span id="cpu的cache架构">CPU的Cache架构</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-103044.jpg" alt=""></p><p><em>图片来源：<a href="https://mp.weixin.qq.com/s/y1NSE5xdh8Nt5hlmK0E8Og" target="_blank" rel="noopener">内核月谈——CPU Cache Line伪共享问题的总结和分析</a></em></p><p>如上图所示：<br>一个物理CPU有四个物理core，每个物理core有两个HT(Hyper Thread)<br>每个物理core内的所有HT，共享：L1-指令cache、L1-数据cache、L2-cache<br>所有物理core共享L3-cache</p><h4><span id="cache的一致性问题">Cache的一致性问题</span></h4><p>通过了解CPU的Cache架构可以发现，每个物理CPU都有自己的Cache，如何解决Cache的不一致问题。</p><h5><span id="不一致问题的产生">不一致问题的产生</span></h5><p>假设多核CPU在每个CPU内不单独设置Cache，而是所有物理CPU共享一个Cache，这样全部CPU的读写操作均串行通过同一个Cache。</p><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-104418.jpg" alt=""></p><p>这样，当其中一个CPU进行写操作，而另一个CPU进行读操作，总是能读到正确的值。<br>但是，所有CPU共享同一个Cache的设计，会极大的降低系统的运算速度，因为所有CPU均需要串行的访问Cache以获取数据，大部分时间均在等待Cache使用权。</p><p>如果引入多个Cache，就会涉及到Cache的一致性问题。<br>所以，Cache的一致性问题，不是因为多CPU导致，而是多Cache导致。</p><h5><span id="一致性协议">一致性协议</span></h5><p>参考WIKI关于Cache一致性的解释：<a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache_coherence</a><br>常用的一致性协议有 <code>snooping</code> 协议，也称为窥探协议。</p><p>该协议对总线上的操作进行监听，例如：一个CPU_A，对变量X进行了写操作，但是还未回写到memory，而另外一个CPU_B需要读取变量X，这时如果直接从memory获取变量X的值，是过期值，<br>这时CPU_A能够从总线上窥探到该次读操作，其把X值写入memory，而CPU_B的读操作由于未得到响应，其会重新发起读请求，这时就能从memory读取到最新值。</p><p>以上只是简单讲解，具体有 <code>MESI</code> 协议，其把Cache分为几个状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I: Invalid（无效），该CPU中该Cache字段失效</span><br><span class="line">S: Shared（共享），多个CPU的Cache均共享该数据</span><br><span class="line">E: Exclusive（独占），数据只在该CPU独有，其它CPU变为Invalid状态</span><br><span class="line">M: Modified（已修改），与E状态类似，但是数据已经被修改，在其变为Invalid状态时，需要先将数据回写到内存</span><br></pre></td></tr></table></figure><p>状态机如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180610-110431.jpg" alt=""></p><p><em>图片来源：<a href="http://www.pandan.xyz/2016/09/23/mesi%20%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">MESI 缓存一致性协议</a></em></p><p>参考文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/y1NSE5xdh8Nt5hlmK0E8Og" target="_blank" rel="noopener">CPU Cache Line伪共享问题的总结和分析</a></li><li><a href="http://www.pandan.xyz/2016/09/23/mesi%20%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">MESI 缓存一致性协议</a> </li><li><a href="http://www.infoq.com/cn/articles/cache-coherency-primer/" target="_blank" rel="noopener">缓存一致性（Cache Coherency）入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代计算机多核CPU的多级缓存构成与一致性算法&lt;/p&gt;
    
    </summary>
    
      <category term="编程理论" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>服务框架设计</title>
    <link href="http://www.xiaocc.xyz/2018-06-03/%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.xiaocc.xyz/2018-06-03/服务框架设计/</id>
    <published>2018-06-03T09:30:00.000Z</published>
    <updated>2018-09-18T03:43:33.859Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究raft论文，想动手实现一下，但是手上没有合适的网络框架，花了几天造了个轮子。</p><a id="more"></a><h4><span id="起因">起因</span></h4><p>raft论文去年看过一遍，最近重读，发现上次阅读的东西，一点都不记得。。。<br>决定这次跟着论文简单的实现一遍，加深理解，手上没有合适的网络框架，学go呢，又来不及，花了几天造了个轮子，总算是跑起来了。</p><p><strong>设计思想参考公司内部网络框架，将其部分精简</strong></p><h4><span id="框架设计">框架设计</span></h4><p>底层网络框架依托ZMQ，采用事件驱动形式，client与server端交互图如下：<br><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-174640.jpg" alt=""></p><h4><span id="worker_dispatcher">worker_dispatcher</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-175915.jpg" alt=""><br>以ZMQ_ROUTER的形式对接监听tcp端口，将client请求通过内部inproc的socket负载均衡的转发给worker进行处理<br>数据转发给worker时，将ZMQ_ROUTER的identity帧一并发送，这样待worker处理完毕，通过inproc的socket返回数据时，ZMQ_ROUTER能将数据返回给请求对应的client</p><h4><span id="worker">worker</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-181150.jpg" alt=""><br>创建ZMQ_DEALER的inproc的socket，并与worker_dispatcher连接，以此处理其转发过来的client的请求<br>当其要请求其它服务时，统一通过client_dispatcher对外处理</p><h4><span id="client_dispather">client_dispather</span></h4><p><img src="http://p9ffylu89.bkt.clouddn.com/Jietu20180603-201920.jpg" alt=""><br>其通过inproc的socket接收worker中对其它服务的请求，并管理对外连接，释放长时间不使用的连接等<br>待下游服务返回数据，其通过inproc的socket返回给对应的worker</p><p><em>下次讲一下定时器的设计</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究raft论文，想动手实现一下，但是手上没有合适的网络框架，花了几天造了个轮子。&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://www.xiaocc.xyz/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>内存检测工具AddressSanitizer</title>
    <link href="http://www.xiaocc.xyz/2018-05-28/AddressSanitizer/"/>
    <id>http://www.xiaocc.xyz/2018-05-28/AddressSanitizer/</id>
    <published>2018-05-28T11:30:00.000Z</published>
    <updated>2018-09-18T03:46:22.612Z</updated>
    
    <content type="html"><![CDATA[<p>Google出品的内存检测工具AddressSanitizer介绍与分析</p><a id="more"></a><h4><span id="介绍">介绍</span></h4><p>AddressSanitizer是Google旗下的一个内存问题检测工具，项目地址：<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizer</a></p><p>它与传统的内存问题检测工具，例如 <code>Valgrind</code> ，有何区别？</p><p>用过 <code>Valgrind</code> 的朋友应该都清楚，其会极大的降低程序运行速度，大约降低10倍，而 <code>AddressSanitizer</code> 大约只降低2倍，这是什么概念，果然是Google大法好！</p><h4><span id="具体使用">具体使用</span></h4><p>在LLVM及高版本编译器中已经自带了该工具，编译时添加 <code>-fsanitize=address</code> 选项。<br>正常运行程序，如有内存相关问题，即会打印异常信息。</p><h4><span id="工具原理">工具原理</span></h4><p>工具用法比较简单，这里想重点说说该工具的原理。</p><p>可参考文档：<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm</a></p><p>由于是内存检测工具，其需要对每一次内存读写操作进行检查：<br><code>*address = ...;  // or: ... = *address;</code></p><p>进行如下的逻辑判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsPoisoned(address)) &#123;</span><br><span class="line">  ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br><span class="line">*address = ...;  <span class="comment">// or: ... = *address;</span></span><br></pre></td></tr></table></figure><p>如果指针读写异常，则统计及打印异常信息，可见整个工具的关键在于 <code>IsPoisoned</code> 如何实现，该函数需要快速而且准确。</p><h4><span id="内存映射">内存映射</span></h4><p>其将内存分为两块：</p><ul><li>主内存：程序常规使用</li><li>影子内存：记录主内存是否可用等meta信息</li></ul><p>如果有个函数 <code>MemToShadow</code> 可以根据主内存地址获取到对应的影子内存地址，那么内存检测的实现，可以改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shadow_address = MemToShadow(address);</span><br><span class="line"><span class="keyword">if</span> (ShadowIsPoisoned(shadow_address)) &#123;</span><br><span class="line">  ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="影子内存">影子内存</span></h4><p><code>AddressSanitizer</code> 用 1 byte 的影子内存，记录主内存中 8 bytes 的数据。</p><p>为什么是 8 bytes ，因为malloc分配内存是按照 8 bytes 对齐。</p><p>这样，8 bytes 的主内存，共构成 9 种不同情况：</p><ul><li>8 bytes 的数据可读写，影子内存中的value值为 <strong>0</strong></li><li>8 bytes 的数据不可读写，影子内存中的value值为 <strong>负数</strong></li><li>前 k bytes 可读写，后 (8 - k) bytes 不可读写，影子内存中的value值为 <strong>k</strong> 。</li></ul><p>如果 <code>malloc(13)</code> ，根据 8 bytes 字节对齐的原则，需要 2 bytes 的影子内存，第一个byte的值为 0，第二个byte的值为 5。</p><p>这时，整个判断流程，可改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">byte *shadow_address = MemToShadow(address);</span><br><span class="line">byte shadow_value = *shadow_address;</span><br><span class="line"><span class="keyword">if</span> (shadow_value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (SlowPathCheck(shadow_value, address, kAccessSize)) &#123;</span><br><span class="line">    ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the cases where we access first k bytes of the qword</span></span><br><span class="line"><span class="comment">// and these k bytes are unpoisoned.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SlowPathCheck</span><span class="params">(shadow_value, address, kAccessSize)</span> </span>&#123;</span><br><span class="line">  last_accessed_byte = (address &amp; <span class="number">7</span>) + kAccessSize - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (last_accessed_byte &gt;= shadow_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="主内存映射到影子内存">主内存映射到影子内存</span></h4><p><code>MemToShadow</code> 采用简单直接映射的方式<br>64-bit <code>Shadow = (Mem &gt;&gt; 3) + 0x7fff8000;</code><br>32-bit <code>Shadow = (Mem &gt;&gt; 3) + 0x20000000;</code></p><h4><span id="例子">例子</span></h4><p>如何检测数组访问越界：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">8</span>];</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddressSanitizer</code> 将其改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> redzone1[<span class="number">32</span>];  <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">8</span>];          <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">char</span> redzone2[<span class="number">24</span>];</span><br><span class="line">  <span class="keyword">char</span> redzone3[<span class="number">32</span>];  <span class="comment">// 32-byte aligned</span></span><br><span class="line">  <span class="keyword">int</span>  *shadow_base = MemToShadow(redzone1);</span><br><span class="line">  shadow_base[<span class="number">0</span>] = <span class="number">0xffffffff</span>;  <span class="comment">// poison redzone1</span></span><br><span class="line">  shadow_base[<span class="number">1</span>] = <span class="number">0xffffff00</span>;  <span class="comment">// poison redzone2, unpoison 'a'</span></span><br><span class="line">  shadow_base[<span class="number">2</span>] = <span class="number">0xffffffff</span>;  <span class="comment">// poison redzone3</span></span><br><span class="line">  ...</span><br><span class="line">  shadow_base[<span class="number">0</span>] = shadow_base[<span class="number">1</span>] = shadow_base[<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// unpoison all</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：<br><img src="http://p9ffylu89.bkt.clouddn.com/20180528214308.png" alt=""><br>将 <code>char a[8]</code> 两侧用 <code>redzone</code> 包夹，这样数组访问越界时，立马能够侦测。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google出品的内存检测工具AddressSanitizer介绍与分析&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>hbase schema design阅读笔记</title>
    <link href="http://www.xiaocc.xyz/2018-05-28/hbase_schema_design/"/>
    <id>http://www.xiaocc.xyz/2018-05-28/hbase_schema_design/</id>
    <published>2018-05-28T09:00:00.000Z</published>
    <updated>2018-09-18T03:47:07.256Z</updated>
    
    <content type="html"><![CDATA[<p>图床终于弄好，可以图文结合了<br>上传一篇以前的阅读笔记，关于hbase的rowkey设计的<br><a id="more"></a></p><p>hbase schema design <a href="http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf" target="_blank" rel="noopener">文章pdf地址</a></p><h5><span id="hbase-存储视图">hbase 存储视图</span></h5><p><img src="http://p9ffylu89.bkt.clouddn.com/6397885A-85FF-4D6D-AB04-E2D0BA46045A.png" alt=""></p><p><strong>文中，以Twitter关注模式为例，讲解存储设计</strong></p><h5><span id="场景分析">场景分析</span></h5><p>首先分析问题，读、写场景有哪些？</p><p><strong>读：</strong></p><ol><li>用户A关注了哪些用户？</li><li>检查用户A是否关注用户B</li><li>哪些用户关注了用户A？</li></ol><p><strong>写：</strong></p><ol><li>用户A关注用户B</li><li>用户A取消关注用户B</li></ol><p>循序渐进的讲解存储设计：</p><p>1.简单的列表存储，用下标做column qualifie，用户名做value，但是读2问题，需要遍历列表解决。同时，新增关注时，不知道下一个下标数值，需要遍历获取。<br><img src="http://p9ffylu89.bkt.clouddn.com/A1223DE1-8F32-46A8-B5B5-464BD723F202.png" alt=""></p><p>2.针对设计1的问题，增加一个额外的column（count），记录当前关注用户数量，但是HBase多API之间的并发问题不容易解决。同时写2问题，用户取消关注B，需要遍历整个列表来delete，同时删除之后的空洞问题无法解决（count数量与下一个下标值无法对应）<br><img src="http://p9ffylu89.bkt.clouddn.com/0D529E1B-23ED-4450-BE1C-6B2D45F1FF27.png" alt=""></p><p>3.针对HBase的column是可变的，非预定义的，同时是bytes []的，所以可以把关注的用户名B作为column qualifier。<br><img src="http://p9ffylu89.bkt.clouddn.com/7DFEF1A3-4124-4681-B3C3-DC858C7DD1EE.png" alt=""></p><p>这个设计可以很方便的查找用户AK关注了哪些用户，但是针对于哪些用户关注了AK，只能遍历整个table来查找。</p><p>4.针对HBase的rowkey是bytes []，同时是有序的、且方便scan，可以存储一些信息在rowkey中。<br><img src="http://p9ffylu89.bkt.clouddn.com/AEB8F7E0-7711-447C-9E70-7FB4691F9A0E.png" alt=""><br><img src="http://p9ffylu89.bkt.clouddn.com/0A2ED8B4-E54A-4E7E-845A-78DA718B84A2.png" alt=""></p><p>将rowkey设计为 follower + followed形式</p><p>如何查找AK关注了哪些用户——通过扫描HBase的rowkey符合 AK* 模式</p><p>如何查找哪些用户关注了AK——通过扫描HBase的rowkey符合 *AK 模式</p><p>5.如何解决用户名长度不一致问题，可以选择归一化用户名或者采用保存md5的形式<br><img src="http://p9ffylu89.bkt.clouddn.com/CE8EFA5B-299D-43F9-8EBF-E73D4B79AA6B.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图床终于弄好，可以图文结合了&lt;br&gt;上传一篇以前的阅读笔记，关于hbase的rowkey设计的&lt;br&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://www.xiaocc.xyz/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>极低概率bug排查</title>
    <link href="http://www.xiaocc.xyz/2018-05-26/%E6%9E%81%E4%BD%8E%E6%A6%82%E7%8E%87bug%E6%8E%92%E6%9F%A5/"/>
    <id>http://www.xiaocc.xyz/2018-05-26/极低概率bug排查/</id>
    <published>2018-05-26T10:00:00.000Z</published>
    <updated>2018-09-18T03:46:52.430Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个bug，需要运行百万次才触发一次，该如何排查这个问题？</p><a id="more"></a><h4><span id="起因">起因</span></h4><p>前几天在内部论坛看到一篇技术贴，关于一个极低概率触发的bug，如何分析与排查。</p><p>借此机会，写一下阅读心得。</p><p>知乎上有一个段子，说是一个面试官出了道题，如果一个bug运行百万次才能触发一次，该如何排查？<br>面试者当场懵逼，很多人讨伐面试官，说这个题目就是故意为难人，考察不到实质内容。</p><p>其实这个问题，挺有意思，可以考察被面试者，在碰到不熟悉的领域以及高困难环境下的分析与应对情况。</p><h4><span id="现象">现象</span></h4><p>文中，作者做https的通用接入平台，每天数百亿次的请求，需要高性能，因而对nginx的底层代码更改很多，特别是握手那块逻辑。<br>自测没问题，线上小流量测试，总是跑个一天左右，会出现进程core的情况。</p><p>如何解决这个棘手的问题？</p><h4><span id="core文件">core文件</span></h4><p>要解决一个bug，最好能够拿到bug触发后的现场，也就是coredump文件，这是进程挂掉最后的遗言。</p><p>也有高手，通过逐行看代码来进行排查，但是面对代码量几十万行的项目，犹如大海捞针。</p><p>开启系统core文件生成后，看看能不能从core文件中有所发现。</p><p>由于nginx的网络框架，数据read后，可能走两个不同的分支逻辑，例如第一次接收数据后，请求包不完整，调用函数A，第二次接收数据后，整个请求包完整，调用函数B，这个时候core文件产生，函数调用栈中只能看到函数B，没有函数A的相关信息，而问题可能是函数A导致，所以整个coredump文件分析下来，没有直接发现问题。</p><p>只是有一个点比较极怪，有一个不可能为空的指针，居然出现为空的情况，这个指针是会话创建之初构建的。</p><h4><span id="复现bug">复现bug</span></h4><p>要排查一个bug，如果能够将bug复现，甚至于必现，那将极大的加快排查速度，可以对关键路径添加日志，然后测试新代码。</p><p>可是一个极低概率触发的bug，如何复现？</p><p>可以自己构造请求以复现，作者特地开发压测工具，以几万/秒的请求量进行压测，晚上开启压测工具，第二天上午就可以收到core文件。</p><h4><span id="排查bug">排查bug</span></h4><p>虽然有了复现bug的方法，也有了core文件，可是从core文件中并不能分析出来有价值的信息。</p><p>那只能通过修改代码，添加日志的方式来进行排查。</p><p>通过添加日志来进行排查，就有讲究了。</p><p>如果日志过多过细，将导致服务性能上不来，原本服务性能几万/秒，可能降低到几百/秒，而且由于日志过多，降低了并发性能，bug可能借此被掩盖而不触发。</p><p>如果日志过少，没有一次请求的全路径信息，不能分析出bug具体出现在哪个点。</p><p>面对这个两难的选择，如何解决？</p><p>作者针对日志系统做了改进，增加日志的粒度，由于bug是低概率触发，绝大部分请求的处理逻辑都是正常的，日志打出来也没用，最好日志系统能抓到那次有问题的请求。<br>作者针对于海量请求，随机触发该次请求的全路径详细日志打印，这样既不会过于降低性能，也不会丢失全路径的详细信息。</p><p>接下来，就是将改进后的代码上线，用工具进行压测，然后，等。。。</p><p>撞大运的事情，终究还是没有发生。。。</p><p>但是，整个日志改造的过程中，作者对于项目代码愈发熟练，对于请求的整个处理流程犹如刻在脑海。</p><h4><span id="分析bug">分析bug</span></h4><p>作者通过与同事讨论交流，分析bug的触发时间点，均在凌晨4-6点，而白天正常，一次core也未发生，这比较奇怪。</p><p>突然灵机一动，联想到凌晨网络运营商会进行维护，可能产生大量异常请求包，是不是这个原因导致的bug发生。</p><p>作者对压测工具进行改造，故意构造一些异常请求，例如tcp三次握手，发了sync包后，就直接将连接close，请求包不完整等等case。</p><p>功夫不负有心人，新版压测工具上线后，不出一个小时就能复现bug，结合网络异常这个点，将代码相关逻辑检查、添加日志，很快就分析出了bug具体原因，session复用机制导致的问题。</p><h4><span id="总结">总结</span></h4><p>这篇文章给出了排查极低概率bug的套路：</p><ul><li>复现bug，可以考虑构造压测工具</li><li>分析bug，可以通过core文件或者在可疑点添加日志</li><li>与同事交流、讨论、思考，分析bug可能触发的原因与场景</li><li>针对性修改压测工具、添加关键点日志</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个bug，需要运行百万次才触发一次，该如何排查这个问题？&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>关于PayPal支付接入的思考——通知校验机制</title>
    <link href="http://www.xiaocc.xyz/2018-05-15/%E5%85%B3%E4%BA%8EPayPal%E9%80%9A%E7%9F%A5%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://www.xiaocc.xyz/2018-05-15/关于PayPal通知校验的思考/</id>
    <published>2018-05-15T11:30:00.000Z</published>
    <updated>2018-09-18T03:43:48.024Z</updated>
    
    <content type="html"><![CDATA[<p>PayPal支付中通知校验机制的思考<br><a id="more"></a></p><h4><span id="校验机制介绍">校验机制介绍</span></h4><p>PayPal支付流程中，待用户支付完毕后，会以WebHook的形式异步通知商户。</p><p>所谓的异步通知，其实就是以Post的形式调用商户提前在PayPal网站注册的一个URL。</p><p>可见，该URL任何第三方亦可调用，以伪装成支付成功，所以商户接收到Notification的时候，需要<strong>校验</strong>其是否PayPal下发。</p><p>PayPal开发者文档中提供了一个API用以校验Notification的真实性。<br>文档地址：<a href="https://developer.paypal.com/docs/api/webhooks/#verify-webhook-signature" target="_blank" rel="noopener">https://developer.paypal.com/docs/api/webhooks/#verify-webhook-signature</a><br>校验流程为，将接收到的相关信息以Post形式请求PayPal校验接口，其会返回：SUCCESS、FAILURE</p><p>Post的数据格式为Json，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;transmission_id&quot;: &quot;69cd13f0-d67a-11e5-baa3-778b53f4ae55&quot;,</span><br><span class="line">  &quot;transmission_time&quot;: &quot;2016-02-18T20:01:35Z&quot;,</span><br><span class="line">  &quot;cert_url&quot;: &quot;cert_url&quot;,</span><br><span class="line">  &quot;auth_algo&quot;: &quot;SHA256withRSA&quot;,</span><br><span class="line">  &quot;transmission_sig&quot;: &quot;xxxx&quot;,</span><br><span class="line">  &quot;webhook_id&quot;: &quot;1JE4291016473214C&quot;,</span><br><span class="line">  &quot;webhook_event&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>webhook_event</code> 字段的Value为<strong>Object</strong>，其它字段的Value均为<strong>String</strong>。</p><p>按照API文档使用curl工具自测，返回 <code>FAILURE</code><br>使用Postman工具测试，亦返回 <code>FAILURE</code><br>翻看文档，尝试各种解决方案，无果，只能求助万能的google。</p><p>还真有人反馈这个问题：<a href="https://github.com/paypal/PayPal-Python-SDK/issues/175" target="_blank" rel="noopener">https://github.com/paypal/PayPal-Python-SDK/issues/175</a>，其中一个解答者为PayPal官方开发者。<br>经过尝试，发现调整 <code>webhook_event</code> 这个Object中某些key的顺序就可以顺利通过检查。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;webhook_event&quot;:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:&quot;WH-64U11527U2666304T-3BK004431V7313539&quot;,</span><br><span class="line">    &quot;event_version&quot;:&quot;1.0&quot;,</span><br><span class="line">    &quot;create_time&quot;:&quot;2016-12-07T09:10:39Z&quot;, </span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API校验<strong>失败</strong></p><p>然而，调整 <code>create_time</code> 与 <code>event_version</code> 的顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;webhook_event&quot;:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:&quot;WH-64U11527U2666304T-3BK004431V7313539&quot;,</span><br><span class="line">    &quot;create_time&quot;:&quot;2016-12-07T09:10:39Z&quot;, </span><br><span class="line">    &quot;event_version&quot;:&quot;1.0&quot;,</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API却校验<strong>成功</strong></p><p>通过curl工具，我能方便的调整Post给PayPal的数据中字段的顺序，可是在代码中实测的时候，我却无法做到！</p><p><strong>为什么？</strong></p><p>因为通过Http接口Post给PayPal的数据本质上是一个 <code>String</code>，只不过在Http头中指定数据格式为Json，<code>Content-type: application/json</code>。<br>这个String肯定是通过调用Json对象的序列化函数得来，我没有办法去改变序列化函数的实现，从而调整序列化成String后Key的顺序。</p><h4><span id="校验机制的问题">校验机制的问题</span></h4><p><strong>为什么会导致校验失败？</strong></p><p>这得从 <code>webhook_event</code> 这个字段所需的值说起。<br>这个字段的值，实际上就是PayPal支付成功后通知商户的Notification的值。</p><p>我们复盘一下整个流程：</p><div id="sequence-0"></div><p>可见，最初PayPal传递给商户的数据<strong>nf_string</strong>，经过反序列化、再序列化之后得到的数据<strong>nf_string’</strong>，两者并不是byte尺度一致。</p><p><strong>商户的Json库序列化实现与PayPal侧的实现无法保证一致</strong></p><p>这就导致PayPal侧，在接收商户校验Notification请求时候，直接以序列化后新的String计算signature值产生偏差。</p><p>也可能，Notification生成服务与校验服务，Json相关序列化函数实现不一致，导致将Json对象转换为 <code>String</code> 后，计算signature两者不一致，从而导致校验失败。</p><h4><span id="思考">思考</span></h4><p>要解决该问题，有几种方式：</p><ul><li><p>PayPal侧保证数据顺序的一致性，在接收到商户发送来的校验请求数据 <code>post_data</code> 后，先反序列化成Json对象，取出 <code>webhook_event</code> 对象，再将其调用序列化函数转换成String，这样就能保证与最初下发给商户的 <code>nf_string</code> 在byte尺度一致，<strong>因为两个String都是在PayPal侧完成序列化</strong>。<br>  不管商户侧对这个 <code>nf_string</code> 如何调整key的顺序，最终校验签名需要的String，都是在PayPal侧序列化生成，能够保证其与最初下发给商户时的 <code>nf_string</code> 一致。</p></li><li><p><strong>回顾整个流程，症结在于商户序列化的实现</strong>，影响了PayPal侧对于签名的计算，所以可以修改API，将 <code>webhook_event</code> 字段的Value修改为<strong>String</strong>。<br>  这样，商户只需要将PayPal最初下发的 <code>nf_string</code> 填入即可，PayPal从商户post_data中取到的 <code>webhook_event</code> 值，即与最初异步通知下发时候一致。</p></li></ul><p>由于多平台、多语言的存在，对于需要byte级别一致的数据，不应该对客户的环境做任何假设，相关字段最好以 <code>String</code> 形式传递。</p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">PayPal->商户: post形式通知支付结果，nf_string商户-->商户: 根据nf_string反序列化成json对象，nf_object商户-->商户: 构造需要校验的Json对象，post_body商户-->商户: 将Json对象序列化成String，post_data商户->PayPal: 以http的形式将post_data发送</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PayPal支付中通知校验机制的思考&lt;br&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://www.xiaocc.xyz/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>关于PayPal支付接入的思考——唯一ID的生成</title>
    <link href="http://www.xiaocc.xyz/2018-05-12/%E5%85%B3%E4%BA%8EPayPal%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://www.xiaocc.xyz/2018-05-12/关于PayPal支付接入的思考/</id>
    <published>2018-05-12T09:00:00.000Z</published>
    <updated>2018-09-18T03:43:59.941Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中需要接入PayPal支付，由此引发了关于唯一ID生成、签名校验机制的一些思考</p><a id="more"></a><h4><span id="系统框架">系统框架</span></h4><p>主要流程：<br>在页面引入PayPal支付购买物品，系统生成CDKey，用户拿着CDKey可以兑换物品。</p><p>框架如下：</p><div id="sequence-0"></div><p>其中，<strong>接入服务</strong>主要负责接入并与外围其它服务交互，而<strong>CDKey服务</strong>主要负责CDKey的维护，包括生成、校验、使用等。</p><h4><span id="paypal支付流程">PayPal支付流程</span></h4><p>既然是接入PayPay支付，阅读其说明文档就能理清整个交互流程，如下：</p><div id="sequence-1"></div><h5><span id="流程解释">流程解释</span></h5><ol><li>用户在web页面点击购买物品，server端做相关检查后，调用paypal接口进行<strong>订单创建</strong></li><li>paypal订单创建接口需要填入<strong>return_url与cancel_url</strong>，这两个字段的含义稍后解释。订单创建成功后，paypal会返回一个<strong>redirect_url</strong>，这个url页面是paypal的，<strong>server端需要让用户web页面重定向至该url</strong>。</li><li>用户web页面被重定向至redirect_url后，需要输入paypal账号、密码进行登录，<strong>如果确认支付</strong>，paypal会让页面跳转至return_url，<strong>如果用户取消支付</strong>，paypal会让页面跳转至cancel_url。</li><li>如果用户确认支付，paypal让用户web页面跳转至return_url的同时，会附带payment_id、user_id，server端需要拿着这些参数<strong>execute订单</strong>。</li><li>等待一小段时间，paypal会以异步通知的形式，通知server端支付结果信息</li><li>server端需要<strong>检查该notify信息是否真的paypal下发</strong>，并检查订单当前支付状态</li></ol><p><strong>注意：检查notify信息是否paypal下发，非常重要！</strong><br><strong>异步通知只是一个web接口的调用，任何第三方都可以调用该接口，以伪装支付成功！</strong></p><p>整个系统分为两个模块，一个模块负责与paypal交互，一个模块负责CDKey相关。</p><h4><span id="cdkey的生成">CDKey的生成</span></h4><p>CDKey本质上是一个唯一ID，且不是单纯的数字id，可以是大小写字母、数字组合。<br>知乎上有关于短链生成算法的讨论，可以借鉴其思想。</p><p>生成方式主要有几种：</p><ol><li><p>通过随机算法生成一个随机数，这个数要尽可能分散，如何解决<strong>碰撞问题</strong>是个难题，可以碰撞后再次尝试生成，但无法根本解决碰撞问题。<br>常用的实现可以对字符串进行hash，其中字符串可以是网站原始url或者自己构造的代表该次请求的唯一串。<br>hash函数要求散列性高，可以使用 <a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">MurmurHash</a>。</p></li><li><p>通过redis或者mysql产生自增id来当做唯一ID，该方式可以解决碰撞问题，但是该方式生成的唯一ID具有<strong>规律性</strong>。<br>而在我们这个使用场景中，用它来当做CDKey不满足要求，因为我们这个系统中CDKey是不记名式的。<br>如果用户知道CDKey=100可用，那么他会拿101这个新的CDKey尝试兑换，这样他就兑换走了其它用户购买的物品，因而不能采用该方式。</p></li><li><p>方式1 + 方式2<br>唯一ID分为两部分，<strong>hash部分 + 自增部分</strong>，其中自增部分保证唯一性，而hash部分解决单纯自增的规律性问题。<br>或者采用<strong>signature(自增id) + 自增id</strong>的方式，签名部分可以解决规律性问题、同时可以用来校验整个id的合法性。</p></li></ol><h4><span id="防刷-盗刷问题">防刷、盗刷问题</span></h4><p>由于物品兑换的唯一依据是不记名的CDKey，如何做防刷、盗刷？</p><ol><li><p>能不能单纯依靠增加CDKey的长度来解决盗刷问题<br>理论上不行，实际可行<br>假设CDKey长度6个字符，每个字符由大小写字母、数字构成，共计62种变化，6个字符约500亿种变化。按照100qps的速度扫描，需要18年才能扫完整个空间，CDKey长度每增加1个字符，扫描难度增大62倍。如果CDKey长度由6个字符，增加到12个字符，破解难度可想而知。</p></li><li><p>能不能通过限制每个ip的访问频率，来控制扫描破解CDKey的速度<br>不行<br>假设黑客控制了100台肉鸡，每台100qps的扫描速度，CDKey长度6个字符，那么他只需要65天，就能扫完整个CDKey空间，如果他控制了10000台呢，那就更快扫完了。</p></li><li><p>能不能对服务端的处理速度做限制，例如：每秒只处理10个请求<br>不行<br>这样虽然控制了黑客的扫描速度，但是也阻挡了正常用户的请求，降低了系统吞吐量</p></li><li><p>能不能针对CDKey做一些检测或者限制<br>不行<br>黑客每次扫描的CDKey都不相同，无规律性</p></li><li><p>那有什么好的解决办法呢？<br>可以考虑给CDKey增加Secret</p><ul><li>添加Secret，相当于增加了CDKey的长度，增加了黑客扫描破解的难度，他必须先猜中CDKey，再猜中Secret才能非法获取</li><li>可以对针对CDKey做一些安全性控制，如果CDKey的密码输入错误3次，冻结该ip及CDKey一段时间，这样可以极大的降低黑客扫描的速度，扫描破解，命中CDKey后，尝试扫描破解Secret密码，只要错误几次，该肉鸡的ip即被冻结，同时该CDKey也暂不可用，阻止黑客采用其它ip继续破解Secret。</li></ul></li></ol><p><em>关于PayPal中Notify的校验问题，下次讨论</em></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">User->接入服务: 购买接入服务->CDKey服务: 请求生成CDKeyNote right of CDKey服务: 根据算法生成CDKeyCDKey服务-->接入服务: CDKey接入服务-->User: CDKeyUser->接入服务: 用CDKey兑换物品接入服务->CDKey服务: 校验CDKeyCDKey服务-->接入服务: yes or no接入服务-->User: 物品</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">user->server: web页面点击购买物品server->paypal: 创建订单(填写return_url、cancel_url)paypal->server: 订单创建成功，返回redirect_urlserver->user: 让web页面302跳转到redirect_urluser->user: 输入paypal账号、密码登录user->user: 确认支付paypal-->user: 页面跳转至return_url并附加相关参数user->server: 将附加参数传递给server端server->paypal: execute订单paypal-->server: 异步notify订单支付信息server-->paypal: 校验notify信息server-->paypal: 检查订单支付状态</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作中需要接入PayPal支付，由此引发了关于唯一ID生成、签名校验机制的一些思考&lt;/p&gt;
    
    </summary>
    
      <category term="系统设计" scheme="http://www.xiaocc.xyz/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>使用C++安全的发送邮件</title>
    <link href="http://www.xiaocc.xyz/2018-05-10/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B62/"/>
    <id>http://www.xiaocc.xyz/2018-05-10/发送邮件2/</id>
    <published>2018-05-10T15:00:00.000Z</published>
    <updated>2018-09-18T03:44:52.495Z</updated>
    
    <content type="html"><![CDATA[<p>前文提到，使用SMTP协议发送邮件不安全，本文将解释具体原因与应对措施</p><a id="more"></a><p>要解释SMTP协议的不安全问题，得先说说http协议</p><h4><span id="http协议">HTTP协议</span></h4><p>具体解释可以参考wiki <a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTP协议</a></p><blockquote><p>它是一种用于分布式、协作式和超媒体信息系统的应用层协议<br>设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法</p></blockquote><p>http交互内容是明文传输，例如获取google首页的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.google.com</span><br></pre></td></tr></table></figure><p>服务器返回内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 3059</span><br><span class="line">Server: GWS/2.0</span><br><span class="line">Date: Sat, 11 Jan 2003 02:44:04 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Cache-control: private</span><br><span class="line">Set-Cookie: PREF=ID=73d4aef52e57bae9:TM=1042253044:LM=1042253044:S=SMCc_HRPCQiqy</span><br><span class="line">X9j; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>这样有什么安全问题呢？整个交互内容除了Client和Server端，没有第三个人知道。<br>你可能有这样的疑问，其实不对，我们在网络上发送消息，并不是直接传递到Server端，中间会经过很多节点的转发，这样就存在干坏事的时机。</p><div id="sequence-0"></div><p>经常上网的你会碰到，有时候打开网页，莫名其妙的多了广告，而且有些是非常著名的网站，这些网站不会自主添加广告。</p><p><strong>那这些广告是哪里来的呢？</strong></p><p>其实是网络运营商对服务端返回的数据进行解析与篡改，由于整个交互内容是明文，很容易知道数据格式，就可以在返回数据中添加自己的广告，然后返回给用户。利用这个原理也可以做一些别的事情，例如：针对非法网页的打击。</p><div id="sequence-1"></div><p>这就是常说的 <code>中间人劫持</code>。</p><h4><span id="https">HTTPS</span></h4><p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki解释</a></p><blockquote><p>超文本传输安全协议，是一种通过计算机网络进行安全通信的传输协议<br>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p></blockquote><h5><span id="与http的差异">与HTTP的差异</span></h5><blockquote><p>与HTTP的URL由“http://”起始且默认使用端口80不同，HTTPS的URL由“https://”起始且默认使用端口443<br>HTTP协议和安全协议同属于应用层（OSI模型的最高层），具体来讲，安全协议工作在HTTP之下，运输层之上：安全协议向运行HTTP的进程提供一个类似于TCP的套接字，供进程向其中注入报文，安全协议将报文加密并注入运输层套接字；或是从运输层获取加密报文，解密后交给对应的进程。<br>严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。<br><strong>HTTPS报文中的任何东西都被加密，包括所有报头和荷载</strong>。<br>除了可能的选择密文攻击之外，一个攻击者所能知道的只有在两者之间有一连接这一事实。</p></blockquote><p><strong>由此可见，https能够实现网页信息的安全传输</strong></p><h4><span id="smtps">SMTPS</span></h4><p>http协议有对应的安全版本https，其实，smtp协议也有对应的安全版本smtps。<br>smtps协议的 <a href="https://en.wikipedia.org/wiki/SMTPS" target="_blank" rel="noopener">wiki解释</a><br>与https协议类似，smtps协议也是通过 SSL/TLS 在传输层上通过对信息加密来保证安全性</p><h4><span id="实际例子">实际例子</span></h4><p>libcurl中有一个smtp + ssl的例子：<a href="https://curl.haxx.se/libcurl/c/smtp-ssl.html" target="_blank" rel="noopener">code</a></p><p><em>我想知道，还有什么功能是libcurl不能实现的。。。</em></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Client->Node1: dataNode1-->Node2: dataNode2-->Node3: dataNode3-->NodeN: dataNodeN->Server: data</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">Server->Node1: dataNode1->Node2: dataNode2-->NodeN: data->data'NodeN->Client: data'</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文提到，使用SMTP协议发送邮件不安全，本文将解释具体原因与应对措施&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
</feed>
