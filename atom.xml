<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曾经浮华的小窝</title>
  
  <subtitle>hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaocc.xyz/"/>
  <updated>2019-06-18T08:44:15.307Z</updated>
  <id>http://www.xiaocc.xyz/</id>
  
  <author>
    <name>曾经浮华</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式作业调度系统nomad</title>
    <link href="http://www.xiaocc.xyz/2019-06-18/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9Fnomad/"/>
    <id>http://www.xiaocc.xyz/2019-06-18/作业调度系统nomad/</id>
    <published>2019-06-18T06:30:00.000Z</published>
    <updated>2019-06-18T08:44:15.307Z</updated>
    
    <content type="html"><![CDATA[<p>作业调度系统nomad介绍与使用</p><a id="more"></a><h4><span id="nomad简介">nomad简介</span></h4><p>nomad是一个分布式作业调度系统，其可以管理容器、微服务、批处理任务等。</p><p>其官网如下：<br><code>https://www.nomadproject.io/</code></p><blockquote><p>Nomad is a flexible workload orchestrator that enables an organization to easily<br>deploy and manage any containerized or legacy application using a single,<br>unified workflow. Nomad can run a diverse workload of Docker, non-containerized,<br>microservice, and batch applications.</p></blockquote><blockquote><p>Nomad enables developers to use declarative infrastructure-as-code for deploying applications. Nomad uses bin packing to efficiently schedule jobs and optimize for resource utilization. Nomad is supported on macOS, Windows, and Linux.</p></blockquote><blockquote><p>Nomad is widely adopted and used in production by PagerDuty, Target, Citadel, Trivago, SAP, Pandora, Roblox, eBay, Deluxe Entertainment, and more.</p></blockquote><h4><span id="与k8s区别">与k8s区别</span></h4><p>nomad与当前热门的容器管理系统k8s，有什么区别</p><ul><li>k8s只是一个容器管理系统，而nomad不但可以管理容器，还可以调度服务、批处理任务等等</li><li>nomad由go语言编写，部署简单，无任何依赖，一个binary搞定</li></ul><h4><span id="示例">示例</span></h4><h5><span id="安装">安装</span></h5><p>文档：<a href="https://www.nomadproject.io/intro/getting-started/install.html" target="_blank" rel="noopener">https://www.nomadproject.io/intro/getting-started/install.html</a></p><p>有多种安装方式：</p><ul><li>下载源码自行编译</li><li>下载binary</li><li>通过vagrant安装</li></ul><h5><span id="启动nomad">启动nomad</span></h5><p>nomad支持集群模式和测试dev模式，在dev模式中client、server直接启动，便于研究和测试</p><p>执行：<code>nomad agent -dev</code> 启动nomad</p><p>通过 <code>nomad node status</code> 查看node状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./nomad node status</span><br><span class="line">ID        DC   Name          Class   Drain  Eligibility  Status</span><br><span class="line">3d2f0237  dc1  046ba6241f86  &lt;none&gt;  false  eligible     ready</span><br></pre></td></tr></table></figure><p>nomad的agent内置gossip协议，其运行于server模式下，会通过该协议获取其它server信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./nomad server members</span><br><span class="line">Name                 Address     Port  Status  Leader  Protocol  Build  Datacenter  Region</span><br><span class="line">046ba6241f86.global  172.17.0.7  4648  alive   true    2         0.9.3  dc1         global</span><br></pre></td></tr></table></figure><h5><span id="运行job">运行job</span></h5><p>通过执行<code>nomad job init</code>生成一个任务模板，观察该任务定义文件大体格式</p><p>该模板任务，定义了一个service，其通过docker启动redis服务<br><code>nomad job run example.nomad</code> 即注册了一个job，等待nomad调度运行</p><h5><span id="自定义任务">自定义任务</span></h5><p>如何编写一个自定义job并运行？</p><p><a href="https://www.nomadproject.io/docs/job-specification/index.html" target="_blank" rel="noopener">查看文档</a>，得知任务定义文件基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job</span><br><span class="line">  \_ group</span><br><span class="line">        \_ task</span><br></pre></td></tr></table></figure><p>每个nomad任务文件定义一个<code>job</code>，一个job下可定义多个<code>group</code>，每个group下有多个<code>task</code></p><p>定义在同一个group中的task，nomad会将其分配在相同的node去执行</p><p><code>job、group、task</code>各自又有不同属性</p><p>job的<code>type</code>属性，定义任务类型，有<code>service</code>、<code>batch</code>、<code>system</code>三种类型，<a href="https://www.nomadproject.io/docs/schedulers.html" target="_blank" rel="noopener">详见文档</a></p><p>group的<code>count</code>属性，指定该group下的task需要下发到多少个node执行，一般填<code>1</code></p><p>task的<code>driver</code>属性，指定任务驱动类型，包括<code>docker, qemu, java and exec</code>等，<a href="https://www.nomadproject.io/docs/drivers/index.html" target="_blank" rel="noopener">详见文档</a></p><p>常见的定时作业任务属于<code>batch</code>类型，即定时或周期执行一个<code>bash</code>脚本或者程序</p><p>接下来自定义一个job，在其中执行一个<code>bash</code>脚本</p><p>cron.nomad 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">job &quot;cron&quot; &#123;</span><br><span class="line">datacenters = [&quot;dc1&quot;]</span><br><span class="line"></span><br><span class="line">type = &quot;batch&quot;</span><br><span class="line"></span><br><span class="line">group &quot;test&quot; &#123;</span><br><span class="line">count = 1</span><br><span class="line"></span><br><span class="line">task &quot;one&quot; &#123;</span><br><span class="line">driver = &quot;raw_exec&quot;</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">command = &quot;/data/nomad/one.sh&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>command</code>需要为绝对路径</p><p>one.sh 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">i=1</span><br><span class="line">sum=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">  let sum=sum+$i</span><br><span class="line">  let i+=2</span><br><span class="line">  echo $sum &gt;&gt; /data/nomad/log/one.log</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum &gt;&gt; /data/nomad/log/one.log</span><br></pre></td></tr></table></figure><p>执行任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./nomad job run cron.nomad</span><br><span class="line">==&gt; Monitoring evaluation &quot;71f82418&quot;</span><br><span class="line">    Evaluation triggered by job &quot;cron&quot;</span><br><span class="line">    Allocation &quot;15671c83&quot; created: node &quot;92bcf36d&quot;, group &quot;test&quot;</span><br><span class="line">    Allocation &quot;15671c83&quot; status changed: &quot;pending&quot; -&gt; &quot;running&quot; (Tasks are running)</span><br><span class="line">    Evaluation status changed: &quot;pending&quot; -&gt; &quot;complete&quot;</span><br><span class="line">==&gt; Evaluation &quot;71f82418&quot; finished with status &quot;complete&quot;</span><br></pre></td></tr></table></figure><h5><span id="周期任务">周期任务</span></h5><p>目前小组主要使用nomad来跑定时task，比如每5分钟、每30分钟执行的任务等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">job &quot;after&quot; &#123;</span><br><span class="line"></span><br><span class="line">datacenters = [&quot;dc1&quot;]</span><br><span class="line"></span><br><span class="line">type = &quot;batch&quot;</span><br><span class="line"></span><br><span class="line">  periodic &#123;</span><br><span class="line">    cron             = &quot;*/3 * * * * *&quot;</span><br><span class="line">    prohibit_overlap = true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">group &quot;test&quot; &#123;</span><br><span class="line">count = 1</span><br><span class="line"></span><br><span class="line">task &quot;two&quot; &#123;</span><br><span class="line">driver = &quot;raw_exec&quot;</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">command = &quot;/data/nomad/two.sh&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="ui">UI</span></h4><p>nomad支持可视化页面，对任务、集群进行查看和管理</p><p>URL：http://*:4646/ui/jobs</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190618-163725.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作业调度系统nomad介绍与使用&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.xiaocc.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>架构设计——高性能</title>
    <link href="http://www.xiaocc.xyz/2019-06-04/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    <id>http://www.xiaocc.xyz/2019-06-04/架构设计高性能/</id>
    <published>2019-06-04T08:30:00.000Z</published>
    <updated>2019-06-05T03:45:05.914Z</updated>
    
    <content type="html"><![CDATA[<p>架构设计相关阅读笔记</p><a id="more"></a><h4><span id="引子">引子</span></h4><p>上篇说到，架构设计是为了解决软件系统中的复杂问题，这些问题归纳起来可以分为几个方面：</p><ul><li>高性能</li><li>高可用</li><li>高可扩展</li></ul><p>一个系统的性能往往是工程师最为关注的，因为用户无法忍受长时间的等待，响应耗时每增加100ms，就有相当比例的用户流失。</p><p>该篇讲讲高性能相关架构设计问题</p><p>高性能可分为两大类：</p><ul><li>计算高性能</li><li>存储高性能</li></ul><h4><span id="计算高性能">计算高性能</span></h4><p>一个系统往往有复杂的计算逻辑，该计算会消耗大量时间，如果系统中只有一台机器处理计算请求，那么会造成请求排队、堆积，导致响应延迟增加。</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190604-164032.jpg" alt=""></p><p>计算有个特点，只要输入保持不变，计算逻辑过程保持不变，那么计算结果也会不变。</p><p>所以，为了提高计算性能，我们可以选择水平扩展的方式——也就是增加机器，以扩大计算性能。</p><p>现在面临两个新问题，由于初始时候只有一台机器，所有请求都可以传递给该机器进行处理</p><p>现在有两台、乃至多台机器，如何进行任务分配？</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190604-164256.jpg" alt=""></p><p>计算有同构和异构的问题，也就是说有些计算过程只能在某些特定机器处理，不能在所有机器处理</p><p>举个例子，有两个计算问题，其中一个特别消耗内存，我们打算通过增加机器的方式来提高计算性能，如果我们只是扩容了一台普通内存的机器，那么消耗大内存的计算问题，无法在新扩容机器上进行计算，如果只是简单按照高配置扩容，性价比又不高，因为另外一个计算问题不需要大内存。</p><p><strong>如何解决上面提到的问题？</strong></p><p>这个时候，需要<strong>任务分配器</strong>来进行任务分配和调度</p><h5><span id="任务分配器">任务分配器</span></h5><p>任务分配器的基本功能是进行任务分配，任务分配根据需求场景不同，采用不同的原则，例如：负载均衡策略、最小耗时策略、异构策略等等。</p><p>任务分配器需要监控下游任务机器，如果机器异常，则不能再对其分配任务，常见策略有心跳检测、负反馈剔除等。</p><p>还有其它任务分配策略：</p><ul><li>轮询</li><li>加权轮询</li><li>根据来源ip、session路由，将用户请求路由到特定机器处理，主要是考虑到缓存问题</li><li>随机</li></ul><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190604-172606.jpg" alt=""></p><h4><span id="存储高性能">存储高性能</span></h4><p>主要是解决存储层读写性能低问题，常见的方式有</p><ul><li>读写分离</li><li>数据分片</li><li>添加缓存</li></ul><p>软件系统没有银弹能解决所有问题，上述解决方式会有对应的问题</p><h5><span id="读写分离">读写分离</span></h5><p>该方式适合读多写少的场景，通过增加机器水平扩展，使得读性能同步提高。<br>该架构往往采用主从架构，主机写，从机读，但是主从同步需要时间，特别是网络状况差的情况下，耗时能到分钟级别。</p><p>这个时候，主、从数据往往不一致，由此导致数据延迟问题</p><p>为了应对该问题，引出以下解决方案：</p><ul><li>读己之写，自己数据读主库，他人数据读从库</li><li>核心数据读主库，其它数据读从库</li><li>通过db-proxy层解决</li></ul><p>上述解决方案为侵入式，需要在代码层面手动设置，容易出错</p><h5><span id="数据分片">数据分片</span></h5><p>当单机无法存储全部数据时，需要对数据进行分片存储<br>如何设计分片、寻址算法成为关键</p><p>常用有以下几种方式：</p><ul><li>hash取模</li><li>一致性hash</li><li>路由表</li></ul><p>hash取模法由于机器增减时，需要大量迁移数据，不适用</p><p>一致性hash，有割环法、google函数法两种，数据迁移量小，适用</p><p>路由表，本质上是分离了数据分片和数据寻址，数据属于某一分片id永不变，但是该id的数据部署在哪台机器，由路由表指定</p><h5><span id="缓存">缓存</span></h5><p>数据落地存储一般在SSD或者硬盘中，其吞吐量大但是延迟高，而缓存一般以内存为载体，速度高但是容量低。</p><p>可以将热数据放在缓存中，这样处理请求时不必访问低速的最终存储，转而访问高速的缓存，这样可以减少响应耗时。</p><p>但是缓存也有相应的问题：</p><ul><li>数据一致性</li><li>缓存穿透</li><li>缓存雪崩</li></ul><p>缓存顾名思义只是一种临时存储，其独立于最终存储之外，虽然可以设计缓存更新策略，尽量减少两者数据不一致，但不能避免。</p><p>其实，缓存原本只是作为一种临时存储，用来存储一些非易变的非核心数据，但是由于其使用方便，越来越多的开发者把缓存当做万金油，无缓存不开发，严重依赖缓存，这其实有些滥用。</p><p>缓存穿透：<br>由于缓存中没有数据，导致miss，请求直接打到后端存储层，造成存储层压力过大，甚至整体不可服务。<br>可以将空数据也当做一种数据保存于缓存中，这样不会导致miss，也不会到最终存储层查找，降低存储层压力。<br>异常增多空查询往往由于黑客暴力扫描破解、或者功能设计不合理导致。</p><p>缓存雪崩：<br>缓存中数据由于过期时间到被淘汰，需要重新生成数据以缓存，但是该过程耗时很长，导致大量请求miss，进而均计算数据，进一步导致系统压力增长，最终雪崩。<br>可以通过分布式锁限制数据计算的个数，或者采用后台线程归并本机计算请求，独立计算并更新缓存，其它工作线程等待或者直接返回已过期数据等方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构设计相关阅读笔记&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>架构设计目的与本质</title>
    <link href="http://www.xiaocc.xyz/2019-05-20/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%E4%B8%8E%E6%9C%AC%E8%B4%A8/"/>
    <id>http://www.xiaocc.xyz/2019-05-20/架构设计目的与本质/</id>
    <published>2019-05-20T04:30:00.000Z</published>
    <updated>2019-05-21T01:55:18.385Z</updated>
    
    <content type="html"><![CDATA[<p>架构设计相关阅读笔记</p><a id="more"></a><h4><span id="架构设计目的">架构设计目的</span></h4><p><strong>架构设计目的是解决软件工程中的复杂问题</strong></p><p>软件工程经历过几个大的变革</p><ul><li>编程语言开发效率低的问题。最初的编程语言只有低级的汇编语言，编写应用软件非常不便利，也不利于调试。为了解决这个问题，诞生了C语言，之后又诞生了C++、Java等语言，解决了第一次软件危机</li><li>多核、多机问题。随着硬件发展，处理器多核架构诞生，传统的单进程架构无法利用多核优势，这时候诞生了多进程、多线程架构，以充分利用单机多核优势，之后诞生的分布式架构，将多机协调工作以完成单机无法做到的工作</li><li>随着软件系统的功能愈发复杂，这时候其它问题成为主要矛盾，例如：如何快速添加新需求而不用更改过多代码，如何保证系统稳定性以应对突发流量，如何测试和升级系统以最小化影响用户</li></ul><h4><span id="为什么要进行架构设计">为什么要进行架构设计</span></h4><p>是不是一定要进行架构设计？<br>没有进行架构设计的系统，也运行得好好的，为什么要做架构设计？<br>架构是不是设计得越复杂越好，是不是只有高大上的设计才能称为架构设计？</p><p>以上是架构设计中经常碰到的问题，还有如下问题也经常碰到：</p><p>别人进行了架构设计，那么我也要做架构设计<br>为了高性能、高可用，所以要做架构设计<br>公司要求必须要做架构设计<br>架构设计可以减少代码量、缩短开发时间，提高开发效率</p><p>会提出这些问题，主要是对架构设计的本质没有理解。</p><p>架构设计的目的是什么？</p><p>不是为了显摆架构师的水平有多深，而是要实实在在的解决当前软件系统中的问题。<br>不能说淘宝用了某某架构、微信用了某某架构，我们也得采用某某设计方案，这些考虑都是脱离实际的，淘宝、微信的业务与我们的业务、用户量级不一样，它们碰到的问题，不一定是我们需要解决的问题，如果照搬，会闹笑话。</p><h4><span id="架构设计三原则">架构设计三原则</span></h4><ul><li>简单原则</li><li>适用原则</li><li>演进原则</li></ul><p>简单的方案有利于实施和测试，复杂的方案开发周期长，如果开发中引入某些bug，在测试中难以发现。简单方案还有另外一个好处，容易找出性能瓶颈点，并进行性能优化。</p><p>架构设计要满足适用原则，能够解决实际问题，而不是为了显摆技术能力，或者照搬大厂的某某方案，由于与大厂在业务维度、技术储备维度、人力资源维度均有较大差异，适合大厂的方案不一定适合自己系统。</p><p>由于软件系统不是一成不变的，为了满足用户需求，需要随时调整与添加功能，不要想着一下子做一个万金油式的方案，一劳永逸。可以采用小步快跑的方式，先开发一个最小化的原型，并保留扩展能力，然后随着业务发展持续优化。</p><h4><span id="架构设计案例分析">架构设计案例分析</span></h4><p>文中以”前浪微博”为例，讲解架构设计详细步骤</p><p>前浪微博与新浪微博业务类似，用户注册后需要通知其它模块，例如：新手礼物模块、vip等级模块、消息发送模块等等，之前采用的是注册模块直接调用相关模块的接口进行通知，这种设计随着系统功能的庞大，越来越不适应。<br>用户点击注册按钮后，注册服务需要与多个模块交互，用户等待延迟长，体验差，另一方面，相关模块经常出问题，导致注册服务通知调用失败，最终给用户的反馈就是注册失败。</p><p>架构师经过分析，主要是各个模块之间耦合严重，决定利用消息队列来对用户注册事件进行分发，其它对该事件感兴趣模块自由监听该事件消息，这样就解决了上面提到的两个问题。</p><p>当前系统负载情况如下：<br>用户注册qps大约1200/s，下游需要监听该事件的模块数量约10个。<br>推论出消息队列写qps大约1200/s，读qps约<code>1200 * 10 = 1.2w/s</code>。</p><p>接下来进行方案选型，备选方案一般选择<code>3-4</code>个，低于3个一般是思维狭隘、眼界不够，多于4个会导致方案辩论时间过长，甚至无法选择出最终方案。</p><p>接下来是团队背景信息：</p><ol><li>开发团队人员5人，技术栈为Java，但有两个同事C/C++特别牛</li><li>中间件团队人员5人</li><li>运维团队人员3人</li></ol><p>备选方案有3个，开源方案kafka、Mysql+自研、纯自研</p><p>接下来进行360度方案评估：</p><table><thead><tr><th>360</th><th style="text-align:center">kafka</th><th style="text-align:center">Mysql</th><th style="text-align:center">纯自研</th></tr></thead><tbody><tr><td>开发团队</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td>中间件团队</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr><tr><td>运维团队</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td></tr></tbody></table><p>评估核心：</p><ul><li>kafka<ul><li>开发团队、中间件团队无意见，主要依赖运维团队，后者表示对kafka不熟悉，并且监控告警机制不完善，担心开源组件稳定性，如果出现问题，无法解决</li></ul></li><li>Mysql<ul><li>开发团队无意见，运维团队对Mysql非常熟练无意见，中间件团队表示无意见，少量开发工作，有利于提高其部门开发实力，同时利于在公司内部露脸彰显技术实力</li></ul></li><li>纯自研<ul><li>开发团队、运维团队表示对中间件团队开发该量级大系统能力表示怀疑，纯自研组件可靠性、稳定性待检测，开发周期长，时间上不允许 </li></ul></li></ul><p>最后架构师基于相关背景、资源，在该约束情况下选择Mysq自研的方式，同时考虑到以下几点：</p><ul><li>Mysql的稳定性、可靠性高，社区活跃、文档多</li><li>Mysql单机性能不错，可以达到2000/s，架构设计时对消息分片以利用多机能力</li><li>运维团队对Mysql熟悉，监控、告警机制齐全</li></ul><p>接下来进行详细的方案设计与讨论</p><h4><span id="总结">总结</span></h4><p>综上，架构设计是为了解决项目中的复杂问题，在有约束情况下(团队技术栈、运维资源)寻找最优解，而不是盲目崇拜大厂方案。<br>技术最终是为了业务而服务，需要遵循架构设计的演化原则，不要想着一步登天，一下子做一个全球领先的方案，以适用业务为原则，只要能实际解决业务遇到的迫切问题就是好方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构设计相关阅读笔记&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>单点登录(SSO)阅读笔记</title>
    <link href="http://www.xiaocc.xyz/2019-04-20/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95(SSO)%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.xiaocc.xyz/2019-04-20/单点登录(SSO)笔记/</id>
    <published>2019-04-20T08:00:00.000Z</published>
    <updated>2019-04-20T10:07:17.822Z</updated>
    
    <content type="html"><![CDATA[<p>分析实现SSO的几种方式</p><a id="more"></a><h4><span id="为什么需要sso">为什么需要SSO</span></h4><p>首先看看什么叫SSO，也即一次登录、多次使用。<br>比如一个公司内部有很多个管理系统，这些系统在功能上互相独立，我们可以对每个系统做一套独立的账号系统，但是这样做，每个用户需要申请多个账号，并且每打开一个新系统的页面都需要登录，非常繁琐。<br>而且由于账号分散到各个系统，也不利于权限的统一管理。</p><p>如下图：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-161602.jpg" alt=""></p><p>所以，我们需要一个系统能够解决以上问题，我们将该问题拆解成如下几个子问题进行解决。</p><h4><span id="单系统保持登录状态">单系统保持登录状态</span></h4><p>首先看看最简单的一个问题，某个系统M，如果用户A已经登录，关闭该系统页面，并重新打开，如何自动登录。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-162302.jpg" alt=""></p><p>用户通过浏览器访问系统M，能不能在浏览器侧保存某种信息，以记录用户的登录状态？</p><p>可以的，浏览器可以保存数据到cookie中，并进行持久存储，那么可以将用户登录状态保存其中。</p><p>用户首次访问系统M，由于未登录，弹出登录框，用户输入账号、密码信息，后台系统验证通过后，生成一个带有效期的SessionID信息，并将其下发给client侧，后者将其保存在cookie中，之后的请求中均带上SessionID信息，这样服务器侧根据该信息就知道用户具体信息，而不需要用户再次登录。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-163144.jpg" alt=""></p><p>这样当用户再次访问系统M时，首先检查cookie信息，并将其与服务器校验有效性，如果其依然处于有效期，则不用输入账号、密码，直接登录成功。</p><h4><span id="多系统保持登录状态">多系统保持登录状态</span></h4><p>这里的多系统分为两种情况：</p><ul><li>多个系统处于同一个域名下，例如：公司内部的管理系统，m.oa.com，n.oa.com</li><li>多个系统域名不同，例如：微信、QQ均可以采用某种账号登录，m.wx.com，m.qq.com</li></ul><h5><span id="同域名登录">同域名登录</span></h5><p>在之前的讨论中，用户访问M系统(m.oa.com)，在其输入账号、密码并登录成功后，其将服务器下发的SessionID信息保存到cookie中，这时候保存的域为<code>m.oa.com</code>，要想实现同域下的访问，只需要将cookie保存的域更改为<code>.oa.com</code>即可。</p><p>如此之后，用户访问N系统(n.oa.com)，由于两者处于同一个域下，即可访问刚才由M系统保存的cookie信息，从而实现自动登录。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190420-165028.jpg" alt=""></p><h5><span id="跨域名登录">跨域名登录</span></h5><p>不同域名的两个系统如何实现单点登录？根据浏览器cookie规则，不允许跨域访问，主要是为了安全性。<br>我们想象一下，如果不采用SSO单点登录，那么用户登录两个系统，m.wx.com，m.qq.com，均需要输入账号、密码，而这个账号密码页的域名是同一个，sso.oa.com。</p><p>那么我们能不能借助该共同信息，以实现SSO单点登录。</p><p>答案是可以的，只是由于跨域和安全性问题，流程比较复杂，具体流程如下：</p><div id="sequence-0"></div><p>用户在此之后，如果再次访问域名M，由于该域的cookie下有登录ticket，只需要拿着该ticket向服务器进行校验，即可实现自动登录。</p><p>在此之后，如果用户访问跨域页面N，看看如何自动登录：</p><div id="sequence-1"></div><p>如此，即实现了域名N的自动登录。</p><h4><span id="核心">核心</span></h4><ul><li>将公用登录SessionID信息保存到登录页面SSO域的cookie中</li><li>各自系统的登录状态、ticket信息保存到各自域的cookie中</li><li>各个系统生成独立的ticket，主要是为了避免cookie泄漏等漏洞。避免黑客攻破一个系统M，拿到cookie信息，即可自动登录其它系统。</li><li>已登录状态下，SSO页面会询问用户是否授权登录另一系统N</li></ul><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">用户->域名M:请求访问域名M->域名SSO:用户未登录，重定向到登录界面域名SSO->SSO后台:用户输入账号、密码并登录SSO后台->域名SSO:信息校验成功，生成SessionID，并针对域名M生成ticket_M域名SSO->域名SSO:将SessionID保存到cookie的sso.oa.com域下域名SSO->域名M:重定向，并传递参数ticket_M域名M->M后台:将参数ticket_M传递M后台->SSO后台:校验ticket_M合法性SSO后台->M后台:校验通过M后台->域名M:登录成功域名M->域名M:保存ticket_M到cookie的m.wx.com域下域名M->M后台:其它请求</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">用户->域名N:请求访问域名N->域名SSO:用户未登录，重定向到登录界面域名SSO->域名SSO:由于SSO域名的cookie下，有已登录的SessinID信息域名SSO->用户:询问是否授权登录用户->域名SSO:授权登录域名SSO->SSO后台:拿着SessionID进行校验SSO后台->域名SSO:信息校验成功，针对域名N生成ticket_N域名SSO->域名N:重定向，并传递参数ticket_N域名N->N后台:将参数ticket_N传递N后台->SSO后台:校验ticket_N合法性SSO后台->N后台:校验通过N后台->域名N:登录成功域名N->域名N:保存ticket_N到cookie的m.qq.com域下域名N->N后台:其它请求</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析实现SSO的几种方式&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>服务响应时间与分布</title>
    <link href="http://www.xiaocc.xyz/2019-04-13/%E6%9C%8D%E5%8A%A1%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%B8%8E%E5%88%86%E5%B8%83/"/>
    <id>http://www.xiaocc.xyz/2019-04-13/服务响应时间与分布/</id>
    <published>2019-04-13T06:00:00.000Z</published>
    <updated>2019-04-13T11:34:11.980Z</updated>
    
    <content type="html"><![CDATA[<p>分析服务响应时间分布，如：均值、中位值、P95值、P99值等如何计算</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>最近看得多，写得少，所谓</p><blockquote><p>学而不思则罔，思而不学则殆</p></blockquote><p>还是得记录笔记，以加强理解。</p><p>有篇博客提到服务响应时间各种值之优劣，特记录之。</p><h4><span id="平均值">平均值</span></h4><p>我们考察一个服务器的性能，除了QPS数据外，还会考察响应时间，当服务器负载增高时，往往会伴随着响应时间的增长，但是这个值该如何度量，以精准的表现服务器当前之负载呢？</p><p>最常用的值为平均值，表示服务的平均响应时间，通过该值我们能够知道服务当前响应的所有请求耗时的平均值。<br>例如平均耗时为100ms，表示服务器当前<code>请求的总耗时/请求总数量</code>，通过该值，我们大体能知道服务运行情况。<br>但是对于具体有多少个请求的耗时比100ms要大，大多少，是200ms，还是500ms，还是1000ms，我们无从得知。<br>而且，平均值这个数据容易掩盖一些<strong>异常值</strong>问题，比如，我的财富加马云财富的平均值也能过亿，所以，平均值这个数据项过于简单，提供的信息量太少。</p><p>那为什么我们通常采用平均值来衡量或者监控服务性能呢？</p><p>主要是由于该值容易计算，采用两个变量<code>S</code>、<code>N</code>，即可持续计算平均值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S = S + X</span><br><span class="line">N = N + 1</span><br><span class="line">V = S/N</span><br></pre></td></tr></table></figure><p>通过该公式，当有新的耗时值<code>X</code>需要考量，很方便的就能算出平均值，就算QPS到几十万/s，也不在话下。</p><p>注意，该公式有个隐含问题，即是<code>S</code>增长过快问题，如果QPS过高，<code>X</code>值过大，很容易导致<code>S</code>溢出，从而导致结果计算异常。</p><p>可将该公式做如下改造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vs = S/N</span><br><span class="line">Vn = (S+X)/(N+1) = (Vs*N+X)/(N+1) = Vs + (X - Vs)/(N+1)</span><br></pre></td></tr></table></figure><p>该算法也只需要两个变量，未考量数据<code>X</code>时——平均值<code>Vs</code>、数据个数N<br>但是，该算法由于不累加<code>S</code>，而只累加<code>N</code>，而<code>N</code>的增长极慢，不易导致溢出问题。</p><h4><span id="中位值">中位值</span></h4><p>如上所述，由于平均值不能反映数据分布及极端异常值的问题，可以考虑采用<strong>中位值</strong>来作为度量。</p><p>中位值如何计算？</p><p>我们假设某服务在1s内响应了100个请求，耗时为X1、X2 … X100，可以对这100个数按照从小到大的顺序进行排序，在排序后的列表的中间位置的值——即为中位值，假设为150ms。</p><p>那这个值，150ms，表示什么意思呢？<br>它表示，服务器响应的这100个请求里面有50个的请求耗时小于150ms，另有50个请求的耗时大于150ms。</p><p>如果，我们有一个服务qps为3万/s，经过计算响应耗时中位值为100ms，那么我们可以推断有1.5万个请求的耗时小于100ms，也就是说我们有一半的用户的响应耗时小于100ms，据此我们就可以评估服务响应性能是否可以满足业务要求。</p><p>但是，这个中位值还有另外一个问题，我们只知道还有一半的请求耗时大于100ms，具体是大多少，大200ms，还是500ms，我们无法得知。</p><h4><span id="p95值与p99值">P95值与P99值</span></h4><p>由于中位值只能反映中位数的问题，不能反馈更多信息，例如，我想知道该服务80%的请求耗时在多少ms以内，这些问题需要额外的数据指标。</p><p>P95——响应耗时从小到大排列，顺序处于95%位置的值即为P95值。</p><p>还是采用上面那个例子，100个请求按照响应时间从小到大排列，位置为95的值，即为P95值。<br>我们假设该值为180ms，那这个值又表示什么意思呢？</p><p>意思是说，我们对95%的用户的响应耗时在180ms之内，只有5%的用户的响应耗时大于180ms，据此，我们掌握了更精确的服务响应耗时信息。</p><h4><span id="p999值">P99.9值</span></h4><p>亚马逊经常采用P99.9值，也就是99.9%用户耗时作为指标，也就是1000个用户里面，999个用户的耗时上限，如果测量与优化该值，即可保证绝大多数用户的使用体验。<br>至于P99.99值，优化成本过高，而且服务响应由于网络波动、系统抖动等不能解决之情况，故暂不考虑该指标。</p><h4><span id="如何计算p分位值">如何计算P分位值</span></h4><p>如上说过平均值的计算方式，而P值需要将响应耗时从小到大排序，然后取得对应百分位之值。</p><p>如果服务qps较低，例如：100/秒，记录这100个耗时数据，然后排序，然后取得P分位值，倒不是难事。<br>而如果qps较高，例如：30万/秒，如果还是采用<code>记录+排序</code>的方式，可以预见需要消耗大量内存与计算资源。</p><p>有没有简单的计算方式呢？</p><p>可以采用直方图来进行计算，该计算方式虽不是完全准确值，但精度非常高，误差较小。</p><p>直方图需要界定两个直方之间的跨度，一般采用等分形式，例如对于耗时统计需求，我们可以假定一个耗时上界，然后等分，比如划分成100个区间，对于每个响应耗时落入对应的直方，如下图：</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190413-183557.jpg" alt=""></p><p>这样就避免了对全部数据进行排序，只需要根据各个直方中的数据数量，即可计算出95%位置位于哪个直方，然后在该直方内部采用插值方法，计算出P95值。</p><p>另外，考虑到数据分布特点，服务耗时异常数据应该只是少数，但是异常值跨度可能很大，大部分耗时数据均靠近正常值，如果直方统计采用等分形式，会导致大量数据堆积在一个直方中，如何解决这个问题？</p><p>可以采用非等分的跨度划分方式，例如采用<strong>指数</strong>形式划分，耗时越低的区间，跨度越小，精度约高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析服务响应时间分布，如：均值、中位值、P95值、P99值等如何计算&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统调用流程</title>
    <link href="http://www.xiaocc.xyz/2019-01-17/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.xiaocc.xyz/2019-01-17/Linux系统调用流程/</id>
    <published>2019-01-17T14:00:00.000Z</published>
    <updated>2019-01-17T15:30:37.492Z</updated>
    
    <content type="html"><![CDATA[<p>linux系统调用流程分析</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>在前篇中我们讲到，使用<code>kill</code>系统调用进行<code>signal</code>投递之流程，其中有个点没有提到，系统调用详细流程究竟是怎样的。</p><p>大家应该知道传统的系统调用方式，即通过<code>int 0x80</code>指令，以软中断的形式触发系统调用，并将系统调用号放置在<code>rax</code>寄存器中，系统调用其它参数也通过寄存器传递。</p><p>由于通过软中断实现系统调用比较低效，现在普遍采用<code>syscall</code>指令形式。</p><p>本篇主要讲解以软中断方式实现系统调用之流程，理解了这个方式，再去研究其他方式会更容易。</p><h4><span id="中断向量表">中断向量表</span></h4><p>在CPU中有中断向量表，可以理解为一个数组，数组的内容为地址，也就是当对应中断发生时候的处理地址。</p><p>按照<code>int 0x80</code>指令的字面意思，应该是触发了中断号为<code>0x80</code>的中断，那么其处理函数是什么呢？</p><h4><span id="初始化中断表">初始化中断表</span></h4><p>以<code>x86</code>-32位架构为例，在内核启动时候，会调用<code>trap_init</code>函数，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /arch/x86/kernel/traps.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EISA</span></span><br><span class="line"><span class="keyword">void</span> __iomem *p = early_ioremap(<span class="number">0x0FFFD9</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (readl(p) == <span class="string">'E'</span> + (<span class="string">'I'</span>&lt;&lt;<span class="number">8</span>) + (<span class="string">'S'</span>&lt;&lt;<span class="number">16</span>) + (<span class="string">'A'</span>&lt;&lt;<span class="number">24</span>))</span><br><span class="line">EISA_bus = <span class="number">1</span>;</span><br><span class="line">early_iounmap(p, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">set_intr_gate(<span class="number">0</span>, &amp;divide_error);</span><br><span class="line">set_intr_gate_ist(<span class="number">2</span>, &amp;nmi, NMI_STACK);</span><br><span class="line"><span class="comment">/* int4 can be called from all */</span></span><br><span class="line">set_system_intr_gate(<span class="number">4</span>, &amp;overflow);</span><br><span class="line">set_intr_gate(<span class="number">5</span>, &amp;bounds);</span><br><span class="line">set_intr_gate(<span class="number">6</span>, &amp;invalid_op);</span><br><span class="line">set_intr_gate(<span class="number">7</span>, &amp;device_not_available);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">set_task_gate(<span class="number">8</span>, GDT_ENTRY_DOUBLEFAULT_TSS);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">set_intr_gate_ist(<span class="number">8</span>, &amp;double_fault, DOUBLEFAULT_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">set_intr_gate(<span class="number">9</span>, &amp;coprocessor_segment_overrun);</span><br><span class="line">set_intr_gate(<span class="number">10</span>, &amp;invalid_TSS);</span><br><span class="line">set_intr_gate(<span class="number">11</span>, &amp;segment_not_present);</span><br><span class="line">set_intr_gate_ist(<span class="number">12</span>, &amp;stack_segment, STACKFAULT_STACK);</span><br><span class="line">set_intr_gate(<span class="number">13</span>, &amp;general_protection);</span><br><span class="line">set_intr_gate(<span class="number">15</span>, &amp;spurious_interrupt_bug);</span><br><span class="line">set_intr_gate(<span class="number">16</span>, &amp;coprocessor_error);</span><br><span class="line">set_intr_gate(<span class="number">17</span>, &amp;alignment_check);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_MCE</span></span><br><span class="line">set_intr_gate_ist(<span class="number">18</span>, &amp;machine_check, MCE_STACK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">set_intr_gate(<span class="number">19</span>, &amp;simd_coprocessor_error);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reserve all the builtin and the syscall vector: */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FIRST_EXTERNAL_VECTOR; i++)</span><br><span class="line">set_bit(i, used_vectors);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IA32_EMULATION</span></span><br><span class="line">set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);</span><br><span class="line">set_bit(IA32_SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</span><br><span class="line">set_bit(SYSCALL_VECTOR, used_vectors);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Should be a barrier for any external CPU state:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cpu_init();</span><br><span class="line"></span><br><span class="line">x86_init.irqs.trap_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中进行了大量中断处理函数的设置，注意到其中有这么一句：<br><code>set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</code></p><p>而<code>SYSCALL_VECTOR</code>是多少呢？</p><p>其在<code>/arch/x86/include/asm/irq_vectors.h</code>中定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SYSCALL_VECTOR 0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>是熟悉的<code>0x80</code>，那么<code>system_call</code>，就是这个中断发生时候的处理函数咯。</p><p>我们再找找，看看这个函数具体内容。</p><h4><span id="system_call">system_call</span></h4><p>其在<code>/arch/x86/kernel/entry_32.S</code>中以汇编的形式定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(system_call)</span><br><span class="line">RING0_INT_FRAME# can&apos;t unwind into user space anyway</span><br><span class="line">pushl_cfi %eax# save orig_eax</span><br><span class="line">SAVE_ALL</span><br><span class="line">GET_THREAD_INFO(%ebp) # system call tracing in operation / emulation</span><br><span class="line">testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)</span><br><span class="line">jnz syscall_trace_entry</span><br><span class="line">cmpl $(nr_syscalls), %eax</span><br><span class="line">jae syscall_badsys</span><br><span class="line">syscall_call:</span><br><span class="line">call *sys_call_table(,%eax,4)</span><br><span class="line">movl %eax,PT_EAX(%esp)# store the return value</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中<code>ENTRY</code>在<code>include/linux/linkage.h</code>中定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ENTRY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENTRY(name) \</span></span><br><span class="line">  .globl name; \</span><br><span class="line">  ALIGN; \</span><br><span class="line">  name:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在<code>system_call</code>中经过一系列处理，最终调用<br><code>call *sys_call_table(,%eax,4)</code><br>也就是说系统调用号保存在<code>%rax</code>中，并根据其值在系统调用表<code>sys_call_table</code>中进行查找，然后调用其值。</p><h4><span id="sys_call_table-32系统的初始化">sys_call_table 32系统的初始化</span></h4><p>32位系统的初始化比较直接，其在<code>arch/x86/kernel/syscall_table_32.S</code>直接定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line">.long sys_restart_syscall/* 0 - old &quot;setup()&quot; system call, used for restarting */</span><br><span class="line">.long sys_exit</span><br><span class="line">.long ptregs_fork</span><br><span class="line">.long sys_read</span><br><span class="line">.long sys_write</span><br><span class="line">.long sys_open/* 5 */</span><br><span class="line">.long sys_close</span><br><span class="line">.long sys_waitpid</span><br><span class="line">.long sys_creat</span><br></pre></td></tr></table></figure><h4><span id="sys_call_table-64系统的初始化">sys_call_table 64系统的初始化</span></h4><p>64位系统的初始化稍微复杂，其定义在<code>arch/x86/kernel/syscall_64.c</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* System call table for x86-64. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/linkage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cache.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/asm-offsets.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NO_STUBS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) extern asmlinkage void sym(void) ;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_64.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) [nr] = sym,</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sys_call_ptr_t</span>)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sys_ni_syscall</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Smells like a like a compiler bug -- it doesn't work</span></span><br><span class="line"><span class="comment">*when the &amp; below is removed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line">#include &lt;<span class="keyword">asm</span>/unistd_64.h&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，<code>sys_call_table</code>是一个数组，其值为<code>typedef void (*sys_call_ptr_t)(void);</code>类型的函数指针。</p><p>在其中<code>#include &lt;asm/unistd_64.h&gt;</code>两次，有什么作用，又有什么区别呢？</p><p>直接看看<code>asm/unistd_64.h</code>文件内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file contains the system call numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: holes are not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* at least 8 syscall per cacheline */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read0</span></span><br><span class="line">__SYSCALL(__NR_read, sys_read)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write1</span></span><br><span class="line">__SYSCALL(__NR_write, sys_write)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open2</span></span><br><span class="line">__SYSCALL(__NR_open, sys_open)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close3</span></span><br><span class="line">__SYSCALL(__NR_close, sys_close)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat4</span></span><br><span class="line">__SYSCALL(__NR_stat, sys_newstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat5</span></span><br><span class="line">__SYSCALL(__NR_fstat, sys_newfstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat6</span></span><br><span class="line">__SYSCALL(__NR_lstat, sys_newlstat)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll7</span></span><br><span class="line">__SYSCALL(__NR_poll, sys_poll)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在其中定义了每个系统调用对应的调用号</p><p>那么再回头看看<code>arch/x86/kernel/syscall_64.c</code>文件内容，其首先对<code>__SYSCALL</code>进行重新定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) extern asmlinkage void sym(void) ;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/unistd_64.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这样就可以对每个系统调用原型进行声明，其展开为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">extern</span> asmlinkage <span class="keyword">void</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> asmlinkage <span class="keyword">void</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>继续往下看，其对<code>__SYSCALL</code>又进行重定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __SYSCALL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL(nr, sym) [nr] = sym,</span></span><br></pre></td></tr></table></figure><p>所以，<code>sys_call_table</code>展开为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Smells like a like a compiler bug -- it doesn't work</span></span><br><span class="line"><span class="comment">*when the &amp; below is removed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>] = sys_read,</span><br><span class="line">[<span class="number">1</span>] = sys_write,</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如此，根据系统调用号，即可在<code>sys_call_table</code>中找到对应的系统调用函数。</p><h4><span id="终">终</span></h4><p>至此，<code>sys_call_table</code>中保存了系统调用的处理地址，执行<code>call *sys_call_table(,%rax,4)</code>即可转入对应系统调用函数进行真正处理。</p><p>精简流程为：<br><code>int 0x80</code>触发软中断<br>-&gt;<br>在中断向量表中查找处理函数，<code>system_call</code><br>-&gt;<br>根据<code>%rax</code>值(系统调用号)查找系统调用处理函数<br>-&gt;<br>执行系统调用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux系统调用流程分析&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux信号投递机制</title>
    <link href="http://www.xiaocc.xyz/2019-01-15/Linux%E4%BF%A1%E5%8F%B7%E6%8A%95%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.xiaocc.xyz/2019-01-15/Linux信号投递机制/</id>
    <published>2019-01-15T14:00:00.000Z</published>
    <updated>2019-01-15T15:00:34.828Z</updated>
    
    <content type="html"><![CDATA[<p>分析Linux信号投递流程</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>最近在学习CMU的计算机系统课程，<code>CSAPP —— Computer Systems: A Programmer&#39;s Perspective</code>，这英文名估计很多人没听说，但是其书的中文名《深入理解计算机系统》，相信大家一定听过。</p><p>我学习的是<em>Fall 2018</em>版，<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f18/www/schedule.html" target="_blank" rel="noopener">课程schedule地址</a></p><p>在<code>ECF: Signals &amp; Nonlocal Jumps</code>这一章中提到：<br>如果进程有信号k处于<code>pending</code>状态，那么，其它投递到该进程的信号k，将被丢弃。</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190115-221302.jpg" alt=""></p><p>由于对这块只有个模糊的印象，所以怀着探索精神，决定深入源码一探究竟。</p><h4><span id="信号投递">信号投递</span></h4><p>不管是glibc的kill函数，还是linux的kill命令，最终都是调用得<code>kill</code>系统调用，且其函数名为<code>sys_kill</code>，只不过新版本的内核，从安全性角度考虑，用宏对其做了复杂包装。</p><p>一般定义为<code>SYSCALL_DEFINEx</code>，其中x为参数个数</p><p>就拿<code>kill</code>系统调用来说，其glibc函数原型为：</p><p><code>int kill(pid_t pid, int sig);</code></p><p>可知其参数个数为<code>2</code>，所以推断在内核中<code>kill</code>系统调用，其声明为<code>SYSCALL_DEFINE2(kill</code>得形式，很快就能定位到其所定义的文件<code>kernel/signal.c</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  sys_kill - send a signal to a process</span></span><br><span class="line"><span class="comment"> *  @pid: the PID of the process</span></span><br><span class="line"><span class="comment"> *  @sig: signal to be sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">info.si_signo = sig;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = SI_USER;</span><br><span class="line">info.si_pid = task_tgid_vnr(current);</span><br><span class="line">info.si_uid = current_uid();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其将发送信号的<code>pid</code>、<code>uid</code>做了记录，然后转发调用<code>kill_something_info</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kill_something_info() interprets pid in interesting ways just like kill(2).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * POSIX specifies that kill(-1,sig) is unspecified, but what we have</span></span><br><span class="line"><span class="comment"> * is probably wrong.  Should make it like BSD or SYSV.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">ret = __kill_pgrp_info(sig, info,</span><br><span class="line">pid ? find_vpid(-pid) : task_pgrp(current));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_process(p) &#123;</span><br><span class="line"><span class="keyword">if</span> (task_pid_vnr(p) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">!same_thread_group(p, current)) &#123;</span><br><span class="line"><span class="keyword">int</span> err = group_send_sig_info(sig, info, p);</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">if</span> (err != -EPERM)</span><br><span class="line">retval = err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = count ? retval : -ESRCH;</span><br><span class="line">&#125;</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里假定给特定进程发信号，所以<code>pid &gt; 0</code>，然后调用<code>kill_pid_info</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill_pid_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error = -ESRCH;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">retry:</span><br><span class="line">p = pid_task(pid, PIDTYPE_PID);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">error = group_send_sig_info(sig, info, p);</span><br><span class="line"><span class="keyword">if</span> (unlikely(error == -ESRCH))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The task was unhashed in between, try again.</span></span><br><span class="line"><span class="comment"> * If it is dead, pid_task() will return NULL,</span></span><br><span class="line"><span class="comment"> * if we race with de_thread() it will find the</span></span><br><span class="line"><span class="comment"> * new leader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其调用<code>group_send_sig_info</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * send signal info to all the members of a group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">group_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">ret = check_kill_permission(sig, info, p);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line">ret = do_send_sig_info(sig, info, p, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其调用<code>do_send_sig_info</code>，并将第4个参数设置为<code>true</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">int</span> ret = -ESRCH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lock_task_sighand(p, &amp;flags)) &#123;</span><br><span class="line">ret = send_signal(sig, info, p, group);</span><br><span class="line">unlock_task_sighand(p, &amp;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，<code>group</code>参数为<code>true</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">send_signal</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *t,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> from_ancestor_ns = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PID_NS</span></span><br><span class="line">from_ancestor_ns = si_fromuser(info) &amp;&amp;</span><br><span class="line">   !task_pid_nr_ns(current, task_active_pid_ns(t));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> __send_signal(sig, info, t, group, from_ancestor_ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="__send_signal">__send_signal</span></h4><p>关键函数来了，就是这货</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *t,</span><br><span class="line"><span class="keyword">int</span> group, <span class="keyword">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="keyword">int</span> override_rlimit;</span><br><span class="line"></span><br><span class="line">trace_signal_generate(sig, info, t);</span><br><span class="line"></span><br><span class="line">assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prepare_signal(sig, t, from_ancestor_ns))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Short-circuit ignored signals and support queuing</span></span><br><span class="line"><span class="comment"> * exactly one non-rt signal, so that we can get more</span></span><br><span class="line"><span class="comment"> * detailed information about the cause of the signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fast-pathed signals for kernel-internal things like SIGSTOP</span></span><br><span class="line"><span class="comment"> * or SIGKILL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (info == SEND_SIG_FORCED)</span><br><span class="line"><span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment"> * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment"> * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment"> * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment"> * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment"> * make sure at least one signal gets delivered and don't</span></span><br><span class="line"><span class="comment"> * pass on the info struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,</span><br><span class="line">override_rlimit);</span><br><span class="line"><span class="keyword">if</span> (q) &#123;</span><br><span class="line">list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_USER;</span><br><span class="line">q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">task_active_pid_ns(t));</span><br><span class="line">q-&gt;info.si_uid = current_uid();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line"><span class="keyword">if</span> (from_ancestor_ns)</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info)) &#123;</span><br><span class="line"><span class="keyword">if</span> (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue overflow, abort.  We may abort if the</span></span><br><span class="line"><span class="comment"> * signal was rt and sent by user using something</span></span><br><span class="line"><span class="comment"> * other than kill().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trace_signal_overflow_fail(sig, group, info);</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a silent loss of information.  We still</span></span><br><span class="line"><span class="comment"> * send the signal, but the *info bits are lost.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">trace_signal_lose_info(sig, group, info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">signalfd_notify(t, sig);</span><br><span class="line">sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">complete_signal(sig, t, group);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>group</code>为<code>true</code>，所以</p><p><code>pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</code></p><p>选择将信号投递到进程的<code>shared_pending</code>中</p><p>接着往下看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">legacy_queue</span><span class="params">(struct sigpending *signals, <span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (sig &lt; SIGRTMIN) &amp;&amp; sigismember(&amp;signals-&gt;signal, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果<code>sig &lt; SIGRTMIN</code>，也就是常说的传统信号、非实时信号、非可靠信号。<br>并且，该进程已经投递过该信号<code>sigismember(&amp;signals-&gt;signal, sig)</code>，<br><code>legacy_queue</code>将返回<code>true</code>，这时，<code>__send_signal</code>将直接结束，不会再次投递该信号。</p><p>至此心中的谜团解开</p><p>而对于<code>sig &gt;= SIGRTMIN</code>，也就是常说的实时信号，会进行排队。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析Linux信号投递流程&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>JMeter压测工具之使用</title>
    <link href="http://www.xiaocc.xyz/2019-01-11/JMeter%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.xiaocc.xyz/2019-01-11/JMeter压测工具/</id>
    <published>2019-01-11T06:30:00.000Z</published>
    <updated>2019-01-11T07:37:39.083Z</updated>
    
    <content type="html"><![CDATA[<p><code>Apache JMeter</code>压测工具，简介与使用</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>目前后台服务采用<code>restful</code>模式，网络层使用<code>Http + Json</code>，交互模式比较通用，排查问题时候，<code>Json</code>格式也比较易于阅读。</p><p>之前采用<code>Tcp + 自定义数据格式</code>的交互模式，排查问题比较头疼，就算采用<code>tcpdump</code>等抓包工具，由于数据是二进制格式，非常不直白。</p><p>采用<code>Http</code>协议还有一个重大好处，就是可以直接使用非常多的测试、Debug工具。</p><p>这次需要对服务器性能进行测试，压测每个接口的性能上限，以利于部署机器。</p><p>所以，找到了鼎鼎大名的<code>JMeter</code>，使用过后，强烈推荐。</p><h4><span id="使用">使用</span></h4><p>由于<code>JMeter</code>支持的功能非常非常多，整个软件很复杂，如果只是想进行接口性能测试，只需要了解几个基本用法就行。</p><ul><li><p>创建一个<code>线程组</code><br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190111-150504.jpg" alt=""></p></li><li><p><code>线程组</code>相关字段解释<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190111-150758.jpg" alt=""></p><ul><li><code>线程数</code>，可以理解为发起请求的用户数</li><li><code>Ramp-Up时间</code>，创建完全部<code>线程数</code>需要的时间。可以这么理解，如果<code>线程数</code>设置为<code>100</code>，<code>Ramp-Up时间</code>设置为<code>1</code>，相当于100个用户在1秒内顺次发起请求，一个用户发起请求后，下一个用户等待10ms，然后才发起请求，总耗时：<code>100 * 10ms = 1s</code>。</li><li><code>循环次数</code>，如果勾选<code>永远</code>，一个<code>Ramp-Up时间</code>结束后，重新开始一个新的周期。</li></ul><p><strong>所以，如果想以<code>200qps</code>的速度测试某个接口，可以将线程数设置为200，Ramp-Up设置为1</strong></p></li><li><p>线程组配置完毕后，可以进行测试接口相关配置，由于我们需要进行<code>Http</code>接口测试，所以添加一个<code>Http</code>类型的取样器<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190111-151723.jpg" alt="">  </p></li><li><p>在这个<code>Http</code>取样器中，我们只是简单的访问了一下百度<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190111-152128.jpg" alt=""><br><em>可以对<code>Http</code>请求进行额外的配置，例如添加Header信息等，均在<code>配置元件</code>栏目中</em></p></li><li><p>为了查看<code>Http</code>请求的响应结果，我们添加<code>监听器</code>栏目中的<code>查看结果树</code></p></li><li><p>为了进行接口性能统计，我们添加<code>监听器</code>栏目中的<code>汇总报告</code><br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190111-152734.jpg" alt=""></p></li><li><p>点击启动后，可以查看<code>Http</code>服务响应数据信息<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20190111-153025.jpg" alt=""></p></li><li><p>在<code>汇总报告</code>中可以查询请求耗时及<code>qps</code>等等数据</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Apache JMeter&lt;/code&gt;压测工具，简介与使用&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.xiaocc.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux中OOM Killer分数计算规则</title>
    <link href="http://www.xiaocc.xyz/2018-12-28/OOM%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99/"/>
    <id>http://www.xiaocc.xyz/2018-12-28/OOM计算规则/</id>
    <published>2018-12-28T14:30:00.000Z</published>
    <updated>2018-12-28T15:38:06.808Z</updated>
    
    <content type="html"><![CDATA[<p>分析内存不足时候，OOM Killer计算规则</p><a id="more"></a><h4><span id="前言">前言</span></h4><p>我们知道，当系统内存不足时，内核会找到一个<em>倒霉鬼</em>，将其kill并释放内存。</p><p>那么，这个查找规则是什么，是随机选取，还是按照进程的内存占用量倒排？</p><p>如何保证重要业务进程不被kill？</p><p>依然记得某天下午突然收到一条告警短信，进程不存在！赶紧将流量从这台机器切走，并排查进程异常的原因，最终在系统message中找到，<strong>OOM</strong>，心累。</p><h4><span id="oom触发流程">OOM触发流程</span></h4><p>访问内存时，如果物理页未分配会引发缺页中断，并最终引发OOM算分。</p><p>流程如下：<br><code>do_page_fault</code> -&gt; <code>out_of_memory</code> -&gt; <code>select_bad_process</code> -&gt; <code>oom_badness</code>。</p><p>在<code>oom_badness</code>即会对进程计算分数，分数越高被kill可能性越高。</p><h4><span id="详细计算规则">详细计算规则</span></h4><p>Linux最初版计算分数时候，只考虑内存使用量这个维度，可以预见该计算规则考虑不全面。</p><h5><span id="v2639版本">v2.6.39版本</span></h5><p>该版本实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oom_badness - heuristic function to determine which candidate task to kill</span></span><br><span class="line"><span class="comment"> * @p: task struct of which task we should calculate</span></span><br><span class="line"><span class="comment"> * @totalpages: total present RAM allowed for page allocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The heuristic for determining which task to kill is made to be as simple and</span></span><br><span class="line"><span class="comment"> * predictable as possible.  The goal is to return the highest value for the</span></span><br><span class="line"><span class="comment"> * task consuming the most memory to avoid subsequent oom failures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">oom_badness</span><span class="params">(struct task_struct *p, struct mem_cgroup *mem,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">nodemask_t</span> *nodemask, <span class="keyword">unsigned</span> <span class="keyword">long</span> totalpages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> points;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oom_unkillable_task(p, mem, nodemask))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p = find_lock_task_mm(p);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Shortcut check for a thread sharing p-&gt;mm that is OOM_SCORE_ADJ_MIN</span></span><br><span class="line"><span class="comment"> * so the entire heuristic doesn't need to be executed for something</span></span><br><span class="line"><span class="comment"> * that cannot be killed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;p-&gt;mm-&gt;oom_disable_count)) &#123;</span><br><span class="line">task_unlock(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the PF_OOM_ORIGIN bit is set, it indicates the task should have</span></span><br><span class="line"><span class="comment"> * priority for oom killing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; PF_OOM_ORIGIN) &#123;</span><br><span class="line">task_unlock(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The memory controller may have a limit of 0 bytes, so avoid a divide</span></span><br><span class="line"><span class="comment"> * by zero, if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!totalpages)</span><br><span class="line">totalpages = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The baseline for the badness score is the proportion of RAM that each</span></span><br><span class="line"><span class="comment"> * task's rss, pagetable and swap space use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">points = get_mm_rss(p-&gt;mm) + p-&gt;mm-&gt;nr_ptes;</span><br><span class="line">points += get_mm_counter(p-&gt;mm, MM_SWAPENTS);</span><br><span class="line"></span><br><span class="line">points *= <span class="number">1000</span>;</span><br><span class="line">points /= totalpages;</span><br><span class="line">task_unlock(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Root processes get 3% bonus, just like the __vm_enough_memory()</span></span><br><span class="line"><span class="comment"> * implementation used by LSMs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (has_capability_noaudit(p, CAP_SYS_ADMIN))</span><br><span class="line">points -= <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may</span></span><br><span class="line"><span class="comment"> * either completely disable oom killing or always prefer a certain</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">points += p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Never return 0 for an eligible task that may be killed since it's</span></span><br><span class="line"><span class="comment"> * possible that no single user task uses more than 0.1% of memory and</span></span><br><span class="line"><span class="comment"> * no single admin tasks uses more than 3.0%.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (points &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (points &lt; <span class="number">1000</span>) ? points : <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该版本考虑维度如下：<br>rss、pagetable、swap使用量、是否root进程</p><p>可以通过调整<code>/proc/pid/oom_score_adj</code>值，对最终分数进行调整。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_SCORE_ADJ_MIN(-1000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_SCORE_ADJ_MAX1000</span></span><br></pre></td></tr></table></figure><p><strong>其中设置值为<code>OOM_SCORE_ADJ_MIN</code>，进程不会被kill。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析内存不足时候，OOM Killer计算规则&lt;/p&gt;
    
    </summary>
    
      <category term="编程理论" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>利用redis进行无密码登录服务器</title>
    <link href="http://www.xiaocc.xyz/2018-12-23/%E5%88%A9%E7%94%A8redis%E8%BF%9B%E8%A1%8C%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>http://www.xiaocc.xyz/2018-12-23/利用redis进行无密码登录/</id>
    <published>2018-12-23T12:30:00.000Z</published>
    <updated>2018-12-23T12:52:17.954Z</updated>
    
    <content type="html"><![CDATA[<p>分析如何利用redis进行无密码登录服务器</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>前段时间，几台服务器被侵入并植入挖坑程序，搜索相关资料后，发现可以利用redis进行无密码登录，特别是redis用root用户启动，并暴露端口在外网能够访问。</p><p>特此记录，以备忘，redis高版本已修复该问题。</p><h4><span id="操作流程">操作流程</span></h4><p>由于redis没有严格的权限分离，也没有账号系统，只要知道redis绑定的ip、port，就可以进行登录，如果redis密码未设置，或者密码复杂度较低，很容易连接上来进行redis运维命令操作。</p><p>这里介绍如何利用redis进行无密码登录，主要涉及其运维命令。</p><p>核心即是，将个人ssh公钥保存到<code>/root/.ssh/</code>目录下，文件名为<code>authorized_keys</code>，即可实现ssh的无密码登录。</p><ul><li>flushall</li><li>config get dir</li><li>config get dbfilename</li><li>config set dir /root/.ssh</li><li>config set dbfilename authorized_keys</li><li>set xxxx WW</li><li>save</li></ul><p>将WW更改为个人ssh公钥即可</p><p>操作完毕后即可发现在<code>/root/.ssh</code>目录下新增<code>authorized_keys</code>文件，其内容中包含个人ssh公钥。</p><p>至此即可实现无密码登录服务器。</p><p>备注：经过实验，新版redis修改了rdb备份文件格式，该方式不再有效，不过<code>2.x</code>版本存在该漏洞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析如何利用redis进行无密码登录服务器&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux程序装载与运行流程分析</title>
    <link href="http://www.xiaocc.xyz/2018-12-19/linux%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
    <id>http://www.xiaocc.xyz/2018-12-19/linux程序装载与运行/</id>
    <published>2018-12-19T14:30:00.000Z</published>
    <updated>2018-12-21T15:16:29.559Z</updated>
    
    <content type="html"><![CDATA[<p>分析Linux程序如何装载与运行</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>在上篇中我们提到如何修改进程名称，其中有一个预设条件：argv数据与environ数据，呈现为紧凑型布局。</p><p>本篇将实地验证这个假设，要想知道这两种数据的内存布局，只能从程序启动流程开始排查，这样就涉及到程序的装载与运行流程。</p><h4><span id="程序如何启动">程序如何启动</span></h4><p>我们启动程序一般都是在命令行中，其实是在与<code>shell</code>打交道，然后<code>shell</code>帮我们启动程序，并传递相关参数。</p><p><code>strace</code>工具能够追踪一个程序执行的系统调用，因而我们构造一个简单的空程序，并在命令行执行：<br><code>strace ./a.out -a -b</code></p><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;./a.out&quot;, [&quot;./a.out&quot;, &quot;-a&quot;, &quot;-b&quot;], 0x7fffc9651ce0 /* 44 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x82f000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb9c2c80000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可见，<code>shell</code>启动程序时执行的第一个系统调用为<code>execve</code>，在glibc库函数中的<code>exec</code>函数族：<br><code>execl, execlp, execle, execv, execvp, execvpe</code>最终即是调用得该系统调用。</p><p><code>man execl</code>，看看该函数的作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The  exec()  family  of  functions replaces the current process image with a new process image.  </span><br><span class="line">The functions described in this manual page are front-ends for execve(2).  </span><br><span class="line">(See the manual page for execve(2) for further details about the replacement  of  the current process image.)</span><br></pre></td></tr></table></figure><p>可见该函数族作用就是清空当前进程并装载新进程。</p><h4><span id="execve"><code>execve</code></span></h4><p>我们看看该系统调用得代码：<br><a href="https://elixir.bootlin.com/linux/v2.6.36/source/arch/s390/kernel/process.c#L270" target="_blank" rel="noopener">execve在线代码</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_execve() executes a new program.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(execve, <span class="keyword">const</span> <span class="keyword">char</span> __user *, name,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, argv,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, envp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span> = <span class="title">task_pt_regs</span>(<span class="title">current</span>);</span></span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">long</span> rc;</span><br><span class="line"></span><br><span class="line">filename = getname(name);</span><br><span class="line">rc = PTR_ERR(filename);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(filename))</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">rc = do_execve(filename, argv, envp, regs);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">execve_tail();</span><br><span class="line">rc = regs-&gt;gprs[<span class="number">2</span>];</span><br><span class="line">out:</span><br><span class="line">putname(filename);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工作其实由<code>do_execve</code>完成，再看看该函数：</p><h4><span id="do_execve"><code>do_execve</code></span></h4><p><a href="https://elixir.bootlin.com/linux/v2.6.36/source/fs/exec.c#L1334" target="_blank" rel="noopener">do_execve在线代码</a></p><p>精简后的核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_execve() executes a new program.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *argv,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *envp,</span></span></span><br><span class="line"><span class="function"><span class="params">struct pt_regs * regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    file = open_exec(filename);</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    retval = bprm_mm_init(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">    <span class="keyword">goto</span> out_file;</span><br><span class="line">    </span><br><span class="line">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line">    <span class="keyword">if</span> ((retval = bprm-&gt;argc) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class="line">    <span class="keyword">if</span> ((retval = bprm-&gt;envc) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line">    retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    current-&gt;flags &amp;= ~PF_KTHREAD;</span><br><span class="line">    retval = search_binary_handler(bprm,regs);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有我们要的关键信息，计算<code>argv</code>、<code>env</code>的数量，并拷贝相关数据，这里有个奇怪的点，它为什么是先拷贝的<code>env</code>，然后再拷贝的<code>argv</code>，按照上一篇的内存布局图，应该是先<code>argv</code>，再<code>env</code>？</p><p>只能详细看看<code>copy_strings</code>的实现：</p><h4><span id="copy_strings"><code>copy_strings</code></span></h4><p><a href="https://elixir.bootlin.com/linux/v2.6.36/source/fs/exec.c#L393" target="_blank" rel="noopener">copy_strings在线代码</a></p><p>它的注释解释得很清楚</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 'copy_strings()' copies argument/environment strings from the old</span></span><br><span class="line"><span class="comment"> * processes's memory to the new process's stack.  The call to get_user_pages()</span></span><br><span class="line"><span class="comment"> * ensures the destination page is created and not swapped out.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>它从旧的进程内存中往新进程的<code>stack</code>中拷贝数据，而<code>stack</code>一般是从高地址向低地址生长，所以要先拷贝<code>env</code>，再拷贝<code>argv</code>。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181219-232948.jpg" alt=""></p><p>并且其实现中：<br><code>while (argc-- &gt; 0)</code> 从数组最后一个元素开始拷贝<br><code>bprm-&gt;p -= len;</code> 栈指针向下生长</p><p>至此就能够解释为何<code>argv</code>、<code>env</code>数据为连续紧凑型存储。</p><h4><span id="程序装载">程序装载</span></h4><p>在<code>do_execve</code>中接下来会调用<br><code>retval = search_binary_handler(bprm,regs);</code><br>就涉及到程序的装载<br><a href="https://elixir.bootlin.com/linux/v2.6.36/source/fs/exec.c#L1255" target="_blank" rel="noopener">函数在线代码</a></p><p>关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(fmt, &amp;formats, lh) &#123;</span><br><span class="line">    <span class="keyword">int</span> (*fn)(struct linux_binprm *, struct pt_regs *) = fmt-&gt;load_binary;</span><br><span class="line">    <span class="keyword">if</span> (!fn)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(fmt-&gt;<span class="keyword">module</span>))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    read_unlock(&amp;binfmt_lock);</span><br><span class="line">    retval = fn(bprm, regs);</span><br></pre></td></tr></table></figure><h5><span id="formats">formats</span></h5><p>其会遍历<code>formats</code>列表，找到合适的可装载格式，linux下编译出来的可执行程序格式一般为<code>ELF</code>格式。<br>其对应的<code>load_binary</code>函数为<code>load_elf_binary</code></p><p>我们看看<code>formats</code>列表是如何赋值的</p><p>在<code>fs/binfmt_elf.c</code>文件中，该文件会编译成为一个模块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_elf_binfmt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> register_binfmt(&amp;elf_format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">exit_elf_binfmt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Remove the COFF and ELF loaders. */</span></span><br><span class="line">unregister_binfmt(&amp;elf_format);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core_initcall(init_elf_binfmt);</span><br><span class="line">module_exit(exit_elf_binfmt);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><h5><span id="init_elf_binfmt">init_elf_binfmt</span></h5><p>在模块初始化的时候会调用<code>init_elf_binfmt</code>函数，其会转而调用<code>register_binfmt</code>函数，参数为<code>elf_format</code>，该结构数据如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> = &#123;</span></span><br><span class="line">.<span class="keyword">module</span>= THIS_MODULE,</span><br><span class="line">.load_binary= load_elf_binary,</span><br><span class="line">.load_shlib= load_elf_library,</span><br><span class="line">.core_dump= elf_core_dump,</span><br><span class="line">.min_coredump= ELF_EXEC_PAGESIZE,</span><br><span class="line">.hasvdso= <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以清晰的看到<code>elf_format.load_binary</code>赋值为<code>load_elf_binary</code>。</p><p>再看看这个<code>elf_format</code>是如何注册到<code>formats</code>列表上面的</p><p><code>register_binfmt</code>函数最终会调用到<code>__register_binfmt</code>，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __register_binfmt(struct linux_binfmt * fmt, <span class="keyword">int</span> insert)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!fmt)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">write_lock(&amp;binfmt_lock);</span><br><span class="line">insert ? list_add(&amp;fmt-&gt;lh, &amp;formats) :</span><br><span class="line"> list_add_tail(&amp;fmt-&gt;lh, &amp;formats);</span><br><span class="line">write_unlock(&amp;binfmt_lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，其通过调用<code>list_add_tail</code>方法将<strong>fmt</strong>数据挂载到<code>formats</code>结构，至此，<code>ELF</code>格式的程序能被系统识别并加载。</p><h5><span id="加载程序-load_elf_binary">加载程序 load_elf_binary</span></h5><p><a href="https://elixir.bootlin.com/linux/v2.6.36/source/fs/binfmt_elf.c#L564" target="_blank" rel="noopener">在线代码</a></p><p>先检查可执行文件头部Magic是否为<code>ELF</code>格式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>ELFMAG<span class="meta-string">"\177ELF"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SELFMAG4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* First of all, some simple consistency checks */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(loc-&gt;elf_ex.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure><p>然后读取头部header信息，找到<code>if (elf_ppnt-&gt;p_type == PT_INTERP)</code>这个段，这个段表示可执行程序运行时，需要依赖动态链接库解释器。</p><p>执行<code>readelf -l a.out</code>可以查看可执行程序相关段信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238</span><br><span class="line">               0x000000000000001c 0x000000000000001c  R      0x1</span><br><span class="line">    [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br></pre></td></tr></table></figure><p>所以在<code>load_elf_binary</code>中，会读取<code>interpreter</code>这个头的字符串，其值为解释器程序的路径，再以该路径读取解释器程序本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">retval = kernel_read(bprm-&gt;file, elf_ppnt-&gt;p_offset,</span><br><span class="line">     elf_interpreter,</span><br><span class="line">     elf_ppnt-&gt;p_filesz);</span><br><span class="line"><span class="keyword">if</span> (retval != elf_ppnt-&gt;p_filesz) &#123;</span><br><span class="line"><span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">retval = -EIO;</span><br><span class="line"><span class="keyword">goto</span> out_free_interp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* make sure path is NULL terminated */</span></span><br><span class="line">retval = -ENOEXEC;</span><br><span class="line"><span class="keyword">if</span> (elf_interpreter[elf_ppnt-&gt;p_filesz - <span class="number">1</span>] != <span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">goto</span> out_free_interp;</span><br><span class="line"></span><br><span class="line">interpreter = open_exec(elf_interpreter);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">retval = kernel_read(interpreter, <span class="number">0</span>, bprm-&gt;buf,</span><br><span class="line">     BINPRM_BUF_SIZE);</span><br><span class="line"><span class="keyword">if</span> (retval != BINPRM_BUF_SIZE) &#123;</span><br><span class="line"><span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">retval = -EIO;</span><br><span class="line"><span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the exec headers */</span></span><br><span class="line">loc-&gt;interp_elf_ex = *((struct elfhdr *)bprm-&gt;buf);</span><br></pre></td></tr></table></figure><p>新进程的入口点如何确定？</p><p>通过阅读代码可以发现，依赖动态链接库的程序，其进程入口点为解释器entry，否则为程序本身entry。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (elf_interpreter) &#123;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">uninitialized_var</span><span class="params">(interp_map_addr)</span></span>;</span><br><span class="line"></span><br><span class="line">elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,</span><br><span class="line">    interpreter,</span><br><span class="line">    &amp;interp_map_addr,</span><br><span class="line">    load_bias);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR((<span class="keyword">void</span> *)elf_entry)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * load_elf_interp() returns relocation</span></span><br><span class="line"><span class="comment"> * adjustment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interp_load_addr = elf_entry;</span><br><span class="line">elf_entry += loc-&gt;interp_elf_ex.e_entry;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">elf_entry = loc-&gt;elf_ex.e_entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retval = create_elf_tables(bprm, &amp;loc-&gt;elf_ex,</span><br><span class="line">  load_addr, interp_load_addr);</span><br><span class="line">  </span><br><span class="line">start_thread(regs, elf_entry, bprm-&gt;p);</span><br></pre></td></tr></table></figure><p>在<code>create_elf_tables</code>函数中会设置<code>argv</code>、<code>env</code>指针数组的值，注意，这里只是将各个字符串的指针设置到<code>argv</code>、<code>env</code>数组中。</p><p>最后调用<code>start_thread</code>并传入<code>elf_entry</code>作为入口点，<code>elf_entry</code>可能为解释器entry，其会加载动态链接库等准备工作，然后转到程序自身entry执行。</p><p>至此，程序加载并启动执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析Linux程序如何装载与运行&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>如何修改进程名称</title>
    <link href="http://www.xiaocc.xyz/2018-12-16/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E8%BF%9B%E7%A8%8B%E5%90%8D%E7%A7%B0/"/>
    <id>http://www.xiaocc.xyz/2018-12-16/如何修改进程名称/</id>
    <published>2018-12-16T14:30:00.000Z</published>
    <updated>2018-12-17T15:02:56.670Z</updated>
    
    <content type="html"><![CDATA[<p>分析如何修改进程名称，以利于更清楚的展示进程相关信息</p><a id="more"></a><h4><span id="引子">引子</span></h4><p>最近服务器中了挖矿病毒，CPU暴涨，<code>top</code>查看到的高负载进程名为随机字母。<br>一般情况下进程名为可执行文件名，执行<code>cat /proc/{pid}/exe</code>，查看可执行文件路径，可执行文件已经被删除。</p><p>网上搜索相关资料，找到一个有意思的问题，如何修改进程名称？</p><p>在<code>redis</code>、<code>nginx</code>中有修改进程名的相关实现，函数为<code>setproctitle</code>。<br>在<code>nginx</code>中有详细的原理解释。</p><h4><span id="核心">核心</span></h4><p>如<code>nginx</code>中注释所言：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * To change the process title in Linux and Solaris we have to set argv[1]</span><br><span class="line"> * to NULL and to copy the title to the same place where the argv[0] points to.</span><br><span class="line"> * However, argv[0] may be too small to hold a new title.  Fortunately, Linux</span><br><span class="line"> * and Solaris store argv[] and environ[] one after another.  So we should</span><br><span class="line"> * ensure that is the continuous memory and then we allocate the new memory</span><br><span class="line"> * for environ[] and copy it.  After this we could use the memory starting</span><br><span class="line"> * from argv[0] for our process title.</span><br><span class="line"> *</span><br><span class="line"> * The Solaris&apos;s standard /bin/ps does not show the changed process title.</span><br><span class="line"> * You have to use &quot;/usr/ucb/ps -w&quot; instead.  Besides, the UCB ps does not</span><br><span class="line"> * show a new title if its length less than the origin command line length.</span><br><span class="line"> * To avoid it we append to a new title the origin command line in the</span><br><span class="line"> * parenthesis.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>进程名及命令行参数保存在<code>argv</code>数组中，而相关环境变量则保存在<code>environ</code>数组中，其内存布局如图：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181216-231645.jpg" alt=""></p><p>可见命令行参数与环境变量是紧凑型存储在一块连续的内存。</p><p>想要改变进程名就得改变<code>argv[0]</code>的值，如果直接设置新进程名，当其过长，会将这块内存区域写坏。</p><p>那该如何实现？</p><h4><span id="实现">实现</span></h4><p>这里采用的方式是给<code>environ</code>数据重新分配一块空间，并改变<code>environ</code>指针数组的值，让其每个指针指向新数据对应地址。<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181216-232458.jpg" alt=""></p><p>这样<code>argv[0]</code>就有足够空间设置新进程名。</p><h4><span id="注意">注意</span></h4><p>如果新进程名比原进程名短，需要先清空<code>argv[0]</code>指向的数据，然后再设置。<br><code>environ</code>可通过<code>extern char** environ</code>获得。</p><p><em>TODO：分析为何argv、environ为连续紧凑型存储</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析如何修改进程名称，以利于更清楚的展示进程相关信息&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>协程原理解析(3)</title>
    <link href="http://www.xiaocc.xyz/2018-12-14/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%903/"/>
    <id>http://www.xiaocc.xyz/2018-12-14/协程原理解析3/</id>
    <published>2018-12-14T14:30:00.000Z</published>
    <updated>2018-12-15T14:51:27.463Z</updated>
    
    <content type="html"><![CDATA[<p>分析cloudwu(云风)协程库的具体实现</p><a id="more"></a><h4><span id="引子">引子</span></h4><p>前两篇分析了协程库的基本用法及四大函数具体实现，本篇分析一个协程库的具体例子。</p><p>云风多年之前用C语言实现过一个协程库，采用非对称式、<code>stackful</code>模式、未hook系统函数、不提供协程调度功能。<br>源码只有200多行，实现简洁，非常教科书式，对于协程刚入门用户可谓佳品。</p><p>其代码库地址：<a href="https://github.com/cloudwu/coroutine" target="_blank" rel="noopener">云风协程库</a></p><h4><span id="库的用法">库的用法</span></h4><p>我们先看该库的用法，再研究具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"coroutine.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">foo(struct schedule * S, <span class="keyword">void</span> *ud) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> * <span class="title">arg</span> = <span class="title">ud</span>;</span></span><br><span class="line"><span class="keyword">int</span> start = arg-&gt;n;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"coroutine %d : %d\n"</span>,coroutine_running(S) , start + i);</span><br><span class="line">coroutine_yield(S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">test(struct schedule *S) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg1</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">arg2</span> = &#123;</span> <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> co1 = coroutine_new(S, foo, &amp;arg1);</span><br><span class="line"><span class="keyword">int</span> co2 = coroutine_new(S, foo, &amp;arg2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main start\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (coroutine_status(S,co1) &amp;&amp; coroutine_status(S,co2)) &#123;</span><br><span class="line">coroutine_resume(S,co1);</span><br><span class="line">coroutine_resume(S,co2);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main end\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">main() &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> * <span class="title">S</span> = <span class="title">coroutine_open</span>();</span></span><br><span class="line">test(S);</span><br><span class="line">coroutine_close(S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先根据代码猜测运行意图：创建了2个协程，它们轮流输出<code>start + i</code>。</p><p>编译并运行，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">coroutine 0 : 0</span><br><span class="line">coroutine 1 : 100</span><br><span class="line">coroutine 0 : 1</span><br><span class="line">coroutine 1 : 101</span><br><span class="line">coroutine 0 : 2</span><br><span class="line">coroutine 1 : 102</span><br><span class="line">coroutine 0 : 3</span><br><span class="line">coroutine 1 : 103</span><br><span class="line">coroutine 0 : 4</span><br><span class="line">coroutine 1 : 104</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>运行结果符合我们的猜测。</p><p>大体用法：<br>通过调用<code>coroutine_open</code>创建协程环境，调用<code>coroutine_new</code>创建协程并传递工作函数指针，调用<code>coroutine_resume</code>授予协程运行权，在协程中调用<code>coroutine_yield</code>将运行权切出。</p><h4><span id="基础数据结构">基础数据结构</span></h4><p>比较重要的两个数据结构<code>schedule</code>、<code>coroutine</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">schedule</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">stack</span>[STACK_SIZE];</span><br><span class="line"><span class="keyword">ucontext_t</span> main;</span><br><span class="line"><span class="keyword">int</span> nco;</span><br><span class="line"><span class="keyword">int</span> cap;</span><br><span class="line"><span class="keyword">int</span> running;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> **<span class="title">co</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>schedule</code>是所有协程公用的一个环境，其中：</p><ul><li>stack——所有协程运行时的栈空间，新创建协程时在四大函数的<code>getcontext</code>之后，<code>makecontext</code>之前设置，协程运行时会以该空间作为栈空间</li><li>main——主协程，当创建的协程调用<code>coroutine_yield</code>切出控制权，实际上会切到主协程运行</li><li>nco——当前正在运行的协程数量</li><li>cap——协程指针容器的容量</li><li>running——当前正在运行的协程的id，如果在主协程运行，则为-1</li><li>co——指针数组，每一个指针指向一个协程</li></ul><p>内存布局如下：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181215-192541.jpg" alt=""></p><p>接下来看看<code>coroutine</code>的具体内容：</p><ul><li>func——协程运行时的工作函数</li><li>ud——工作函数的附属参数</li><li>ctx——协程的context</li><li>sch——该协程归属的<code>schedule</code></li><li>cap——拷贝栈时候申请的内存的容量</li><li>size——拷贝栈后的有效数据大小</li><li>status——协程状态</li><li>stack——拷贝栈数据申请的空间</li></ul><p>这里解释一下<code>coroutine</code>结构中的<code>stack</code>的作用：</p><p>由于协程运行时需要栈空间，我们可以选择给每个协程单独申请一块空间(例如：1M大小)，而每个协程运行时候所需空间大小不一，如果空间过小协程运行时候会由于空间不足而栈溢出，如果空间太大则整体空间浪费严重。<br>所以这里采用所有协程公用一块大空间，当协程切出时，把自己运行时候的栈内容一并拷贝，当控制权再次切回来时候，把自己的栈内容还原到公共栈空间。</p><p>示意图如下：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181215-204455.jpg" alt=""></p><p>这里可以预见当协程切换时候，涉及到大量的内存拷贝操作，这里可能成为瓶颈，如此，便可以采用独立栈结构——即每个协程一个独立栈空间。</p><h4><span id="具体实现">具体实现</span></h4><p>有了以上对两个基础数据结构的分析，接下来分析具体实现代码就比较容易。</p><h5><span id="coroutine_open"><code>coroutine_open</code></span></h5><p>内容比较简单，主要是分配空间容纳<code>coroutine</code>的指针</p><h5><span id="coroutine_close"><code>coroutine_close</code></span></h5><p>没什么好说的</p><h5><span id="coroutine_new"><code>coroutine_new</code></span></h5><p>新建协程的主要函数，在其中，如果<code>schedule</code>中容纳协程指针的空间不足，会进行扩容。<br>这个实现里面有一个<strong>比较有意思的点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;S-&gt;cap;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> id = (i+S-&gt;nco) % S-&gt;cap;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;co[id] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">S-&gt;co[id] = co;</span><br><span class="line">++S-&gt;nco;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是想找到一个空闲的槽位放置新创建的协程，我们一般会从<code>0</code>开始遍历，如果找到空闲槽位就返回下标，否则<code>i++</code>继续遍历查找。</p><p>但是这里，<code>int id = (i+S-&gt;nco) % S-&gt;cap;</code>，这是什么意思？<br>为什么不是直接取<code>i</code>，而要进行这么复杂的操作？</p><p>如下图：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181215-210628.jpg" alt=""></p><p>其中，橙色表示已分配，灰色表示未分配</p><p>由于是从下标<code>0</code>开始遍历查找空闲槽位，这样头部的槽位会优先被选中，导致后续遍历次数增加才能找到空闲槽位。<br>而<code>int id = (i+S-&gt;nco) % S-&gt;cap;</code>，则是倾向于从使用尾区开始查找，很快就能找到空闲槽位。</p><p>但是这样有个问题，随着头部的空间释放，而尾部作为使用中的空间逐渐增加，依然要遍历多次以跨过正在使用中的空间，并达不到作者想要的效果。</p><p>构造如图所示的申请与释放过程：<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181215-213819.jpg" alt=""></p><ol><li>nco=6，cap=11</li><li>新增一个协程，按照分配算法，从下标<code>5</code>开始往后查找空闲槽位，找到<code>7</code>号槽位</li><li><code>1</code>号槽位协程退出，并释放槽位</li><li>新增一个协程，由于当前nco=6，cap=11，从下标<code>5</code>开始往后查找空闲槽位，找到<code>8</code>号槽位</li></ol><p>以上分析可见，该遍历算法并无实质性优化。</p><ul><li>可以通过记录已经分配的最大下标，从该下标往后查找空闲槽位</li><li>cpu遍历速度非常快，个人认为可以从<code>0</code>开始遍历</li></ul><h5><span id="coroutine_resume"><code>coroutine_resume</code></span></h5><p>将控制权切换到协程的核心函数</p><ul><li>如果协程处于<code>COROUTINE_READY</code>状态，也就是协程刚创建，还未被调度过，则需要初始化协程context</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> COROUTINE_READY:</span><br><span class="line">getcontext(&amp;C-&gt;ctx);</span><br><span class="line">C-&gt;ctx.uc_stack.ss_sp = S-&gt;<span class="built_in">stack</span>;</span><br><span class="line">C-&gt;ctx.uc_stack.ss_size = STACK_SIZE;</span><br><span class="line">C-&gt;ctx.uc_link = &amp;S-&gt;main;</span><br><span class="line">S-&gt;running = id;</span><br><span class="line">C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line"><span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>)S;</span><br><span class="line">makecontext(&amp;C-&gt;ctx, (<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) mainfunc, <span class="number">2</span>, (<span class="keyword">uint32_t</span>)ptr, (<span class="keyword">uint32_t</span>)(ptr&gt;&gt;<span class="number">32</span>));</span><br><span class="line">swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>教科书式的用法，先调用<code>getcontext</code>初始化<code>ucontext_t</code>，再设置协程运行时候的栈，<strong>注意</strong>，这里的栈设置为<code>schedule</code>中的stack，也就是公共栈空间。再调用<code>makecontext</code>初始化栈结构，最后调用<code>swapcontext</code>，把控制权从主协程切出。</p><ul><li>如果协程处于<code>COROUTINE_SUSPEND</code>状态，表示其已经被调度过，意味则相关初始化工作已经做过。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> COROUTINE_SUSPEND:</span><br><span class="line"><span class="built_in">memcpy</span>(S-&gt;<span class="built_in">stack</span> + STACK_SIZE - C-&gt;size, C-&gt;<span class="built_in">stack</span>, C-&gt;size);</span><br><span class="line">S-&gt;running = id;</span><br><span class="line">C-&gt;status = COROUTINE_RUNNING;</span><br><span class="line">swapcontext(&amp;S-&gt;main, &amp;C-&gt;ctx);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>直接将其保存的栈数据从buffer设置到主stack，然后调用<code>swapcontext</code>，将控制权从主协程切出。</p><h5><span id="coroutine_yield"><code>coroutine_yield</code></span></h5><p>协程主动将控制权交出给主协程<br>由于运行时的栈空间是<code>schedule</code>的stack，也就是公共栈空间，是所有协程公用的。<br>所以需要协程自己保存数据，以待将来再次获得控制权时将数据拷贝回公共栈空间，然后运行。</p><p>如何保存协程的栈空间数据？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_save_stack(struct coroutine *C, <span class="keyword">char</span> *top) &#123;</span><br><span class="line"><span class="keyword">char</span> dummy = <span class="number">0</span>;</span><br><span class="line">assert(top - &amp;dummy &lt;= STACK_SIZE);</span><br><span class="line"><span class="keyword">if</span> (C-&gt;cap &lt; top - &amp;dummy) &#123;</span><br><span class="line"><span class="built_in">free</span>(C-&gt;<span class="built_in">stack</span>);</span><br><span class="line">C-&gt;cap = top-&amp;dummy;</span><br><span class="line">C-&gt;<span class="built_in">stack</span> = <span class="built_in">malloc</span>(C-&gt;cap);</span><br><span class="line">&#125;</span><br><span class="line">C-&gt;size = top - &amp;dummy;</span><br><span class="line"><span class="built_in">memcpy</span>(C-&gt;<span class="built_in">stack</span>, &amp;dummy, C-&gt;size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了一个假定，栈空间由高地址向低地址增长，拷贝有效数据到协程自己的buffer中保存<br><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20181215-222926.jpg" alt=""></p><p>设置协程状态，并将控制权交给主协程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">coroutine_yield(struct schedule * S) &#123;</span><br><span class="line"><span class="keyword">int</span> id = S-&gt;running;</span><br><span class="line">assert(id &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine</span> * <span class="title">C</span> = <span class="title">S</span>-&gt;<span class="title">co</span>[<span class="title">id</span>];</span></span><br><span class="line">assert((<span class="keyword">char</span> *)&amp;C &gt; S-&gt;<span class="built_in">stack</span>);</span><br><span class="line">_save_stack(C,S-&gt;<span class="built_in">stack</span> + STACK_SIZE);</span><br><span class="line">C-&gt;status = COROUTINE_SUSPEND;</span><br><span class="line">S-&gt;running = <span class="number">-1</span>;</span><br><span class="line">swapcontext(&amp;C-&gt;ctx , &amp;S-&gt;main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="总结">总结</span></h4><p>分析完云风的协程源码，大家可以参考微信开源的libco加强理解，其hook了系统函数，并包含协程调度逻辑，是一个工业级协程库，不过知乎上也有人提到libco实现有bug云云，不一而足。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析cloudwu(云风)协程库的具体实现&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>协程原理解析(2)</title>
    <link href="http://www.xiaocc.xyz/2018-12-06/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%902/"/>
    <id>http://www.xiaocc.xyz/2018-12-06/协程原理解析2/</id>
    <published>2018-12-06T14:00:00.000Z</published>
    <updated>2018-12-14T14:35:42.767Z</updated>
    
    <content type="html"><![CDATA[<p>探讨与分析实现协程依赖的四大函数</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>接上篇讲到协程的实现需要依赖四大函数：</p><ul><li><code>int getcontext(ucontext_t *ucp);</code></li><li><code>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</code></li><li><code>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</code></li><li><code>int setcontext(const ucontext_t *ucp);</code></li></ul><p>本篇具体分析这四大函数的功能与实现，代码阅读工具采用：<br><a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq在线源码阅读平台</a></p><h4><span id="实际例子">实际例子</span></h4><p>先看看使用四大函数构造协程的一个简单例子，例子中函数<code>f1</code>、<code>f2</code>交替运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main-&gt;f1-&gt;f2</span></span><br><span class="line"><span class="comment">//ut[0]-&gt;ut[1]-&gt;ut[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ucontext_t</span> ut[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"f1:%d\n"</span>, i);</span><br><span class="line">        swapcontext(&amp;ut[<span class="number">1</span>], &amp;ut[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"f2:%d\n"</span>, i);</span><br><span class="line">        swapcontext(&amp;ut[<span class="number">2</span>], &amp;ut[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> stack_buff[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> stack_buff2[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    getcontext(&amp;ut[<span class="number">1</span>]);</span><br><span class="line">    ut[<span class="number">1</span>].uc_stack.ss_sp = stack_buff;</span><br><span class="line">    ut[<span class="number">1</span>].uc_stack.ss_size = <span class="keyword">sizeof</span>(stack_buff);</span><br><span class="line">    ut[<span class="number">1</span>].uc_link = &amp;ut[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    makecontext(&amp;ut[<span class="number">1</span>], f1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    getcontext(&amp;ut[<span class="number">2</span>]);</span><br><span class="line">    ut[<span class="number">2</span>].uc_stack.ss_sp = stack_buff2;</span><br><span class="line">    ut[<span class="number">2</span>].uc_stack.ss_size = <span class="keyword">sizeof</span>(stack_buff2);</span><br><span class="line">    ut[<span class="number">2</span>].uc_link = &amp;ut[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    makecontext(&amp;ut[<span class="number">2</span>], f2, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    swapcontext(&amp;ut[<span class="number">0</span>], &amp;ut[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="引子">引子</span></h4><p>在Stack Overflow上有一个问题：<br><a href="https://stackoverflow.com/questions/19503925/what-does-the-getcontext-system-call-ucontext-h-really-do" target="_blank" rel="noopener">What does the getcontext system call (ucontext.h) really do?</a></p><p>提问者问道：</p><ul><li><code>getcontext</code>究竟干了什么</li><li>与<code>makecontext</code>有什么区别</li><li>为什么不能直接定义一个<code>ucontext_t</code>结构，然后初始化并调用<code>makecontext</code>，再使用<code>swapcontext</code>或者<code>setcontext</code>激活context</li><li>为什么不按照man page要求的在调用<code>makecontext</code>之前调用<code>getcontext</code>，激活context就会报错</li></ul><p>为了解决这些疑惑，我们深入到源码级别，看看这些函数到底做了什么。</p><h4><span id="基础结构ucontext_t">基础结构<code>ucontext_t</code></span></h4><p>先看看这个最重要的结构的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span>         uc_sigmask;</span><br><span class="line">    <span class="keyword">stack_t</span>          uc_stack;</span><br><span class="line">    <span class="keyword">mcontext_t</span>       uc_mcontext;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure><p>其中:<br><code>uc_link</code>表示该context执行完毕之后，下一个需要激活的context<br><code>uc_sigmask</code>主要是该context需要屏蔽的信号<br><code>uc_stack</code>指定context运行时候的栈空间<br><code>mcontext_t</code>的定义依赖于特定平台，主要包含寄存器等结构</p><h4><span id="int-getcontextucontext_t-ucp">int getcontext(ucontext_t *ucp)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/getcontext.S.html" target="_blank" rel="noopener">getcontext在线代码</a></p><p>主要是将当前context的相关寄存器值保存，相当于保护现场</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq        (%rsp), %rcx</span><br><span class="line">movq        %rcx, oRIP(%rdi)</span><br><span class="line">leaq        8(%rsp), %rcx         /* Exclude the return address.  */</span><br><span class="line">movq        %rcx, oRSP(%rdi)</span><br></pre></td></tr></table></figure><p>这里需要对C++中函数调用栈熟悉，函数调用时候，先对参数压栈，再压入返回地址，再执行被调函数体指令。</p><p>由于是在当前context中调用得<code>getcontext</code>函数，所以<code>(%rsp)</code>中保存的即是函数返回地址，也就是执行完<code>getcontext</code>这个函数之后需要执行的下一个指令的地址。<br><code>8(%rsp)</code>值即是当前context的栈顶排除返回地址之后的值。</p><p>由于context即是由代码+数据组成，保存了相关寄存器的值主要是<code>rip</code>值，同时把当前栈的<code>rsp</code>值也保存，这样便可以通过这些数据恢复context以再次继续执行。</p><p>这其中还有一个很重要的操作，保存了浮点寄存器相关数据。</p><h4><span id="void-makecontextucontext_t-ucp-void-func-int-argc">void makecontext(ucontext_t <em>ucp, void (</em>func)(), int argc, …)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/makecontext.c.html" target="_blank" rel="noopener">makecontext在线代码</a></p><p>该函数由C语言实现，代码前部的注释中简明介绍了该函数的工作</p><p>该函数主要是进行栈准备工作，并保存相关值到<code>uc_mcontext</code>的寄存器结构中，同时把<code>uc_link</code>值也做了保存，而需要传递给<code>func</code>函数的参数，一部分保存在寄存器中，剩下的保存在栈中。</p><p>栈布局结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           +-----------------------+</span><br><span class="line">           | next context          |</span><br><span class="line">           +-----------------------+</span><br><span class="line">           | parameter 7-n         |</span><br><span class="line">           +-----------------------+</span><br><span class="line">           | trampoline address    |</span><br><span class="line">%rsp -&gt;    +-----------------------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Setup context ucp.  */</span><br><span class="line">/* Address to jump to.  */</span><br><span class="line">ucp-&gt;uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;</span><br><span class="line">/* Setup rbx.*/</span><br><span class="line">ucp-&gt;uc_mcontext.gregs[REG_RBX] = (uintptr_t) &amp;sp[idx_uc_link];</span><br><span class="line">ucp-&gt;uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;</span><br><span class="line"></span><br><span class="line">sp[0] = (uintptr_t) &amp;__start_context;</span><br><span class="line">sp[idx_uc_link] = (uintptr_t) ucp-&gt;uc_link;</span><br></pre></td></tr></table></figure><p>这其中一个巧妙之处在于，如何实现在该context执行完毕后自动激活<code>uc_link</code>并执行？</p><p>在该函数中把返回地址巧妙的设置为<code>__start_context</code>，这样，当<code>func</code>函数执行完毕后即会转到<code>__start_context</code>执行，而在该函数中即可实现激活<code>uc_link</code>并执行。</p><h4><span id="int-swapcontextucontext_t-oucp-ucontext_t-ucp">int swapcontext(ucontext_t <em>oucp, ucontext_t </em>ucp)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/swapcontext.S.html" target="_blank" rel="noopener">swapcontext在线代码</a></p><p>当<code>makecontext</code>做好准备工作后，即由该函数进行context切换，把执行流程切到另外一个context。</p><p>该函数首先将当前context的相关寄存器值保存到<code>oucp</code>中，而第54-57行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq        (%rsp), %rcx</span><br><span class="line">movq        %rcx, oRIP(%rdi)</span><br><span class="line">leaq        8(%rsp), %rcx       /* Exclude the return address.  */</span><br><span class="line">movq        %rcx, oRSP(%rdi)</span><br></pre></td></tr></table></figure><p>当前<code>rsp</code>指向的地址中存储的即是返回地址，也就是调用<code>swapcontext</code>后当前协程需要执行的下一个指令地址。<br><code>swapcontext</code>函数没有返回值，因为在其内部会发生执行流程的跳转，控制权会转移到另外的context。<br><code>8(%rsp)</code>的值即是排除返回地址后的当前栈顶地址。<br>保存当前context的相关信息后，将来控制权再切回来时，就能正确的恢复现场。</p><p>剩下的工作即是用<code>ucp</code>中保存的信息，设置相关寄存器值，如<code>rsp</code>、<code>rbp</code>等。<br>我们知道程序的指令寄存器为<code>rip</code>，只有改变该寄存器值才能改变程序的执行流程，关键在于函数底部的第231-248行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* The following ret should return to the address set with</span><br><span class="line">        getcontext.  Therefore push the address on the stack.  */</span><br><span class="line">movq        oRIP(%rdx), %rcx</span><br><span class="line">pushq        %rcx</span><br><span class="line">/* Setup registers used for passing args.  */</span><br><span class="line">movq        oRDI(%rdx), %rdi</span><br><span class="line">movq        oRSI(%rdx), %rsi</span><br><span class="line">movq        oRCX(%rdx), %rcx</span><br><span class="line">movq        oR8(%rdx), %r8</span><br><span class="line">movq        oR9(%rdx), %r9</span><br><span class="line">/* Setup finally %rdx.  */</span><br><span class="line">movq        oRDX(%rdx), %rdx</span><br><span class="line">/* Clear rax to indicate success.  */</span><br><span class="line">xorl        %eax, %eax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>将<code>ucp</code>中保存的<strong>返回地址压栈</strong>，该返回地址即是该协程之前执行<code>swapcontext</code>的那个点，因为只有执行该函数才能将控制权转移给别的协程，现在如果把控制权再切回该协程，下一个需要执行的指令地址是多少呢？<br>即是当初调用<code>swapcontext</code>函数时候的返回地址，然后执行<code>ret</code>指令，该指令将当前栈上的值弹出并保存到<code>rip</code>，到这里控制权完成切换，从协程<code>oucp</code>切换到<code>ucp</code>。</p><h4><span id="int-setcontextconst-ucontext_t-ucp">int setcontext(const ucontext_t *ucp)</span></h4><p><a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/setcontext.S.html" target="_blank" rel="noopener">setcontext在线代码</a></p><p>该函数功能与<code>swapcontext</code>类似，将控制权转移到<code>ucp</code>中。</p><h4><span id="为什么必须调用getcontext">为什么必须调用<code>getcontext</code></span></h4><p>在<code>getcontext</code>中保存了浮点寄存器相关值，该值在<code>swapcontext</code>、<code>setcontext</code>中都有使用，否则调用时会发生异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探讨与分析实现协程依赖的四大函数&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>协程原理解析(1)</title>
    <link href="http://www.xiaocc.xyz/2018-12-05/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%901/"/>
    <id>http://www.xiaocc.xyz/2018-12-05/协程原理解析1/</id>
    <published>2018-12-05T15:00:00.000Z</published>
    <updated>2018-12-05T15:12:41.992Z</updated>
    
    <content type="html"><![CDATA[<p>探讨C/C++协程实现原理，分析协程实现依赖的四大函数</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>前两天跟同事讨论C++中的协程，我提到微信开源的协程库libco，性能高、稳定性好。<br>在看点项目后期，有些模块也引入该协程库，以解决异步调用复杂，代码逻辑难以梳理，维护性差，出bug后不易排查等问题。<br>引入协程库后，代码以顺序性书写，易于理解，而执行时则是异步调用，性能不减。</p><h4><span id="协程用法">协程用法</span></h4><p>协程库核心即是在用户线程中模拟操作系统线程并进行调度，一个协程A调用网络写请求write后，然后调用<code>yield</code>将控制权交出，协程调度器从所有协程中获取满足唤醒条件的协程（如：远端服务返回数据或sleep时间到等等），对其调用<code>resume</code>，使该协程继续执行。</p><p>例如协程版网络库封装如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendAndRecv</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; recv_data, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; send_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过socket发送数据</span></span><br><span class="line">    write(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将协程控制权交出</span></span><br><span class="line">    yield();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//远端服务器返回数据后，该协程被调度器resume，从yield后继续执行</span></span><br><span class="line">    read(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，上层逻辑代码写起来非常直接，例如某个处理需要先请求A服务获取特定数据，再请求B服务获取特定数据，两种数据整合后再返回给请求方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//请求A服务获取数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_recv_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造请求数据包</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_send_data = ....;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用协程库接口</span></span><br><span class="line">    SendAndRecv(a_recv_data, a_send_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求B服务获取数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> b_recv_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造请求数据包</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> b_send_data = ....;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用协程库接口</span></span><br><span class="line">    SendAndRecv(b_recv_data, b_send_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//整合A、B服务的数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不采用协程方式，要么：</p><ol><li>使用网络库同步版API，该代码书写方式在请求量大时候，服务性能不足，线程大量时间阻塞在等待远端服务返回数据，整体吞吐量不高。</li><li>针对每个请求，改造与管理session，并与事件框架结合，待远端服务返回数据，事件框架通知后采用回调形式。这样，原本连贯的处理逻辑，会被切分得支离破碎。<br>示例代码如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造session</span></span><br><span class="line">    Session* session = m_SessionMgr.AddSession();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//往服务A发送请求以获取数据</span></span><br><span class="line">    <span class="comment">//将session_id发送至服务A，同时服务A将该session_id原样返回</span></span><br><span class="line">    <span class="comment">//构造请求数据包</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> a_send_data = ....;</span><br><span class="line">    SendData(a_send_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数由事件框架调用，当远端服务器有数据返回时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRecvRemoteData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; recv_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从recv_data中解析出session_id</span></span><br><span class="line">    <span class="keyword">uint32_t</span> session_id = GetSessionID(recv_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从session管理器获取session</span></span><br><span class="line">    Session* ps = m_SessionMgr.GetSession(session_id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//session中有step标记，以区分是服务A返回还是服务B返回</span></span><br><span class="line">    <span class="keyword">if</span> (ps-&gt;step == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Session结构中缓存A服务返回的数据</span></span><br><span class="line">        ps-&gt;recv_a_data = recv_data;</span><br><span class="line">        </span><br><span class="line">        ps-&gt;step = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//请求B服务获取数据</span></span><br><span class="line">        <span class="comment">//同样需要将session_id带至远端</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> b_send_data = ....;</span><br><span class="line">        SendData(b_send_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//服务B的数据已经返回</span></span><br><span class="line">        <span class="comment">//可以进行总处理</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data_a = ps-&gt;recv_a_data;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data_b = recv_data;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//核心数据处理流程</span></span><br><span class="line">        ....</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放session</span></span><br><span class="line">        m_SessionMgr.DelSession(session_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上方案对比可以发现，采用协程后代码逻辑清晰易懂，同时代码量也更少，出问题后更利于排查。</p><h4><span id="协程原理">协程原理</span></h4><p>协程按类型分为：</p><ul><li><code>非对称式协程</code>，协程之间有调用链关系，一个协程A释放控制权有2种方式<ul><li>通过调用<code>yield</code>，将控制权返还给协程A的创建协程</li><li>通过调用<code>resume</code>，将控制权交给一个子协程</li></ul></li><li><code>对称式协程</code>，与<code>非对称式协程</code>不同，各个协程之间可以互相转移控制权，类似于goto语句，这种方式，即使非常有经验的程序员也很难理清调用流程。同时该协程方式实现困难，性能不高。</li></ul><p>业内实现的C/C++协程基本都采用<code>非对称</code>的协程方式。</p><p>协程实现主要依赖以下四个系统级函数：</p><ul><li><code>int getcontext(ucontext_t *ucp);</code></li><li><code>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</code></li><li><code>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</code></li><li><code>int setcontext(const ucontext_t *ucp);</code></li></ul><p>相关函数定义均在<code>ucontext.h</code>，通过查询man page可以大略知道各个函数的作用<br>可参考文档：<a href="https://linux.die.net/man/3/makecontext" target="_blank" rel="noopener">文档</a></p><ul><li>getcontext——可以认为是用当前执行环境初始化<code>ucontext_t</code>结构</li><li>makecontext——更改ucp结构，该结构必须先通过调用getcontext进行初始化，同时进行stack相关赋值，待该ucp通过swapcontext或setcontext激活时，其会从func函数开始执行</li><li>swapcontext——把当前执行环境保存到oucp，并激活ucp进行执行</li><li>setcontext——激活ucp并进行执行</li></ul><p>接下来会详细分析这几个函数的实现，并参考云风的协程库进行分析。</p><p>参考文档：</p><ol><li><a href="https://www.zhihu.com/question/52193579" target="_blank" rel="noopener">腾讯开源的 libco 号称千万级协程支持，那个共享栈模式原理是什么?</a></li><li><a href="https://github.com/cloudwu/coroutine" target="_blank" rel="noopener">云风的协程库</a></li><li><a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">我所理解的ucontext族函数</a></li><li><a href="https://code.woboq.org/" target="_blank" rel="noopener">woboq源码阅读网站</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;探讨C/C++协程实现原理，分析协程实现依赖的四大函数&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++17学习笔记(3)——容器、指针、线程</title>
    <link href="http://www.xiaocc.xyz/2018-09-30/C++17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://www.xiaocc.xyz/2018-09-30/C++17学习笔记3/</id>
    <published>2018-09-30T12:30:00.000Z</published>
    <updated>2018-09-30T14:22:01.823Z</updated>
    
    <content type="html"><![CDATA[<p>C++17学习笔记系列</p><a id="more"></a><ol><li><p>容器</p><ul><li><p>std::array<br>与 std::vector 区别：栈内存、固定大小</p></li><li><p>std::forward_list<br>单链表、不提供size()函数</p></li><li><p>无序容器</p><ul><li>unordered_map</li><li>unordered_multimap</li><li>unordered_set</li><li>unordered_multiset</li></ul></li><li><p>元组 std::tuple</p><ul><li>std::make_tuple 构造元组</li><li>std::get&lt;N&gt;() 获得元组中某个位置的值<br> 其中N为编译期固定值，包括数字常量值、constexpr值<br> 如何在运行期获取tuple中的值，接下来会介绍</li><li><p>std::tie 从tuple中获取解值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packing/unpacking tuples</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;        // std::tuple, std::make_tuple, std::tie</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myint;</span><br><span class="line">  <span class="keyword">char</span> mychar;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>,<span class="keyword">float</span>,<span class="keyword">char</span>&gt; mytuple;</span><br><span class="line"></span><br><span class="line">  mytuple = <span class="built_in">std</span>::make_tuple (<span class="number">10</span>, <span class="number">2.6</span>, <span class="string">'a'</span>);          <span class="comment">// packing values into tuple</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::tie (myint, <span class="built_in">std</span>::ignore, mychar) = mytuple;   <span class="comment">// unpacking tuple into variables</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myint contains: "</span> &lt;&lt; myint &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mychar contains: "</span> &lt;&lt; mychar &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在运行期索引tuple值<br>利用 <code>boost::variant</code> 配合变长模板参数的黑魔法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/variant.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> n, <span class="keyword">typename</span>... T&gt;</span><br><span class="line">boost::variant&lt;T...&gt; _tuple_index(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;T...&gt;&amp; tpl) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;n&gt;(tpl);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="keyword">sizeof</span>...(T) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"越界."</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> _tuple_index&lt;(n &lt; <span class="keyword">sizeof</span>...(T)<span class="number">-1</span> ? n+<span class="number">1</span> : <span class="number">0</span>)&gt;(i, tpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line">boost::variant&lt;T...&gt; tuple_index(<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::tuple&lt;T...&gt;&amp; tpl) &#123;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;<span class="number">0</span>&gt;(i, tpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><code>std::tuple</code> tpl 在其定义时，其能保存的元素个数已经确定，并且在编译期可以获取，也就是 <code>sizeof...(T)</code> 。</li><li><code>std::get&lt;N&gt;()</code> 中 <code>N</code> 只能是常量值，既然要运行期获取tpl中某index值，那么该index可取值区间为 <code>[0, Len - 1]</code> ，那么可以采取一种笨方法，通过获取 <code>get&lt;0&gt;,get&lt;1&gt; ... get&lt;Len - 1&gt;</code> 逐个与index比较，最终即可获取到下标为index的值。</li><li><code>tuple_index</code> 函数，从 <code>0</code> 开始尝试，并在编译期实例化大量的 <code>_tuple_index</code> 函数，即 <code>_tuple_index&lt;0&gt;</code>，<code>_tuple_index&lt;1&gt;</code>，… <code>_tuple_index&lt;Len - 1&gt;</code>，而其中每个函数即可调用 <code>std::get&lt;0&gt;</code>，<code>std::get&lt;1&gt;</code>，… <code>std::get&lt;Len - 1&gt;</code>。</li><li>详细过程：<br>在 <code>_tuple_index&lt;0&gt;</code> 中判断 <code>i</code>，<code>n</code> 值，如果不符，继续往上递归增长式调用 <code>_tuple_index&lt;1&gt;</code>，再次判断 <code>i</code>，<code>n</code>值，如果不符，则调用 <code>_tuple_index&lt;2&gt;</code>，如此往复，直到某个 <code>n</code> 值与 <code>i</code> 相等，则此时调用 <code>std::get&lt;n&gt;(tpl)</code> 获取tpl中值。</li></ol><p><strong>使用方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">tuple_len</span><span class="params">(T &amp;tpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tuple_size&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != tuple_len(new_tuple); ++i) &#123;</span><br><span class="line">    <span class="comment">// 运行期索引</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuple_index(i, new_tuple) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>指针</p><ul><li><p>std::shared_ptr<br>std::make_shared</p></li><li><p>std::unique_ptr<br>一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全<br>可以利用 <code>std::move</code> 转移给其它的 unique_ptr<br>std::make_unique</p></li><li><p>std::weak_ptr<br>解决 <code>std::shared_ptr</code> 之间循环引用，析构时无法释放问题</p></li></ul></li><li><p>线程与并发</p><ul><li><p>std::thread</p></li><li><p>std::mutex</p><ul><li>std::lock_guard<br> RAII，构造函数lock，析构函数unlock</li><li>std::unique_lock<br> 默认行为与std::lock_guard一致，但是提供lock、unlock函数手动操作mutex</li></ul></li><li><p>std::packaged_task、std::future、std::promise<br>关于 <code>std::future</code>，<code>std::promise</code> 会再写一篇详细介绍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>()&gt; task([]()&#123;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f = task.get_future();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread(<span class="built_in">std</span>::move(task)).detach();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait result ..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    f.wait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> r = f.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"get result:"</span> &lt;&lt; r &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>std::conditiaon_variable 信号量</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++17学习笔记系列&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++17学习笔记(2)——语言运行期强化</title>
    <link href="http://www.xiaocc.xyz/2018-09-19/C++17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://www.xiaocc.xyz/2018-09-19/C++17学习笔记2/</id>
    <published>2018-09-19T00:30:00.000Z</published>
    <updated>2018-09-19T05:01:19.705Z</updated>
    
    <content type="html"><![CDATA[<p>C++17学习笔记系列</p><a id="more"></a><ol><li><p>Lambda表达式</p><ul><li><p>Lambda 表达式的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>捕获列表</p><ul><li><p>值捕获</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">learn_lambda_func_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value_1 = [value_1] &#123;</span><br><span class="line">        <span class="keyword">return</span> value_1;</span><br><span class="line">    &#125;;</span><br><span class="line">    value_1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value_1 = copy_value_1();</span><br><span class="line">    <span class="comment">// 这时, stored_value_1 == 1, 而 value_1 == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value_1 在创建时就保存了一份 value_1 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用捕获</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">learn_lambda_func_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value_2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value_2 = [&amp;value_2] &#123;</span><br><span class="line">        <span class="keyword">return</span> value_2;</span><br><span class="line">    &#125;;</span><br><span class="line">    value_2 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value_2 = copy_value_2();</span><br><span class="line">    <span class="comment">// 这时, stored_value_2 == 100, value_1 == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value_2 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>隐式捕获</li></ul><blockquote><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code> 向编译器声明采用 <code>引用捕获</code>或者 <code>值捕获</code>。</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] 空捕获列表</span><br><span class="line">[name1, name2, ...] 捕获一系列变量</span><br><span class="line">[&amp;] 引用捕获, 让编译器自行推导捕获列表</span><br><span class="line">[=] 值捕获, 让编译器执行推导应用列表</span><br></pre></td></tr></table></figure></li></ul></li><li><p>泛型Lambda</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数对象包装器</p><ul><li>std::function</li><li><p>std::bind/std::placeholder</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + (<span class="number">2</span> * b) + (<span class="number">3</span> * c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + important + <span class="number">5</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func2(<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindfoo = <span class="built_in">std</span>::bind(foo2, <span class="number">5</span>, _1, _2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bindfoo(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>右值引用</p><ul><li>左值</li><li>右值<ul><li>纯右值</li><li>将亡值</li></ul></li><li>左值引用</li><li>右值引用<blockquote><p>需要拿到一个将亡值，就需要用到右值引用的申明：T &amp;&amp;，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p></blockquote></li></ul><ul><li>移动语义<ul><li>移动构造函数</li><li>移动赋值函数</li></ul></li><li><p>完美转发<br>  一个声明的右值引用其实是一个左值</p>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">rv2 += <span class="string">"Test"</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,string,Test</span></span><br><span class="line"></span><br><span class="line">reference(rv2); <span class="comment">// 输出左值</span></span><br></pre></td></tr></table></figure><p>   rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值</p></li></ul></li></ol><p><strong>引用坍缩规则：</strong></p><blockquote><p>在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引用，又能右引用。</p></blockquote><table><thead><tr><th style="text-align:center">函数形参类型</th><th style="text-align:center">实参参数类型</th><th style="text-align:center">推导后函数形参类型</th></tr></thead><tbody><tr><td style="text-align:center">T&amp;</td><td style="text-align:center">左引用</td><td style="text-align:center">T&amp;</td></tr><tr><td style="text-align:center">T&amp;</td><td style="text-align:center">右引用</td><td style="text-align:center">T&amp;</td></tr><tr><td style="text-align:center">T&amp;&amp;</td><td style="text-align:center">左引用</td><td style="text-align:center">T&amp;</td></tr><tr><td style="text-align:center">T&amp;&amp;</td><td style="text-align:center">右引用</td><td style="text-align:center">T&amp;&amp;</td></tr></tbody></table><blockquote><p>因此，模板函数中使用 T&amp;&amp; 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。更准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。这才使得 v 作为左值的成功传递。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"左值引用"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"右值引用"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"普通传参:"</span>;</span><br><span class="line">    reference(v);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::move 传参:"</span>;</span><br><span class="line">    reference(<span class="built_in">std</span>::move(v));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"std::forward 传参:"</span>;</span><br><span class="line">    reference(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传递右值:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    pass(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传递左值:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    pass(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传递右值:</span><br><span class="line">普通传参:左值引用</span><br><span class="line">std::move 传参:右值引用</span><br><span class="line">std::forward 传参:右值引用</span><br><span class="line">传递左值:</span><br><span class="line">普通传参:左值引用</span><br><span class="line">std::move 传参:右值引用</span><br><span class="line">std::forward 传参:左值引用</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++17学习笔记系列&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++17学习笔记(1)——语言可用性强化</title>
    <link href="http://www.xiaocc.xyz/2018-09-18/c++17%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://www.xiaocc.xyz/2018-09-18/c++17学习笔记1/</id>
    <published>2018-09-18T03:50:00.000Z</published>
    <updated>2018-09-20T14:27:28.270Z</updated>
    
    <content type="html"><![CDATA[<p>C++17学习笔记系列1</p><a id="more"></a><ol><li>nullptr</li><li>constexpr</li><li>if/switch 中定义临时变量</li><li><p>初始化列表 <code>initializer_list</code></p><ul><li><p>类构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MagicFoo(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">            it != <span class="built_in">list</span>.end();</span><br><span class="line">            ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        vec_.push_back(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;::const_iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">            it != <span class="built_in">list</span>.end();</span><br><span class="line">            ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>统一的初始化语法<br><code>MagicFoo magicFoo = {1, 2, 3, 4, 5};</code> </p></li></ul></li><li><p>结构化绑定 tuple</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; f() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">"456"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = f();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">", "</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>类型推导</p><ul><li><p>auto 针对变量进行类型推导<br>   auto 不能用于函数传参<br>   auto 不能用于推导数组类型<br>   <code>auto i = 5;  // i 被推导为 int</code></p></li><li><p>decltype 针对表达式进行类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure></li><li><p>尾返回类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x+y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>decltype(auto) 函数转发的返回类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>  <span class="title">lookup1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">lookup2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) look_up_a_string_1() &#123;</span><br><span class="line">    <span class="keyword">return</span> lookup1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) look_up_a_string_2() &#123;</span><br><span class="line">    <span class="keyword">return</span> lookup2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>区间 for 迭代</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>); itr != vec.end())</span><br><span class="line">        *itr = <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;                      <span class="comment">// writeable</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>模板</p><ul><li><p>变长参数模板<br><code>template&lt;typename... Ts&gt; class Magic;</code></p><blockquote><p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<br>  <code>class Magic&lt;&gt; nothing;</code></p><p>如果不希望产生的模板参数个数为 <code>0</code> ，可以手动的定义至少一个模板参数：<br>  <code>template&lt;typename Require, typename... Args&gt; class Magic;</code></p></blockquote></li><li><p>应用到模板函数上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str, Args... args)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>如何对参数解包：</p><ul><li><p>参数个数 <code>sizeof…</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对参数解包</p><ul><li><p>递归模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T value, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"123"</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>c++17中简略写法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t0 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    if constexpr (sizeof...(t) &gt; 0) printf(t...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化列表展开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译这个代码需要开启 -std=c++14</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print</span><span class="params">(T value, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;] &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;(), value)...&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print(<span class="number">1</span>, <span class="number">2.1</span>, <span class="string">"123"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>折叠表达式</strong></p><blockquote><p><a href="https://zh.cppreference.com/w/cpp/language/fold" target="_blank" rel="noopener">折叠表达式 cppreference</a><br><a href="https://blog.csdn.net/zwvista/article/details/53981696" target="_blank" rel="noopener">C++17尝鲜：fold expression</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>面向对象</p><ul><li>委托构造</li><li>继承构造</li><li>显式虚函数重载 <code>override、final</code></li><li><p>显式禁用默认函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Magic() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">        Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">        Magic(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++17学习笔记系列1&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://www.xiaocc.xyz/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>穷，是一种病</title>
    <link href="http://www.xiaocc.xyz/2018-09-12/%E7%A9%B7%E6%98%AF%E4%B8%80%E7%A7%8D%E7%97%85/"/>
    <id>http://www.xiaocc.xyz/2018-09-12/穷是一种病/</id>
    <published>2018-09-12T15:00:00.000Z</published>
    <updated>2018-09-18T03:45:44.421Z</updated>
    
    <content type="html"><![CDATA[<p>观看《我不是药神》后，一直想就这个话题写点东西，三十年的邻居突患病离世，更添些许压抑。</p><a id="more"></a><h4><span id="背景">背景</span></h4><p>前段时间跟老婆一起看了口碑爆棚的神作《我不是药神》，影片很好的反应当代现实与社会问题。<br>特别是里面有句台词，<code>世上有一种病叫穷病——没得治</code>。</p><p>在这里不想讨论大道理，如：医药公司是否过于暴利、政府的缺位等等，只想说一下亲身体会。</p><h4><span id="亲人患病">亲人患病</span></h4><h5><span id="初诊">初诊</span></h5><p>大约7月份的时候，堂弟突然微信联系我，发来一些检查报告，是他岳母的。<br>检查报告先出来，周一才能找医生会诊，心里比较着急，让我找同学帮忙问问报告内容具体什么意思。</p><p>赶紧与同学联系，她是麻醉师，医院各科室都认识人。<br>她找人看了一下检查报告，对方提出需要查看图片影像，以增加信息辅助判断，但是根据检查报告初步怀疑肺癌。</p><p>收到信息后，马上给堂弟打电话，他对此已有所预感，待周一拿上相关资料与医生当面会诊。</p><p><strong>为什么会这样？</strong></p><p>犹如晴天霹雳，今年初的时候还到他们家做客，岳母才47岁，非常年轻，刚当上外婆，宝宝才1岁，为什么这个不幸的病会找上她。<br>且宝宝刚出生时，由于感染，在中心医院住院治疗一个多月，没有明显恢复，后又转院到同济医院，前后花了十多万，举债累累。<br>万幸的是治疗后，宝宝没有后遗症、恢复很好，让人欣慰。</p><p>去年宝宝患病，今年岳母患病，让这个本就不富裕的家庭，更捉襟见肘。</p><p>这可如何是好？虽还没确诊，但我已有如此担忧。</p><h5><span id="确诊">确诊</span></h5><p>周一下午，打电话给堂弟询问具体诊断结果，医生初步怀疑肺癌，需要做病理检查，进一步确认。</p><p>按照医生的要求，一项项检查，焦急的等等……</p><p>周五堂弟打电话过来，确诊：<strong>肺腺癌晚期</strong>。<br>医生反馈由于是晚期，且带有一些扩散，无法进行手术治疗，可以尝试进行<strong>靶向治疗</strong>，但是需要先进行基因检测。</p><p>赶紧打电话给同学，将最新信息同步于她，并寻求建议、打听基因检测价格、靶向药物价格等等。</p><h5><span id="靶向治疗">靶向治疗</span></h5><p>预约基因检测，待拿到检测结果后，再预约医生制定具体治疗方案。<br>基因检测结果显示，可以使用靶向药物，药名：<strong>吉非替尼</strong>，俗名：<strong>易瑞沙</strong>。</p><p>这个药已经国产，一盒大约2000多块钱，疗程10天，一个月大约6000多块钱。</p><p>虽然国产后已便宜许多，但是一个月6000多的药物费用，依然让这个家庭特别吃力。</p><p>这时想起《我不是药神》的情节，这个药有没有印度版？价格怎么样？</p><p>立马在各种同学群找他们帮忙，打听药物渠道、价格如何、疗效怎样。</p><p>由于《药神》上映后，海关检查特别严格，药物不好带，他们多方打听也没有合适渠道。</p><p>不放弃，最后找到一个渠道，印度直接邮寄过来，先来一盒看看疗效，以验证药物是否靠谱，最后药价大约是正版药的<strong>1/5</strong>。</p><p>堂弟将岳母接回老家吃药静养，带带宝宝，放松心情，每半个月复查一次。</p><p>这一切才刚刚开始。</p><h4><span id="隔壁邻居患病离世">隔壁邻居患病离世</span></h4><p>周六定时给家里打电话，老爸突然说道，隔壁华爷爷去世。</p><p>怎么可能？</p><p>年初回家过年，还跟他打招呼着呢。<br>他喜欢喝酒，喝完后拿着泡着茶的保温杯，嘴里叼一根烟，一踱一踱的走着，笑呵呵的对我说，“回来过年啦”，“是啊，过年必须要回来呀，城市过年没气氛，有钱没钱，回家过年”。</p><p>他腿是去年摔断的，这事儿也是听老爸说的。</p><p>当时吃了酒席喝了酒，主人家要送他回家。他偏不，倔得很，非要自己骑摩托车回来，不幸摔跤，休养了约半年才好。</p><p>老爸说，华爷爷是今年3-4月份村里大检查时排查出来的，<strong>肺癌晚期</strong>。<br>他又不配合治疗，不打针、不吃药，按他的说法，“还不如拿治病的钱喝酒呢，反正治不好，多花些冤枉钱”。</p><p>也可能是，不想为子女添加负担吧。农村年收入才2-3万元，按最便宜的治疗方案，初期怎么也得花费大几万，后面每个月还有固定开销，对农村家庭真是难以承受。</p><p><strong>穷，真是一种病</strong></p><p>9月6号当晚，可能是疼痛难忍，自己喝药走了。</p><p>这就是华爷爷，看着我长大的华爷爷，就这样走了。</p><p>俗话说，远亲不如近邻，特别是在农村，这种感受尤为强烈。</p><p>深深的无力感，就我认识的人，患癌症的就有7-8个人。</p><p>三姨妈淋巴癌晚期带转移，已经化疗几个疗程，人都瘦得不行，靶向药：<strong>美罗华</strong>，50ml药价25000。<br>姑爹，胃癌，4月份刚去世。<br>舅舅，肺癌，16年去世。<br>堂弟岳母、隔壁华爷爷、隔壁健爹刚45岁胃癌已去世……</p><p><strong>这个世道怎么了？</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观看《我不是药神》后，一直想就这个话题写点东西，三十年的邻居突患病离世，更添些许压抑。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.xiaocc.xyz/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>linux hook机制研究</title>
    <link href="http://www.xiaocc.xyz/2018-09-08/linux%E4%B8%8Bhook%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/"/>
    <id>http://www.xiaocc.xyz/2018-09-08/linux下hook机制研究/</id>
    <published>2018-09-08T15:00:00.000Z</published>
    <updated>2018-12-15T11:15:43.397Z</updated>
    
    <content type="html"><![CDATA[<p>在研究C++中协程机制时，发现有些实现通过hack掉glibc的read、write等IO操作函数，以达到迁移协程框架时，最小化代码改动，遂小小研究一下linux下的hook机制。</p><a id="more"></a><h4><span id="引子">引子</span></h4><p>在linux下调用C库中的函数，主要是调用得 <code>libc.so.6</code> 这个动态链接库中的函数。<br>那么我们有没有办法让应用程序改调其它函数，而应用程序无感知，也就是hack掉应用程序中调用的某些函数。</p><p><img src="https://blog-1256756464.cos.ap-shanghai.myqcloud.com/image/Jietu20180908-232110.jpg" alt=""></p><p>由于是调用得动态链接库中函数，我们可以通过劫持该函数的方式引入额外处理。<br>例如通过劫持 <code>malloc</code>、<code>free</code> 来追踪内存使用情况等等。</p><h4><span id="实际操作">实际操作</span></h4><h5><span id="so文件">so文件</span></h5><p>我们先创建一个 <code>my_hook.c</code> 文件，并编写需要hook的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRY_LOAD_HOOK_FUNC(name) <span class="meta-keyword">if</span> (unlikely(!g_sys_##name)) &#123;g_sys_##name = (sys_##name##_t)dlsym(RTLD_NEXT,#name);&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (*<span class="keyword">sys_malloc_t</span>)(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sys_malloc_t</span> g_sys_malloc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TRY_LOAD_HOOK_FUNC(<span class="built_in">malloc</span>);</span><br><span class="line">    <span class="keyword">void</span> *p = g_sys_malloc(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in malloc hook function ...\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sys_free_t</span>)</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">sys_free_t</span> g_sys_free = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TRY_LOAD_HOOK_FUNC(<span class="built_in">free</span>);</span><br><span class="line">    g_sys_free(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in free hook function ...\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用 <code>RTLD_NEXT</code> 来获取系统glibc的 <code>malloc</code> 函数地址，由于待会使用 <code>LD_PRELOAD</code> 来优先加载我们创建的 <code>so</code> 文件，因而系统的 <code>libc.so.6</code> 排在第二位，也就是 <code>next</code> 。</p><p>编译该文件生成一个 <code>so</code> 库：<br><code>gcc -fPIC -shared -o libmyhook.so my_hook.c -ldl</code></p><h5><span id="测试程序">测试程序</span></h5><p>接下来创建测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter main...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocation error...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"returning to main...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"aa"</span>, <span class="string">"bb"</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hook strcmp\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not match\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="hack测试">hack测试</span></h4><p>对上面的测试程序，直接编译并运行<br><code>gcc -o main main.c</code><br><code>./main</code></p><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enter main...</span><br><span class="line">returning to main...</span><br><span class="line">not match</span><br></pre></td></tr></table></figure><p>可以清楚的看到，我们创建的 <code>so</code> 中函数并没有被调用到，也就是说<strong>hack失败</strong>！</p><p>等等！目前为止我们生成的 <code>so</code> 文件，并没有与测试程序产生关联，所以 <code>malloc</code>、<code>free</code> 函数没有被hack掉，理所应当。</p><p><strong>那么，如何才能让两者产生关联呢？</strong></p><p><strong>LD_PRELOAD</strong>这个环境变量，能够影响程序运行时候动态链接库的加载，可以通过设置其来优先加载某些库，进而覆盖掉某些函数。</p><p>这里只需要<strong>稍加更改运行方式</strong>：<br><code>LD_PRELOAD=./libmyhook.so ./main</code></p><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enter main...</span><br><span class="line">in malloc hook function ...</span><br><span class="line">returning to main...</span><br><span class="line">in free hook function ...</span><br><span class="line">not match</span><br></pre></td></tr></table></figure><p>大功告成，我们自定义的 <code>malloc</code>、<code>free</code> 被调用到，<strong>hack成功</strong>！</p><h4><span id="问题">问题</span></h4><p>在尝试对<code>strcmp</code> 函数进行hack时，按照如上方式并不能hack成功，通过查阅资料，原来编译器对很多函数进行了内联优化，并不会调用到 <code>so</code> 库中的函数，因而通过优先加载自定义动态库的方式不可行。<br>不过，可以在编译测试程序时，添加 <code>-fno-builtin-strcmp</code>，关闭 <code>strcmp</code> 函数的优化<br><code>gcc -o main main.c -fno-builtin-strcmp</code></p><p>以相同的方式运行测试程序：<br><code>LD_PRELOAD=./libmyhook.so ./main</code></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enter main...</span><br><span class="line">in malloc hook function ...</span><br><span class="line">returning to main...</span><br><span class="line">in free hook function ...</span><br><span class="line">in strcmp hook function ...</span><br><span class="line">hook strcmp</span><br></pre></td></tr></table></figure><h4><span id="参考资料">参考资料</span></h4><ul><li><a href="https://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="noopener">警惕UNIX下的LD_PRELOAD环境变量</a></li><li><a href="https://stackoverflow.com/questions/44606523/hook-strcmp-using-ld-preload-in-linux" target="_blank" rel="noopener">如何hack strcmp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在研究C++中协程机制时，发现有些实现通过hack掉glibc的read、write等IO操作函数，以达到迁移协程框架时，最小化代码改动，遂小小研究一下linux下的hook机制。&lt;/p&gt;
    
    </summary>
    
      <category term="编程实践" scheme="http://www.xiaocc.xyz/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
</feed>
