<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曾经浮华的小窝</title>
  
  <subtitle>hello,world!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaocc.xyz/"/>
  <updated>2018-05-08T05:33:45.252Z</updated>
  <id>http://www.xiaocc.xyz/</id>
  
  <author>
    <name>曾经浮华</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++发送邮件</title>
    <link href="http://www.xiaocc.xyz/2018-05-07/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B61/"/>
    <id>http://www.xiaocc.xyz/2018-05-07/发送邮件1/</id>
    <published>2018-05-07T14:15:00.000Z</published>
    <updated>2018-05-08T05:33:45.252Z</updated>
    
    <content type="html"><![CDATA[<p>工作中需要发送邮件，本来用python几行代码就可以搞定的事情，可是为了与整个项目框架匹配，以利于监控和维护，只能采用C++形式了</p><a id="more"></a><p>C++发送邮件采用 <code>SMTP</code> 协议，具体原理可以参见 <a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">wiki解释</a></p><h4><span id="操作流程">操作流程</span></h4><p>假设发送者邮箱为：<a href="mailto:ww@sina.com" target="_blank" rel="noopener">ww@sina.com</a>，注意：需要在设置中启用smtp选项<br>接收者邮箱为：<a href="mailto:yy@qq.com" target="_blank" rel="noopener">yy@qq.com</a></p><div id="sequence-0"></div><p>其中发送内容content为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From: ww@sina.com</span><br><span class="line">TO: yy@qq.com</span><br><span class="line">Subject: test</span><br><span class="line"></span><br><span class="line">hello，this is a test</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p><strong>其中邮件正文以：\r\n.\r\n 结束</strong></p><h4><span id="代码实现">代码实现</span></h4><p>根据这个流程就可以编写C++代码，没什么难度，注意：每次往server端发送命令，以 <code>\r\n</code> 结尾</p><h4><span id="思考">思考</span></h4><p>这个方案有一个安全问题，整个交互都是以明文形式，如果存在中间人劫持，很容易获取邮件正文，风险很大<br><strong>那么，如何解决这个安全问题呢？</strong><br>http的不安全问题导致了https的产生，那么有没有安全的smtp协议呢？</p><p><em>请听下回分解</em></p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">client->server: telnet smtp.sina.com 25server-->client: xxxclient->server: EHLO smtp.sina.comserver-->client: xxxclient->server: AUTH LOGINserver-->client: xxxclient->server: base64(邮箱账号名)server-->client: xxxclient->server: base64(邮箱密码)server-->client: xxxclient->server: MAIL FROM: &lt;ww@sina.com&gt;server-->client: xxxclient->server: RCPT TO: &lt;yy@sina.com&gt;server-->client: xxxclient->server: DATA:server-->client: xxxclient->server: 发送内容contentserver-->client: xxx</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中需要发送邮件，本来用python几行代码就可以搞定的事情，可是为了与整个项目框架匹配，以利于监控和维护，只能采用C++形式了&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac OS环境下利用Hexo搭建个人博客</title>
    <link href="http://www.xiaocc.xyz/2018-05-06/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.xiaocc.xyz/2018-05-06/博客搭建/</id>
    <published>2018-05-06T14:30:00.000Z</published>
    <updated>2018-05-06T14:49:26.982Z</updated>
    
    <content type="html"><![CDATA[<p>在网上查找资料时候碰到很多有意思的技术博客，也一直想拥有个人主页，可是拖延症晚期患者，<br>总是由于各种原因，迟迟未能动手搭建。<br>昨天周六在公司加班，没什么特别紧急的事情，决定把这个坑填上。经过多方面查找资料与实践，有了如今这个小窝，感谢各位知识的分享者。</p><a id="more"></a><p><strong>注意：本人搭建环境为Mac OS</strong></p><p><em>暂未找到合适的图床，只能先用纯文字表述了。。</em></p><h4><span id="大体步骤">大体步骤</span></h4><ul><li>在github创建个人主页仓库</li><li>安装git</li><li>安装nodejs</li><li>安装hexo</li><li>网站预览与推送</li><li>域名申请与绑定</li><li>更换主题等个性化配置</li></ul><h4><span id="详细步骤">详细步骤</span></h4><h4><span id="github相关">github相关</span></h4><p>首先注册github账号，然后创建github pages，创建方法可以自行搜索或者阅读 <a href="https://pages.github.com/" target="_blank" rel="noopener">github官方指引</a> 点击new repository创建一个新仓库，其中仓库名字比较特殊为：<code>xxx.github.io</code> ，其中xxx为自己的github账号名，例如我的仓库名就是：<code>xiaocc2012.github.io</code> 。</p><h4><span id="安装git">安装git</span></h4><h5><span id="安装">安装</span></h5><p>我在mac环境下安装软件，一般是通过homebrew进行，它的安装和使用可以自行搜索一下。<br>执行 <code>brew install git</code> 进行git安装，这时如果遇到错误，一般是因为mac环境的git依赖CommandLineTools需要对其进行安装。</p><h5><span id="配置">配置</span></h5><p>git安装完毕后需要对其进行相关配置<br>设置user.name和user.mail信息<br><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p><h5><span id="ssh-秘钥">ssh 秘钥</span></h5><p>执行 <code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code><br>直接3个回车即可，默认不需要设置密码<br>在 <code>~/.ssh/</code> 目录下会生成 id_rsa、id_rsa.pub 文件，其中 id_rsa.pub 为公钥文件<br>执行 <code>cat id_rsa.pub</code> 打印公钥文件内容，打开 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">github ssh keys设置</a>，创建一个新的ssh key，其中Title随便填写，Key内容即为公钥文件内容。<br>执行 <code>ssh git@github.com</code> 检测公钥是否设置成功</p><p><strong>为什么需要设置ssh 秘钥？</strong></p><p>github每次推送时候都会检查用户是否合法，就需要输入用户名和密码来进行检测，为了省去每次输入密码的步骤，采用ssh非对称加密形式，将公钥保存在github网站，私钥保存在电脑上，每次推送的时候，github会检查私钥是否能与公钥匹配，从而判断用户是否合法。</p><h4><span id="安装nodejs">安装nodejs</span></h4><p>同样采用homebrew进行安装<br><code>brew install node</code><br>执行 <code>node -v</code> 查看nodejs是否安装成功<br>执行 <code>npm -v</code> 查看npm是否安装成功</p><h4><span id="安装hexo">安装hexo</span></h4><p>参考 <a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">hexo官方文档</a>进行安装</p><p>执行 <code>npm install -g hexo-cli</code> 安装hexo<br>执行 <code>hexo init blog</code> 创建blog目录，并进行相关初始化工作<br><code>cd blog</code><br><code>npm install</code><br>创建一个页面来检查网站<br><code>hexo new test_page</code><br><code>hexo g</code><br>启动网站 <code>hexo s</code></p><p><strong>注意：hexo 3需要单独安装 hexo server</strong></p><p>执行 <code>npm install hexo-server --save</code> 进行安装<br>安装完server端后，再次执行 <code>hexo s</code> 启动网站</p><h4><span id="网站预览与推送">网站预览与推送</span></h4><p>待hexo server端启动后，用浏览器打开：localhost:4000，即可查看网站</p><p><strong>hexo与github pages联系</strong></p><p>打开blog根目录下的 <code>_config.yml</code> 文件，该文件存储了站点相关配置<br>找到底部 <code>deploy:</code> 相关，填入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xiaocc2012/xiaocc2012.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>其中repo内容填写自己在github上新建仓库的完整url路径，记得url最后要添加 <strong>.git</strong><br>保存配置文件，这里做的配置其实就是给 <code>hexo d</code> 命令使用，告诉hexo要把blog部署在哪里<br>安装git部署插件 <code>npm install hexo-deployer-git --save</code><br>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>对网站进行clean，重新生成，并启动服务<br>再次在浏览器打开：localhost:4000 进行网站预览</p><p><strong>将网站推送至github</strong><br>网站预览无误后，执行 <code>hexo d</code> 将网站内容推送至github，这时在github查看仓库内容，会发现多了一些文件。<br>在浏览器输入：xiaocc2012.github.io（即为最开始创建的仓库名称），就可以看到刚才一样的博客网站了，也即咱们的博客可以在互联网上进行访问。</p><p><em>我遇到的问题：</em><br>在浏览器通过输入github地址方式访问，一直提示404错误，后来尝试各种折腾，在 <code>Settings</code> 页面的子选项 <code>GitHub Pages</code> 中选择了一个主题theme，然后网页就能正常展示了。</p><h4><span id="域名申请与绑定">域名申请与绑定</span></h4><p>申请一个自己喜欢的域名<br>在解析中新建两条配置：</p><ol><li>新建一条解析，记录类型选择 <code>CNAME</code> ，主机记录：<code>www</code> ，记录值：xiaocc2012.github.io <em>(就是github pages直接访问的那个url地址)</em></li><li>执行 <code>ping xiaocc2012.github.io</code> 获取IP地址W，新建一条解析，记录类型为 <code>A</code>, 主机记录：<code>@</code>，记录值：W <em>(就是刚才通过 ping 获取的ip地址)</em></li></ol><p><strong>在github上的配置</strong><br>在仓库的 <code>Settings</code> 页面的子选项 <code>GitHub Pages</code> 中的 <code>Custom domain</code> 选项中填入自己申请的域名：<code>www.xxx.yyy</code><br>等待约1分钟，待github重新发布页面，就可以通过自己的域名访问网站啦</p><h4><span id="更换主题等个性化配置">更换主题等个性化配置</span></h4><p>hexo默认主题个人不是很喜欢，更换成了next主题，流程如下：<br>进入blog目录 <code>cd blog</code><br>执行 <code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code> 下载next主题<br>打开站点的 <code>_config.yml</code> 配置文件，将主题更换为next主题 <code>theme: next</code><br>执行预览网站的相关命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>在浏览器打开：localhost:4000 预览网站，会发现网站主题样式已经更改<br>将新网站推送至github<br><code>hexo d</code><br>通过自己申请的域名进行访问，也会发现网站样式已经更改</p><p>至此，采用hexo + github pages搭建博客全流程完毕，其它hexo用法与配置就需要各位去探索啦<br><em>enjoy a good time！</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上查找资料时候碰到很多有意思的技术博客，也一直想拥有个人主页，可是拖延症晚期患者，&lt;br&gt;总是由于各种原因，迟迟未能动手搭建。&lt;br&gt;昨天周六在公司加班，没什么特别紧急的事情，决定把这个坑填上。经过多方面查找资料与实践，有了如今这个小窝，感谢各位知识的分享者。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.xiaocc.xyz/2018-05-05/hello-world/"/>
    <id>http://www.xiaocc.xyz/2018-05-05/hello-world/</id>
    <published>2018-05-05T08:07:50.631Z</published>
    <updated>2018-05-06T04:34:20.140Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo用法简介</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo用法简介&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从strncpy的实现说起</title>
    <link href="http://www.xiaocc.xyz/2018-05-05/linux-kernel-strncpy/"/>
    <id>http://www.xiaocc.xyz/2018-05-05/linux-kernel-strncpy/</id>
    <published>2018-05-05T05:32:37.000Z</published>
    <updated>2018-05-06T04:37:24.167Z</updated>
    
    <content type="html"><![CDATA[<p><code>strncpy</code>函数的内核实现与分析</p><a id="more"></a><p>第一次阅读内核源码是在网上浏览博客的时候，有个博主说<code>strncpy</code>的执行效率很低，而且并不是绝对安全，也存在缓冲区溢出的风险。</p><p>先贴出来其实现，再逐行分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HAVE_ARCH_STRNCPY</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strncpy - Copy a length-limited, %NUL-terminated string</span></span><br><span class="line"><span class="comment"> * @dest: Where to copy the string to</span></span><br><span class="line"><span class="comment"> * @src: Where to copy the string from</span></span><br><span class="line"><span class="comment"> * @count: The maximum number of bytes to copy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The result is not %NUL-terminated if the source exceeds</span></span><br><span class="line"><span class="comment"> * @count bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In the case where the length of @src is less than  that  of</span></span><br><span class="line"><span class="comment"> * count, the remainder of @dest will be padded with %NUL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = dest;(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count) &#123;(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> ((*tmp = *src) != <span class="number">0</span>)(<span class="number">3</span>)</span><br><span class="line">            src++;(<span class="number">4</span>)</span><br><span class="line">        tmp++;(<span class="number">5</span>)</span><br><span class="line">        count--;(<span class="number">6</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;(<span class="number">7</span>)</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(<span class="built_in">strncpy</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3><span id="首先我们整体看一下函数的执行流程">首先，我们整体看一下函数的执行流程</span></h3><ol><li>行1，将tmp指向dest</li><li>行2，初次进入while循环时，count为dest大小</li><li>行3，将src的内容赋值给tmp</li><li>行4，如果src没有移动到字符串末尾的<code>\0</code>，则把src往后移动一个字节</li><li>行5，tmp向后移动一个字节</li><li>行6，count减1</li></ol><h4><span id="简单来说该函数把src的内容往dest拷贝最多拷贝count个字节">简单来说，该函数把src的内容往dest拷贝，最多拷贝count个字节</span></h4><h4><span id="但是这里有几个关键问题"><strong>但是这里有几个关键问题</strong></span></h4><ol><li>如果src的长度 &gt;= count 会发生什么？</li><li>如果src的长度 &lt; count，该函数性能如何？</li></ol><h4><span id="问题1">问题1：</span></h4><p>如果<code>src_len &gt;= count</code>，根据<code>行2</code>、<code>行3</code>可知，dest会被填充count字节，也就是说src的前count字节会被copy到dest，所以dest末尾并不是<code>\0</code>。</p><h4><span id="问题2">问题2：</span></h4><p>如果src_len &lt; count，考虑边界情况，假设当前src指向字符串末尾（也就是<code>\0</code>的前一个字符），则<code>行3</code>把src的值赋值到tmp，<code>行4</code>src往后移动一个字节，指向<code>\0</code>，行5、行6，把tmp向后移动一个字节，count减1，while循环进入下一次，<code>行3</code>把src的值（也就是<code>\0</code>）赋值给tmp，注意观察<code>行3</code>，此时<code>if</code>语句值为false，src不向后移动（所以src依然指向<code>\0</code>），行5、行6，tmp向后移动，count减1。再次进入下一次循环，<code>行3</code>，把src的当前值（<code>\0</code>）赋值给tmp，<code>if</code>语句值为false，src不向后移动，tmp向后移动，count减1。<strong>所以，此情况下，该函数会使用<code>\0</code>填充dest剩下的全部字节。</strong></p><h4><span id="看看如下常用的使用方式">看看如下常用的使用方式：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buff[1024];</span><br><span class="line">const char* src = &quot;hello world&quot;;</span><br><span class="line">strncpy(buff, src, sizeof(buff));</span><br></pre></td></tr></table></figure><p>把src内容拷贝到buff后，会将剩余的空间全部填充0，效率非常低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buff[5];</span><br><span class="line">const char* src = &quot;hello world&quot;;</span><br><span class="line">strncpy(buff, src, sizeof(buff));</span><br></pre></td></tr></table></figure><p>buff的长度比src长度要小，buff末尾并不是<code>\0</code>，需要添加如下语句才能避免缓冲区溢出问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buff[sizeof(buff) - 1] = 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;strncpy&lt;/code&gt;函数的内核实现与分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux kernel" scheme="http://www.xiaocc.xyz/tags/linux-kernel/"/>
    
      <category term="strncpy" scheme="http://www.xiaocc.xyz/tags/strncpy/"/>
    
  </entry>
  
</feed>
